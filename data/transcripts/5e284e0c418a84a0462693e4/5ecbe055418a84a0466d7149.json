{
  "pid": "5e284e0c418a84a0462693e4",
  "eid": "5ecbe055418a84a0466d7149",
  "title": "58. Kerning Panic·字谈字串（九）名名之中",
  "task_id": "2yjoqzbmw6w8q68l",
  "transcription": [
    {
      "time": "00:00:00",
      "text": "321开始。",
      "speaker": "发言人1"
    },
    {
      "time": "00:00:23",
      "text": "大家好，今天是2020年的5月26号，也是自弹自唱的第126期。",
      "speaker": "发言人1"
    },
    {
      "time": "00:00:29",
      "text": "您正在收听内核恐慌，一档大致以计算机科技为主题的娱乐podcast。我们号称硬核，但是也没有什么干货，想听就听，不想听就别听，这是我们的第58期.",
      "speaker": "发言人2"
    },
    {
      "time": "00:00:42",
      "text": "是啊这同时也是我们自弹自唱和内核恐慌串台的自弹自唱的第九期。自弹自唱是全球首家用华语制作的字体打印主题播客节目。我是主播汶川西判斗营区eric.",
      "speaker": "发言人1"
    },
    {
      "time": "00:00:57",
      "text": "我是主播黄浦江边清蒸鱼钱蒸鱼。",
      "speaker": "发言人4"
    },
    {
      "time": "00:01:00",
      "text": "我是吴涛，我是real。我们都串了九期了。",
      "speaker": "发言人3"
    },
    {
      "time": "00:01:05",
      "text": "对，然后我们上一期是一年之前录的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:01:11",
      "text": "我们串了九期了，我们都还没有抬头。就是你们前面那个很酷炫的那个title.",
      "speaker": "发言人3"
    },
    {
      "time": "00:01:17",
      "text": "我们曾经有过，但是我们觉得太awkward，所以我们放弃了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:01:22",
      "text": "距离上次自弹自唱第八期哈那期是叫什么人造千年宠物，那时还是令和元年对吧？2019年的5月14号刚刚好是整整一年。在这一年里面我们的自弹自唱从第99期更新到126期，内核同框从第55期更新到了第58期，是吧？",
      "speaker": "发言人1"
    },
    {
      "time": "00:01:47",
      "text": "沧海桑田中间经历了多少巨变。",
      "speaker": "发言人2"
    },
    {
      "time": "00:01:50",
      "text": "人家都两位数变三位数了，我们还缓慢的爬行了，我们总共更新了三期。",
      "speaker": "发言人3"
    },
    {
      "time": "00:01:57",
      "text": "但是你们很厉害，你们这图标也变了，或那个域名也变了，然后连官网的字体都换掉了。",
      "speaker": "发言人1"
    },
    {
      "time": "00:02:04",
      "text": "对，我们这个是应该是2020年有什么改头换面了。",
      "speaker": "发言人3"
    },
    {
      "time": "00:02:08",
      "text": "之前功夫都用在节目之外了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:02:10",
      "text": "应该说这叫看得见的地方，对，听不见的地方。",
      "speaker": "发言人3"
    },
    {
      "time": "00:02:15",
      "text": "现在说实话，我现在打了个趴，你哭还是感觉很有违和感知道吗？",
      "speaker": "发言人1"
    },
    {
      "time": "00:02:21",
      "text": "为什么？这不挺好的吗？怕你哭多好，好乖，听起来很很日本。",
      "speaker": "发言人3"
    },
    {
      "time": "00:02:28",
      "text": "然后这个点阵字看起来还感觉挺好的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:02:31",
      "text": "不过对点阵字就是因为上次听了你们应该是最新一期节目，就是低毛期还是上前一期。",
      "speaker": "发言人3"
    },
    {
      "time": "00:02:38",
      "text": "因为我们是前一期了。",
      "speaker": "发言人1"
    },
    {
      "time": "00:02:40",
      "text": "已经是对前一期的太好，你们那个速度比较快。然后我就说我之前本来一直想换的，因为之前先我们是先换的这个logo，先换的那个像素点，也不叫像素点。那个叫什么？我叫LED灯的这个风格的logo，那圆的。对对对，当时我就想说，那干脆拿这个风格把这个正文字也换了，不是有这个refund。但是后来转念一想，那中文字体的外放马上就劝退了。",
      "speaker": "发言人3"
    },
    {
      "time": "00:03:09",
      "text": "因为都知道这个体积会比较惊人，对吧？那后来听你们前一期节目找这个威力来聊的时候，我在想，如果是纯点阵的，那不就没有这个体积问题了吗？因为我简单算了一下这个数，对吧？假设我是一个十像素乘以十像素的汉字，那么一个像就算我不压缩的情况下，我一个焊一个方块就是100个bit。100个bit除以八才多少？不到20个这个bit对吧？算下来还然后再再稍微压缩一下，应该是可以接受的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:03:43",
      "text": "但是问题是丁卯它不是真正的点阵，它其实还是矢量字问题。",
      "speaker": "发言人1"
    },
    {
      "time": "00:03:47",
      "text": "这就是我遇到的第一个问题，就是后来显示没有办法，是真的使用在这个就是wifi放在真的是没有办法使用点阵字体的。就好像跟威廉那期你们也聊了，windows的自带的那个系统字体，还有好几个都是有那个内嵌点阵的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:04:03",
      "text": "对，这个就所谓的中译宋体。",
      "speaker": "发言人1"
    },
    {
      "time": "00:04:06",
      "text": "对还包括之前在古早时期的这个linux系统里面，有那个叫文泉驿那套的东西。",
      "speaker": "发言人3"
    },
    {
      "time": "00:04:13",
      "text": "你知道吧？",
      "speaker": "发言人2"
    },
    {
      "time": "00:04:14",
      "text": "那应该是PCF吗？这个格式我不知道，我就说就是文泉驿他们当时也做过，就是那种他做过那个就是他叫他们叫他叫他叫开源，我不知道，就是免费的这种就自由的这种中文点阵字，他做了一个高质量的，他当时是应该是中文互联网上比较早的那种crowd sourcing的项目。因为他当时我记得是做了一个，网页，那个时候还挺不容易的。那个时候网页技术都比较落后，他们用通过这个网页的方式让大家去拆这个字，然后点这个像素点，然后就是他们也那那边也有一套点阵子。但是这些都是没有办法用到那个refund里面的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:04:52",
      "text": "因为web fund那个目前主流的几个格式，就最开始的那个EOT什么叫做embedded open type对吧？后来的这个svg包括在目前最新的那个wolf和那个wolf 2，对吧？他们在那个生成的时候就直接是不支持这个内嵌点阵的，所以这条路就是断掉的。所以你上期这个威力，他做那个也是一个折折中的方案，就是用矢量来模拟点阵的那种风格对吧？但是你还别说这个其实还是有用的。虽然说不是一个真正的点阵，我要我要表达一个十个像素乘以十个像素的字符，并不能真的只用100个bat就可以实现。但是因为极度简化过的那个方那个就是微微点阵，就是矢量点阵它其实是一个各种各样的小方块，对吧？小方块的就有一个好处，它就什么没有这个什么什么曲贝塞尔曲线这些转角什么的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:05:50",
      "text": "它的那个点就比较少。",
      "speaker": "发言人1"
    },
    {
      "time": "00:05:52",
      "text": "没错，你你你想这个道理，OK确实就是拿这个威利，他拿这个他给他给了我一个demo的DTF，然后我把它转成沃夫2 waf 2是wolf的那个升级版，它的压缩比例又提高了百分之好像20左右，应该是。那其实我我压完了之后，他当时给的是一套还在贝塔中的低毛体的文件给我们。我压完之后，其实也就才不到500KB的那个大小，挺好的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:06:20",
      "text": "对对对，就500KB可能在比如说在五年前，可能还是一个有一点纠结的这个尺寸。因为毕竟还是网络要下载，然后带宽不高的情况下，他现在在500KP就我们这个有4G网络，马上5G网络对吧？又是光纤入户，都还挺多的。500KB的话，你其实你在这个instagram上刷刷一张图，估计都都不止500KB了，对吧？很多网页你加载一个什么javascript的库，那可能都是差不多那个水平了。所以完全可以接受。所以我就那其实是可以的，我就换上把我们的这个官网的那个refund，就换上了这个demo作为主。然后再设了一些这个系统自带的一些back up。如果因为某种原因，你的这个系统，你的你浏览器不够现代，或者是你用了什么插件禁用那个web fund的话，那你还是会退到你系统默认的那些字体。所以整个下来风格就还觉得还不错。",
      "speaker": "发言人3"
    },
    {
      "time": "00:07:19",
      "text": "用这种假的点阵的话，其实其实是矢量。但是你这样用容易用，要不然的话你点阵真点阵的话，你那个字号不好弄。",
      "speaker": "发言人1"
    },
    {
      "time": "00:07:32",
      "text": "对，就是有这个我点阵的话。",
      "speaker": "发言人3"
    },
    {
      "time": "00:07:34",
      "text": "你一个字号要一套点阵，反而这种假点阵的话，你可以你可以随意缩放。对，反而更好。",
      "speaker": "发言人1"
    },
    {
      "time": "00:07:42",
      "text": "是因为你如果用真点阵的话，缩放的话因为其实现在我想想，我们至少在英特尔出那个还有AMD，出下一代的那个显卡之前，我们目前所用的这个就是显卡，包括不管内嵌的也好，还是独立的，包括手机上的也好，他都不能做，我们叫做这个整数倍缩放。什么意思呢？就是比如说我要我们现在用的这个什么所谓高分，不是高清屏，有什么二叉三叉的，什么意思？就是相当于有一个像素点。它我们之前讨论过，是用可能是用四个物理点或者是九个物理点，就是22乘以2或者3乘以3的这个格子来做。",
      "speaker": "发言人3"
    },
    {
      "time": "00:08:20",
      "text": "所谓的这个整数倍缩放什么意思呢？就是说假设我是一个4K的屏幕，对不对？但是你想那个4K游戏它有很多特效，不是这显卡的处理的就跟不上，所以很多很多时候他只能用就放这个1080来的这个分辨率来来来显示这个游戏，对吧？但是1080分辨率，但是你又是4K4K就刚好是1111080的屏幕的那个拼就是在田字格拼起来，对吧？",
      "speaker": "发言人3"
    },
    {
      "time": "00:08:47",
      "text": "那这就有个问题了，一个108的像素点是对应4444K的像素点。我们通常讲肯定就是说把那四个物理像素点都是都渲染成一个逻辑像素点的颜色。那这样不就看起来虽然说是4444K的屏幕，但看起来还是10801080的清晰，那么锐利，对不对？但其实并不是这样子的，因为现在主主的显卡都是叫做它叫什么liar的这种那个词叫什么来着？Interpolate对，interpolate就是他就会去差值值差值去算。比如说我要如果你你想象一下这么一个场景，你说你这个1080的屏幕上，从左到右是一个从白到黑的一个渐进的一个过渡，对吧？正常的话，如果说你是在4K屏幕上显示，那你说你每一个线条绘制两遍，就是没没数，没数行你就绘制两遍，对不对？但其实并不是这样，他还是要在4K上，他是要算出那两条1080的中间值是怎么样子，然后再把那个中间值绘制在4K的多出来的像素，那那那束的这个像素上面的去吧，在这个网页的上面其实有类似的问题。",
      "speaker": "发言人3"
    },
    {
      "time": "00:09:52",
      "text": "就是说我本来说我有一个比如说是这个10乘以十像素的这个点阵字，那我能不能渲染到这个20乘以20这个面对上去，其实是做不到的，对不对？OK在这个情况下，就刚才艾瑞克说那个问题，就是说你反而用这种微叫伪点阵，这就是用矢量来模拟的反而更好，它可以缩放一点。但是我遇到一个问题，就是现在这个网页那个CSS里面那个宽度，还有有可能我不是按这个整数像素来定的那个宽度它可能比如说是一个百分比是吧？百分比之后他算出来的，他最后还是要落实的。他的这个叫什么？就是restore zed的时候，知道什么叫三句话的时候的时候，它还是会会变成要要变成一个具体的到哪一个像素点的坐标上去。有时候如果你是按百分比的话，它不就除不尽，它就有这个小数，那么就变成了这个就结合到我们之前几期谈过的那个次像素平滑的问题，对吧？",
      "speaker": "发言人3"
    },
    {
      "time": "00:10:46",
      "text": "对，以前是灰度平滑，我先还是一个像素，我不不考虑这个LCD屏幕这个子像素的结构，我直接按灰度平滑。比如说我们现在在这个IOS设备上面都是这样子的对吧？它是没有这个次像素平滑，都是灰度平滑的话，这样的话就相对来说还好一点。它就是最多是在左边一个像素或右边一个像素，或者他如果他觉得这个应该是两个像素之间。他可能在这个灰度上面做一些平均，对不对？",
      "speaker": "发言人3"
    },
    {
      "time": "00:11:11",
      "text": "但是就会导致我这个丁卯点阵题，本来我想到的效果是应该是非常边缘锐利。我把它那个那个叫做像素的字体的尺寸调好的话，它边缘应该是非常锐利的。但是因为由于这个非整数的这个宽度的问题，他可能那个字的那那一竖，就是说他起止的那个位置，他在排版引擎加上这个三更换之后删除。它是在这个从左到右第32.57个像素点这可是那个时候再开始绘制，这个时候怎么办的？就是你还是会看到在有些地方，它的这个字的边缘是有一层那个叫什么，就是灰灰的那种感觉的。如果说你是有这个次像素平滑，然后你这个人眼睛又比较敏感，或者是你的屏幕素质是有一点问题的话，你看到它可能边上有一点点就叫那个彩边儿。对，彩边儿那个clear type那种常见的问题，所以就还是挺头疼的这个事情。",
      "speaker": "发言人3"
    },
    {
      "time": "00:12:07",
      "text": "对。",
      "speaker": "发言人2"
    },
    {
      "time": "00:12:08",
      "text": "那毕竟你是假点阵。",
      "speaker": "发言人1"
    },
    {
      "time": "00:12:11",
      "text": "对对对，就假点阵这个问题。但是刚才你说的那个缩放的问题，其实这里还是有一点技巧的。并不是说我因为是这个为真实量为点正就可以自由缩放了。其实也我要达到刚才那种就是pixel to pixel，像素点对像素点的那种清晰和锐利的话，其实还是有讲究的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:12:29",
      "text": "比如说我用的那个正文体是丁卯的，丁卯其实只有两个尺寸，就是七像素和九像素，对吧？七像素、九像素，它其实是因为有一个像素的留白的话，它其实是八像素宽和十像素宽的这么一个字体，对吧？这样你在CSS里面设置的时候，你就要设置成正常你应该设置成十个像素，对不对？但是因为十个像素实在是太小了，因为现在很多屏幕的这个分辨率挺挺高的，而且手机上你强制设置十个像素，它也字也比较小，所以我就设置成了15。15你想不就除不尽了，对不对？",
      "speaker": "发言人3"
    },
    {
      "time": "00:13:04",
      "text": "你必须把它量子化。",
      "speaker": "发言人2"
    },
    {
      "time": "00:13:05",
      "text": "它其实是可以的。因为我看目前我们大部分人用的这个，不管是笔记本也好，还是这个就至少mac mac现在应该已经没有这个非大屏幕的mac在销售了。",
      "speaker": "发言人3"
    },
    {
      "time": "00:13:15",
      "text": "对吧？销售肯定没有了，但使用肯定还是有的。而且你要考虑到外接显示器这个问题。",
      "speaker": "发言人2"
    },
    {
      "time": "00:13:21",
      "text": "基本上至少是所有的mac就是新基和所有的目前应该在试的这个IOS的，应该都是所谓的高分屏，就retina屏幕对不对？就有两种了，我们一种是常见的mac都是二叉的对吧？然后还有那个叫什么iphone这个什么，比如说11 pro它是333倍的那个三三叉的。对，那三叉的话就相对来说我就那个就相对来说我也没有那个设备，所以我都是两叉的设备。我觉得这是15个像素，15个像素的逻辑其实对应30个像素的物理，对不对？OK30个像素的物理除以十个像素的这个低昴的点阵体不也能是三倍。",
      "speaker": "发言人3"
    },
    {
      "time": "00:14:02",
      "text": "所以它是最小的最小公倍数。",
      "speaker": "发言人1"
    },
    {
      "time": "00:14:04",
      "text": "对对对，找搞个它能够整除的地方就还挺好的。但是问题就来了，我后来我想起来了，你记不记得你们有买最新的macbook pro的笔记本？就最近两三年的。特别是13寸的那个那个机器。",
      "speaker": "发言人3"
    },
    {
      "time": "00:14:21",
      "text": "没有想买，没有没没有人给我们捐款。",
      "speaker": "发言人2"
    },
    {
      "time": "00:14:26",
      "text": "对这个我们忘了在节目里面说了，请大家给我们捐款。",
      "speaker": "发言人3"
    },
    {
      "time": "00:14:31",
      "text": "详情请见我们没有人用爱。",
      "speaker": "发言人2"
    },
    {
      "time": "00:14:34",
      "text": "用发点IC，说回来，就是13寸那个机型的那个屏幕的那个那个面板的分辨率是，我记得是2560乘以1600，应该是这样。它的逻辑是21280乘以800，1280乘以800在当下其实是一个非常窄的一个显示的面积，对不对？所以苹果后来应该我记得应该是在前几年开始，应该就是最近这一代，把蝴蝶键盘那那代开始。",
      "speaker": "发言人3"
    },
    {
      "time": "00:15:06",
      "text": "它的那个出厂默认设置，13寸的那个macbook的的默认的分辨率，它并不是点对点的清晰的。他用了一个它的默认值是一个缩放的，就是它缩放出来应该是个1440乘以900的这么一个逻辑的分辨率。但其实它的物理上它并除不尽，你就就2560除以这个1440是除不尽的，12560刚好是1280的2倍，所以它虽然说是逻辑上的这个二叉，但它物理上并不，物理上并不是。",
      "speaker": "发言人3"
    },
    {
      "time": "00:15:40",
      "text": "他只是没有点到点，就是他推荐的那个设置没有点到点。",
      "speaker": "发言人4"
    },
    {
      "time": "00:15:45",
      "text": "对对对，他现在我已经完全不点对点了。",
      "speaker": "发言人1"
    },
    {
      "time": "00:15:48",
      "text": "所有的但我都是调到点到点的。比如我现在这台15寸的，我不用它默认的那个缩放，我就会改成正好是两倍的那个分辨率。",
      "speaker": "发言人4"
    },
    {
      "time": "00:15:57",
      "text": "对，因为15寸它原生的这个点点分辨率应该是1440宽的，对吧？",
      "speaker": "发言人3"
    },
    {
      "time": "00:16:02",
      "text": "它其实调整他推荐你设的是1680乘1050。",
      "speaker": "发言人4"
    },
    {
      "time": "00:16:05",
      "text": "对对对，它都都是都是都是变成这我们叫做scale mode，就是缩放模式对不对？",
      "speaker": "发言人3"
    },
    {
      "time": "00:16:09",
      "text": "对它可以让你的屏幕看起来容量更大一点。",
      "speaker": "发言人4"
    },
    {
      "time": "00:16:12",
      "text": "对对对，因为它就是要展示更多的内容，但是其实这样是会影响它。",
      "speaker": "发言人3"
    },
    {
      "time": "00:16:16",
      "text": "可以让你的视力下降会更快一点。",
      "speaker": "发言人2"
    },
    {
      "time": "00:16:19",
      "text": "其实你看绝大部分人是看不出来的。但是如果说你对这个点对点这种有洁癖的话，比如说我们如果要强行用这个低锚点阵，要打个点阵，要点对点的话，你在这两个就是你在最新的这个macbook笔记本上是实现不了的。对吧？因为它默认值不是那样子的，所以我都是把那个默认值调，我都是手动把它改成二叉的那个连接点的模式，这样我看起来那些才正常。但这样的后果就是说你的可显示的这个实际面积感觉就变小了。",
      "speaker": "发言人3"
    },
    {
      "time": "00:16:50",
      "text": "就字儿更大。对对对，它的设置不是就是选你要么选较大文字，要么选更多空间，字很小的空间更大。他的那他们那个系统设计就只能这样选。",
      "speaker": "发言人1"
    },
    {
      "time": "00:17:05",
      "text": "对，那这样就会很影响。比就本来之前，你说你只是你做设计的人有这个问题，你把这个调一下，你这样看出你交付的作品还是这个点对点清晰的，对不对？但现在这个默认值变成这个skill model，就是说你哪怕你交付的作品是点对点清晰的。最后你就是用户炫看到的时候，他其实也是被这个scale掉了。所以这个事情我觉得挺挺扯的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:17:27",
      "text": "所以他他的意思就是你别纠结这个事情。",
      "speaker": "发言人1"
    },
    {
      "time": "00:17:30",
      "text": "已经突破了视觉极限了是吧？",
      "speaker": "发言人3"
    },
    {
      "time": "00:17:32",
      "text": "IOS设备的话没有办法了。",
      "speaker": "发言人1"
    },
    {
      "time": "00:17:33",
      "text": "IOS至少目前还是信息。",
      "speaker": "发言人3"
    },
    {
      "time": "00:17:35",
      "text": "我觉得他的意思其实是普通用户根本不应该操心这些事情。",
      "speaker": "发言人2"
    },
    {
      "time": "00:17:39",
      "text": "对，但是这还是一个compromise，就是说在显卡的这个处理能力，面板的这个叫什么？就是这个显示就是显卡到面板的连接带宽以及面板的实际的工艺的限制的情况下，做出了这么一个compromise。但我觉得这毕竟不是长脸之际。",
      "speaker": "发言人3"
    },
    {
      "time": "00:18:02",
      "text": "我又想起来我因为我实际主力机是27寸的那个imac，是5K的屏。那个显卡是想就可以看得出来，他很很吃力，你知道吗？",
      "speaker": "发言人1"
    },
    {
      "time": "00:18:14",
      "text": "刷屏我可以感觉到显卡很吃力，这个共情能力真的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:18:19",
      "text": "5K的屏幕，你渲染的时候得多大？",
      "speaker": "发言人3"
    },
    {
      "time": "00:18:21",
      "text": "你想一想那个5K的屏，你抓个屏，对，刷个屏出来11个1个PNG文件的话，那个也是超大的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:18:30",
      "text": "对还那个还是减无损压缩的，都可能有好几兆了。对，anyway就说回那个低毛点阵。所以当时我们我就试了一下，我就感觉效果还行。然后我就跟这个威利说这个事儿，然后他还帮我们做了很多其他的事情。因为丁卯他应该是我，如果我没记错，应该是我们是就应该是我们网站应该是第一个正式商用的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:18:54",
      "text": "贵网站是第一个正式商用的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:18:57",
      "text": "对对对，然后他就其实遇到了很多问题，比如说你像我们上一次节目的时候，不是有讨论这个令和这个盒子，对不对？",
      "speaker": "发言人3"
    },
    {
      "time": "00:19:08",
      "text": "他做了，我记得对那个。",
      "speaker": "发言人1"
    },
    {
      "time": "00:19:10",
      "text": "令和是丁宝里面他唯一做了两个令和连就是合在一起的。但这个时候其实已经很为难了，对不对？一个十像素乘以十像素点阵，你要还要做核干旱，自己去。我看了一下，反正也是比较勉强。当时我还鼓动这个威力说，那你要不要去把这个。",
      "speaker": "发言人3"
    },
    {
      "time": "00:19:27",
      "text": "挑战一下极限。",
      "speaker": "发言人2"
    },
    {
      "time": "00:19:29",
      "text": "把前面那几个都做完，那个叫什么昭和对吧？从这儿开始一直在做，他说不做了不做了，我说九江还。",
      "speaker": "发言人3"
    },
    {
      "time": "00:19:36",
      "text": "还有九江是做昭和，我天哪。",
      "speaker": "发言人2"
    },
    {
      "time": "00:19:38",
      "text": "这还不是正常的。还有日文株式会社。",
      "speaker": "发言人3"
    },
    {
      "time": "00:19:43",
      "text": "我觉得做大众可能还可以想象做其他的，oh my god.",
      "speaker": "发言人2"
    },
    {
      "time": "00:19:48",
      "text": "那株式会社怎么办？",
      "speaker": "发言人3"
    },
    {
      "time": "00:19:50",
      "text": "不要说这些了，那当然是不要说盒子，就写一个和什么雷霆万钧，那个那个都都已经。",
      "speaker": "发言人1"
    },
    {
      "time": "00:19:58",
      "text": "写了一坨的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:19:59",
      "text": "对，这个我就担心怕那个不易读，然后我就套上之后我就做了一个这个use ability test。就是找的主要是找我太太拿来试了一下。我就把我们有一期节目的那个那个叫summary，就是那个叫什么节目简介。他有一段话，写了一段话，就是50 57期节目有一段话，我先把那个点换上他那些点对点都调好，然后我让他来读那段话基本就还挺挺超乎我意外的，就是还基本上没有出什么差错。",
      "speaker": "发言人3"
    },
    {
      "time": "00:20:27",
      "text": "易认性还是很好的。对，而且主要是你放在这个有上下文之类的话，没错就没错，可以猜，对吧？有语境的话就可以猜。",
      "speaker": "发言人1"
    },
    {
      "time": "00:20:36",
      "text": "而且我用的是那个999像素那款，九像素那款相对来说还是看得清楚一些的。旗下做贷款，如果没有上下文确实有点难度了。",
      "speaker": "发言人3"
    },
    {
      "time": "00:20:44",
      "text": "这关键是有语境的话就好。",
      "speaker": "发言人1"
    },
    {
      "time": "00:20:46",
      "text": "是的，所以我就想，反正我们这个网站看的人也不多，对吧？因为大部分都是在这个，主要是订订阅订阅在这个I就是博客客户端里面去去去看的，也不会说经常去我们网页翻来翻去，对吧？所以想那不刚好我们这个网页还可以做的这个风格别致一点，反正也不怎么常读它，吧？也没几个字儿。其实对，就不像我你们还要发这个你们官网这type官网还要发很多波纹什么的。我们一般就一期节目可能不到100个字的这个汉字，对吧？完全没有问题。",
      "speaker": "发言人3"
    },
    {
      "time": "00:21:18",
      "text": "每一期节目来看的人也就100个。",
      "speaker": "发言人2"
    },
    {
      "time": "00:21:22",
      "text": "我很怀疑，我怀疑。对，anyway就这样的话，我就把那个低码用起来。然后好，但是其实我们还遇到了其他很大其他很多问题。比如说我们上次不是也是讨论这个，那期节目除了讨论有些讨论日本的地方就很多，那个叫show note里面有很多日文的符号吗？然后刚好这个低保里面那威力他也做了日文的那些什么，就是对他的有那些是吧？对，就看我效果还挺好的，超乎我的意料。后来他他交付给我的就是为了提，还是为了这个体积的原因，我就说我们大概率应该不会讲，不会也不会打，主要是也不会用什么阿拉伯文和希伯来文，就把那几个符号给去掉了。",
      "speaker": "发言人3"
    },
    {
      "time": "00:22:04",
      "text": "然后我问威廉说他应该是没有韩文的部分的，因为韩文好像挺坑的，就是比较难做。但我们想一下，好像我们官网也没有韩文。这个也还也也就过去了。",
      "speaker": "发言人3"
    },
    {
      "time": "00:22:15",
      "text": "但是又遇到另外一个问题，就是我们毕竟是一个面向中老年程序员的一个节目。所以比如有有一有一有两期节目是有贴代码的，有一小段代码，那么我就需要一个等宽的这个拉丁字符，然后威利就帮我们调了一个，这个最开始是用了一个六七像素，但就是有些这个还是有些问题。后来他又专门帮我们定制了一个等宽的点阵字。但是就不是严格跟中文有等比的关系了。但其实，因为我不需要跟中文配配对用。然后另外一个场景就是我们不是之前每期节目吴涛都会有一句gan，反正就slogan在本期的口号是对对对对，我们那个那个slogan在排版上，在网页上排版那句slogan是斜体排的。所以温柔又给我们定制了一套斜体字的这个丁卯点阵的这个英文字符当时因为有一个事情过于疯狂，我们只是在微信上简单聊了一下，这个事情并没有真的发生。你说他其实中文也有写题的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:23:30",
      "text": "所以这个鞋底是威利做的是吧？是威利做的其实还可以。",
      "speaker": "发言人1"
    },
    {
      "time": "00:23:34",
      "text": "这也是调了几次。对。",
      "speaker": "发言人3"
    },
    {
      "time": "00:23:36",
      "text": "就是是拉丁字母的鞋底。",
      "speaker": "发言人4"
    },
    {
      "time": "00:23:38",
      "text": "我想知道它是自动生成的，这是一个程序生成的，还是它一个一个自己。",
      "speaker": "发言人2"
    },
    {
      "time": "00:23:43",
      "text": "去排了一个这个点对自己做的。最开始是那个程序生产，其实就不是那个不是鞋底，是叫做abc是不是？",
      "speaker": "发言人3"
    },
    {
      "time": "00:23:51",
      "text": "那不是italic.",
      "speaker": "发言人4"
    },
    {
      "time": "00:23:53",
      "text": "是真斜体，我有个伪斜体，就直接把那个点阵fox拉斜了。最最开始是那个，就当时我都没有留意到这个问题，因为我我都忘了我们有用鞋体的地方了，因为最近急都没有用了。",
      "speaker": "发言人3"
    },
    {
      "time": "00:24:06",
      "text": "得亏吴涛说了那么多口号，都被你忘了。",
      "speaker": "发言人1"
    },
    {
      "time": "00:24:10",
      "text": "中文用斜体是异端，中文用写的地方应该用楷体吗？",
      "speaker": "发言人2"
    },
    {
      "time": "00:24:13",
      "text": "不是，就是我们口号都是英文的。对对，所以就是只是英文的一部分。但是我开始没有意识到，后来是我把那个那个丁卯Y不就是部署成本放到网上去，然后让威廉来看这个烧火的时候，他发现的。然后他说这个鞋底好像是有点问题，他就修了一下。他给了我单独的一个，就之前给了我单独的一个，这个叫做他叫dicky，dicky code就是那个等宽的，后来又做了这个dicky的这个italy x你这但这两个都是只包含这个拉丁和常用符号那部分了，其他的中文肯定没有办法做做鞋底。这么小的这个情况下，但其实你看那个鞋体的话，它的那个易读性就要比那个正正普通的那个正常版本就差好多了。",
      "speaker": "发言人3"
    },
    {
      "time": "00:24:58",
      "text": "那肯定的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:24:59",
      "text": "就抖就就就真斜体的可读性是要差的，但是伪斜体那个之前的易读性还是挺不错的，很奇怪对不对？",
      "speaker": "发言人3"
    },
    {
      "time": "00:25:10",
      "text": "不，这个网页看习惯了以后，反而就已经习惯了这个点阵看习惯了，反而就看比如说咱们那个自弹自唱的第三期，那个表情符号超清晰的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:25:25",
      "text": "人那种反差感特别强烈，是不是？对这个。",
      "speaker": "发言人3"
    },
    {
      "time": "00:25:30",
      "text": "太魔幻了。对。",
      "speaker": "发言人1"
    },
    {
      "time": "00:25:33",
      "text": "反正我目前就还是挺满意这个显示效果的。虽然说就刚才有说如果你仔细看的话，有一些这个，但根据你浏览器宽度，因为它那个那个分栏是自适应的，在某些宽度下面它就会出现那个那个叫做灰边的问题。但是有些情况下，它如果你刚好恰好的分散出来，都是整数倍的这个像素，就不出现这个定位，就是半个像素的，或者是就小于一个像素的情况下，它的每个边缘都是非常，他还要加这个星号，你前提是你在一个真的可以点对点显示的这个二这个二叉或者三叉屏幕上才可以，对吧？因为刚才讲的这个麦克的那。",
      "speaker": "发言人3"
    },
    {
      "time": "00:26:11",
      "text": "其实你特别在意。如果你特别在意这个显示器，或者说是这个应该其实这个应该是浏览器带来的这个次像素渲染，或者是其他的一些抗拒持续就会带动你可以在CSS里把它关掉。",
      "speaker": "发言人4"
    },
    {
      "time": "00:26:26",
      "text": "关掉没有用，关掉不解决刚才那个问题。",
      "speaker": "发言人3"
    },
    {
      "time": "00:26:30",
      "text": "可以一定程度上缓解。因为CSS里面至少很多浏览器都支持entirely的设计。",
      "speaker": "发言人4"
    },
    {
      "time": "00:26:37",
      "text": "我知道我试过那个那个效果比较糟糕。",
      "speaker": "发言人3"
    },
    {
      "time": "00:26:40",
      "text": "这个还是跟底层操作系统有关，就是你在mac和windows上不能使用同样的CS规则来达到同样的效果。",
      "speaker": "发言人2"
    },
    {
      "time": "00:26:47",
      "text": "这是最大的问题。可以把几个浏览器兼容的CSS全写上。",
      "speaker": "发言人4"
    },
    {
      "time": "00:26:51",
      "text": "他只要不冲突的话，都可以都写上。就啰嗦一点。",
      "speaker": "发言人3"
    },
    {
      "time": "00:26:54",
      "text": "不是就是你你同你用同样的规则在mac和windows上得到的效果是不一样的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:26:59",
      "text": "这对对对，就是关掉次像素平滑这个事情，各家的时效上都是都是问题比较多的对，所以因为这个事情也不是一个最常见的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:27:09",
      "text": "4S规则里面有一条就是好像叫tax rainer's，还是叫font render。还有然后他现在有两个，应该是mozilla和web kit各有一个实现。但这两个实现最后得到的效果都是就在watch上要好很多，但是在windows上就还是十一坨。",
      "speaker": "发言人2"
    },
    {
      "time": "00:27:25",
      "text": "对，反正就这个问题是比较多的。所以就刚才那个郑宇说这条，我其实我在开发的时候我已经试过了，那个效果是比反正一个是不一致。一个就是说其实挺糟糕的，而且也不能解决刚才说的，比如说你的那个屏幕不是那点对点导致的这个问题。这个是你不管软件怎么调都调不了的。你一个是你在那个操作系统本身的设置的问题，你这个你是改不了用户设置的，对吧？我又不能检测到说这个用户说是这个不是点对点，我弹个弹窗说，你这个不是点对点，你赶紧把那个点弄回来，对吧？这也不现实。",
      "speaker": "发言人3"
    },
    {
      "time": "00:27:58",
      "text": "然后就是在做完这一套之后，我就在这应该是前两周，就在刷那个还有news，结果发现上面有有竟然有人在搞这个XP点CSS，什么意思？他要用CSS来复原当初的这个windows XP时代。就是什么680 640乘以480像素的那个显示屏，那种那种样那种就是那种像素感不是我们现在追求的那种，其实也算是了，只是说可能不是特别，他是从英文那个事件来做的，他也提到了说怎么用这个外放来来实现这种像素的感，对吧？包括是叫做拟真还原当年的windows常用的那几个字体。比如说像banana，像vana、George，还有像那个times new roman d这些。对，在关掉这个次像素平滑的情况下，实现出点对点渲染的感觉，对吧？但是他其实没有，他是用的也是用这个。因为刚才讲的那个web，它其实不支持这个帧像素字体，都是也是伪像素，也是用那个钉钉卯的类似的手法，不就是把它做成矢量字。但是是那垂死出来的点就是比较整数的那这样的它在rendering在mz过后，就得到的还是一个像素化的感觉的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:29:16",
      "text": "我看到有两个案例在做这件事情的。回头我们可以把这两个案例放到这个show note里面，大家有兴趣的话可以点开看一下。但是我就觉得因为它当然一个是因为拉丁字符的那个数量比较少，而且它那个点也比较好好弄，它的还原式效果还是比较高的。后来我想了一下说，那我能不能还原出这个，比如说我不还原windows XP那种比较难的情况下，我就还原一个以前那个叫什么dos下面的那种什么UC dos，那个中文dos环境那种感觉行不行？对吧？但是就是因为刚才那个不能严格点对点的那个问题，可能还不太好实现，我们现在反正还在研究。吴涛也在最近最近也在做类似风格的事情，所以我们都刚好凑到一块儿了。",
      "speaker": "发言人3"
    },
    {
      "time": "00:30:00",
      "text": "对，现在其实网上有好多那种在网页里面跑一个操作系统，就是跑一个古老的拟真操作系统的那个效果。他们用的那个字体也差不多，虽然不是完全一致，但也是那种古早的PCIBMPC机里面那个内嵌的那种room的字体，那个还是比较好的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:30:19",
      "text": "你刚才用canvas直接把字体的渲染结果画出来。",
      "speaker": "发言人4"
    },
    {
      "time": "00:30:23",
      "text": "你说这个思路倒是可以，就是用HM5那个canvas那套API。对，然后直接在里面画那个点，直接往上画。大家就有个问题，你那个文字就不可选了。至少我们现在做的这种伪像素感，它其实每个字都是可以，都是非常accessible的对。",
      "speaker": "发言人3"
    },
    {
      "time": "00:30:39",
      "text": "这他们做那个拟真操作系统的这帮人是无所谓这件事的。但是如果你想要说我要做一伪操作系统的风格，同时又实际上是一个accessible的website，那的确是非常难，至少你不能保证跨平台。",
      "speaker": "发言人2"
    },
    {
      "time": "00:30:55",
      "text": "对对对，这个就比较坑一点。所以我但是我想一下，如果我的那个要求不是那么高，我只是要求尽可能的像素的对齐，就包括解决这个比如说现在我们那个首页，它是一个用最新的CSS3的那个grade，那个就是规就是网格排布，访问还不但是他比如说我默认打开是一个三三列三栏，对三三栏对，三栏就比较难除，这就可能导致刚才我说的这个边缘有灰度，因为那个半个像素的问题，对不对？但如果说有一个什么，我不用这个三栏，我就用一栏或者两个，就双栏或者是这四栏。",
      "speaker": "发言人3"
    },
    {
      "time": "00:31:31",
      "text": "一定通过这个java c来实现的话。那也可能实现说我能够指定到像素级别的这个宽度。那至少你说在不同系统上它有一定的出入。它至少它多一个像素，少一个像素，它至少还是个整数倍，应该还是可以做的。我觉得有有一些这个机会。所以这个是我们什么官网改头换面，其实就是都是在听着你们前一期节目的这个鼓噪下面实现的。当然这里也非常感谢为礼包这个过程中非常的尽心尽力，帮我们做了那么多的定制化，然后我们也是第一个吃了这个螃蟹的人。",
      "speaker": "发言人3"
    },
    {
      "time": "00:32:09",
      "text": "现在好像把网站做成Rachel风格是一个三号，是个潮流。就是包括在在文艺界也是有怎么叫文在文艺界我我想的是在设计界也是现在好像兴起了Rachel wave这样一个风潮。",
      "speaker": "发言人2"
    },
    {
      "time": "00:32:24",
      "text": "今年一直都流行ritual，对。",
      "speaker": "发言人1"
    },
    {
      "time": "00:32:27",
      "text": "复古风不对。但最近比如说那个蒸汽波Y，好像是这个名字就是特别流行。在90年代的日本流行音乐配上那种什么美少女战士或者是超时空要塞的动画片，然后就现在各种各样的音乐全都被整成这个风格。就太之之之前。",
      "speaker": "发言人2"
    },
    {
      "time": "00:32:48",
      "text": "我再提顺便提一个打个岔的事儿，就是那个叫什么班班代，中文叫什么百代是吧？百代在应该是去年年末的时候，把他之前的一些老的那个就小时候我们看那些动画片全部给放youtube上面去了。然后我又去追了一遍，那个那个叫什么来着，魔神英雄传，应该是那个纪念传，是有个有个这边有一个山山有一圈彩虹，那汽车什么是创建珊对吧？然后有好多彩虹，我把那个又看了一遍。",
      "speaker": "发言人3"
    },
    {
      "time": "00:33:21",
      "text": "是应该是一个他驾驶一个类似像高达一样的机甲。",
      "speaker": "发言人4"
    },
    {
      "time": "00:33:24",
      "text": "对，类高达龙，还有一个龙，骑着龙。",
      "speaker": "发言人3"
    },
    {
      "time": "00:33:28",
      "text": "我记得他好像有个女主的那个名字叫是日本的一个女巫的一个名。对。",
      "speaker": "发言人4"
    },
    {
      "time": "00:33:34",
      "text": "那个时候这个动画片小时候好火的，我们班有一个女生就叫黑米。对，昵称我我也。",
      "speaker": "发言人2"
    },
    {
      "time": "00:33:41",
      "text": "我我当时应该是上小学，对吧？小学几年级，反正就是那个时候特别火，一一到那个播出的时候，一直守在电视机里面看万人空巷的。而且你放到现在看，它是做了那个高清重置。我还不知道怎么，反正看起来那个youtube产品的效果还挺清楚的那我就追了一遍，而且这个片特别坑，他好像有有三部，然后都烂尾了，就没有播完。",
      "speaker": "发言人3"
    },
    {
      "time": "00:34:03",
      "text": "不知道为什么是在中国没有播完，还是没有画完就。",
      "speaker": "发言人2"
    },
    {
      "time": "00:34:06",
      "text": "youtube上也没有，我不知道是怎么一回事儿，有可能是没有没有画，有可能是没有画完，这个很坑。然后这个故事到时候就我那天是他是先开放的。第一步它是一周更一集，一集也就十来20分钟的样子。然后我最多第一季还差两三集，可能就追完了，他就放第二步了，跟我说。",
      "speaker": "发言人3"
    },
    {
      "time": "00:34:29",
      "text": "需要付费解锁。",
      "speaker": "发言人2"
    },
    {
      "time": "00:34:31",
      "text": "没有，他有没有这个选项？他是为了卖那个卖手办，他现在就在出那个那个机甲的那个手办。",
      "speaker": "发言人3"
    },
    {
      "time": "00:34:39",
      "text": "OK我想起来了，他们的机甲非常Q版是吧？",
      "speaker": "发言人2"
    },
    {
      "time": "00:34:42",
      "text": "对的，他们现在就很整个这个动画片都是那种萌系的，也不要QQ系，就特别搞笑的那种。",
      "speaker": "发言人3"
    },
    {
      "time": "00:34:48",
      "text": "对。",
      "speaker": "发言人2"
    },
    {
      "time": "00:34:48",
      "text": "二手车版高达一样吗？",
      "speaker": "发言人4"
    },
    {
      "time": "00:34:51",
      "text": "对对对，我当时，但是我应该是小时候最喜欢的动画片，那个应该能排到前三。这个天哪，所以就是又又在那就在那里复了蛊一下他的音乐，我觉得还他还挺好听的，就是一直现在都还记得那个感觉。",
      "speaker": "发言人3"
    },
    {
      "time": "00:35:04",
      "text": "这一期播节目播出之后，这个视频的点击量会大增。",
      "speaker": "发言人2"
    },
    {
      "time": "00:35:08",
      "text": "这一看都是我们埃批连过去，我们那个refer过去了。",
      "speaker": "发言人3"
    },
    {
      "time": "00:35:12",
      "text": "对不对？AU等对吧？",
      "speaker": "发言人1"
    },
    {
      "time": "00:35:14",
      "text": "他们那个叫对对对瓦特鲁瓦特鲁日了。",
      "speaker": "发言人3"
    },
    {
      "time": "00:35:17",
      "text": "什么男主的名字吗？瓦特鲁是男主的名字，就是一般写成汉字那个渡渡江的渡。",
      "speaker": "发言人4"
    },
    {
      "time": "00:35:23",
      "text": "就渡渡边杜的那个杜对吧？对。",
      "speaker": "发言人3"
    },
    {
      "time": "00:35:26",
      "text": "就是他的名字。",
      "speaker": "发言人4"
    },
    {
      "time": "00:35:27",
      "text": "跟凡凡这个最近不是在什么怀旧考古，特别多这种情况，对不对？然后最近也是在那个商场里面，应该是疫情之前，商场也看到很多那种国产复古的，也有，你知道吧？你们这边上海有那个大白兔奶糖。",
      "speaker": "发言人3"
    },
    {
      "time": "00:35:44",
      "text": "这个已经很久了，这个十年前就出现了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:35:48",
      "text": "没有，他最近我也是，我们可能在其他地方有，但是我是记得应该是去年就是19年末下半年，在深圳才看到他搞了一整个展厅的那种复古的。而且其实你仔细翻那个时候的那个排版设计，我觉得他做的还蛮好的。是啊，就是大白兔奶糖的那套的这个设计，但不知道不知道是谁做的，可以去找一期节目，你们可以去考一下古当时是谁做的那个字体的设计，他全部都定制的。因为那个时候还没有没有什么数字化设计的手工画的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:36:16",
      "text": "那个时候美术字的功美术字和平面设计的功底，虽然条件非常简陋，但是最终水准是非常高的。在90年代电脑普及之后，就是这个个人桌面出版毁了平面设计。",
      "speaker": "发言人2"
    },
    {
      "time": "00:36:30",
      "text": "可以说就是粗制滥造，对吧？什么叫做低端家具下？",
      "speaker": "发言人3"
    },
    {
      "time": "00:36:36",
      "text": "当年就是所有的师傅都有手上功夫的，就是像后来就都都用电脑了，大家就没有手上功夫了。",
      "speaker": "发言人1"
    },
    {
      "time": "00:36:43",
      "text": "对，那时候我去我跟老师去做校做校刊，做初中还是高中校刊，去一个印刷厂，我那个师傅的手艺真的令人叹为观止。就是从一个剪贴画那种它实际上是一张一本很厚的书，然后里面每页都是那种半透明的剪贴画。然后他从上面裁一下，然后贴在一个板上，然后问你这样行不行，然后再去排版，最后把它印出来，那个那个手艺真的让人非常叹服了。那绝对是你看现在一个人敲键盘放鼠标做出来排版的感受是完全不一样的，是一种有那种降意的冲击在里面。就好像你看一个什么看一个什么letter Price的那种印刷机一样，就是赏心悦目。我想想。",
      "speaker": "发言人2"
    },
    {
      "time": "00:37:29",
      "text": "那时候都是这剪刀功夫，剪剪贴贴都是对对。",
      "speaker": "发言人1"
    },
    {
      "time": "00:37:35",
      "text": "那天我就是在逛商场的时候，看到那个大白兔他搞的那套东西，然后我就仔细去听。其实小时候就是光吃那个糖，也没在意那个包装纸。然后他那个时候就是他卖的那个糖里面的那个包装纸。因为我估计应该还是成本和这个工艺的考虑，他那个其实不是特别的清晰哈他现在他就是全部用最新的工艺做出我原来的那个那个图样，所以你仔细看它非常在现代工艺下面它非常清楚，然后那个边缘那些都做的非常好。我觉得这个仔细看那个配色都搭的挺棒的。大白兔的兔毛看的也是有毛吗？这个没有毛，高清版大白兔有一个版本是有毛的对，特别搞笑。等等等等。我们我们这期节目聊啥就。",
      "speaker": "发言人3"
    },
    {
      "time": "00:38:24",
      "text": "被你们扯到这哪去了。不过我们内核恐慌，这次作为这个丁卯点阵体的这个案例，我其实已经在我们的type会员的五月份这一期里面介绍了。所以大家如果在会刊里面也可以看到我们这次改版后的内核恐慌的这个网页的效果。",
      "speaker": "发言人1"
    },
    {
      "time": "00:38:46",
      "text": "感谢推荐我们发，我们回去看一下这个能有多少个点击过来。所以刚才讲了那么多与主题无关的事情，我们这期。",
      "speaker": "发言人3"
    },
    {
      "time": "00:39:00",
      "text": "节目在聊什么是有关。",
      "speaker": "发言人1"
    },
    {
      "time": "00:39:02",
      "text": "勉强被牵扯上OK。好的，但是不是今天的主题。",
      "speaker": "发言人3"
    },
    {
      "time": "00:39:06",
      "text": "我们今天主题讲什么？",
      "speaker": "发言人1"
    },
    {
      "time": "00:39:08",
      "text": "我想想这个怎么描述，其实今天这个主题跟我们之前串台的好几期节目都是有或多或少的关联，对吧？这关联。",
      "speaker": "发言人3"
    },
    {
      "time": "00:39:16",
      "text": "当然了，我这个都是想好的，都想很长时间酝酿的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:39:22",
      "text": "都是有计划的，对不对？对，冥冥之中早已慢慢变化快。",
      "speaker": "发言人3"
    },
    {
      "time": "00:39:26",
      "text": "艾瑞克真的是非常用心的，就像我们两个每次来都是像打酱油一样。",
      "speaker": "发言人2"
    },
    {
      "time": "00:39:31",
      "text": "我们都是很很欢乐的在打酱油。",
      "speaker": "发言人3"
    },
    {
      "time": "00:39:34",
      "text": "对我我们是双重捧哏。",
      "speaker": "发言人2"
    },
    {
      "time": "00:39:36",
      "text": "但是你们很你们能你们很能说。",
      "speaker": "发言人1"
    },
    {
      "time": "00:39:39",
      "text": "对我说我们是之前串的时候讲过那个UNI ode的各种问题，然后包括应该有一最开始第一期也讲过什么。就是你在键盘上按下一个按键，那个字怎么出现在屏幕上的个过程的对吧？其实今天讲的这个话题，跟这两件事情或多或少是有一定关系的对吧？就是说文件系统，大家如果还知道什么叫文件系统的话，现在应该很多00后没有用BC或者back的话。",
      "speaker": "发言人3"
    },
    {
      "time": "00:40:06",
      "text": "它可能不mobile first generation。",
      "speaker": "发言人2"
    },
    {
      "time": "00:40:08",
      "text": "对，就是mobile first这一代应该已经不知道什么是文件系统了。文件系统就是你打开这个所谓的资源管理器，对吧？能看到那个东西。假如你在像我跟吴涛这个状态的人，就还知道还可以有一个命令行，对吧？那能看到这个路径什么什么的对，在文件系统我们不是聊他的那些其他各种各样的怎么用这么一些关于我们只聊一个事情，就是文件系统是怎么命名的问题，就是一个文件到底它可以叫什么？",
      "speaker": "发言人3"
    },
    {
      "time": "00:40:39",
      "text": "然后其实我们也可以扩展到这其他的，就是关于各种源代码还有语言，我们会涉及到这个命名的事情。对，英文它就叫什么naming convention，是吧？这个就叫命名规则，其实会有各种各样的命名规则。对，但是是像因为我们大家都是mac用户，mac几乎都都没有规定，那就不会存在这个事情。但是以前在很早以前，我们在学命令行，还在学dos的时候。",
      "speaker": "发言人1"
    },
    {
      "time": "00:41:10",
      "text": "有各种各样的制度要遵守，对吧？对。",
      "speaker": "发言人3"
    },
    {
      "time": "00:41:14",
      "text": "那时候你们还记得比如说8.3规则吗？",
      "speaker": "发言人1"
    },
    {
      "time": "00:41:18",
      "text": "对对对，这个是啊这个要我想想一下，这个得要在windows 95之前时代的，应该是windows 32时代的时候，大家都要遵守的一个事情，对不对？",
      "speaker": "发言人3"
    },
    {
      "time": "00:41:29",
      "text": "从windows 3.1开始支持的长文件名应该是。但是为了向下兼容，或者说或者对他做了一套向下兼容的方案，就是他这个文件名在dos下面显示的时候还是会显示成8.3.",
      "speaker": "发言人2"
    },
    {
      "time": "00:41:42",
      "text": "还是用一个波浪号来展来来来。",
      "speaker": "发言人3"
    },
    {
      "time": "00:41:44",
      "text": "显示一个波浪号加一个数字。",
      "speaker": "发言人2"
    },
    {
      "time": "00:41:46",
      "text": "你们要跟大家解释一下什么叫8.3好吧？anyone?",
      "speaker": "发言人1"
    },
    {
      "time": "00:41:49",
      "text": "其实我觉得要解释8.3，先要解释什么是扩展名。因为其实麦克上，比如说我们现在麦克上面默认的情况下，它是不显示这个扩展名的，对不对？",
      "speaker": "发言人3"
    },
    {
      "time": "00:41:57",
      "text": "因为mac其实即使没有扩展名也可以也成立，就是在mac上面。但是windows不行。",
      "speaker": "发言人1"
    },
    {
      "time": "00:42:04",
      "text": "是这样的，是这么来的。Windows扩展名这个东西最早实际上是70年代的一个发明，当时那个操作的CPM应该叫control。什么DC是control，我只记得C是control，CPM就是dos，dos是从CPM抄过来的，相当于然后CPM有扩展名这一项。因为CPM的创就是创始人认为在和文件相关的所有的原数据里面，类型数据是最重要的。所以类型数据应该是文件名的一部分。",
      "speaker": "发言人2"
    },
    {
      "time": "00:42:33",
      "text": "其实这里是一个哲学问题，就是说一个文件的扩展名，它其实是定义这个文件是一个什么样的种类，对不对？然后这个种类这个信息是否是应该体现在这个名字里面，还是说体现在一个什么别的地方。比如说刚才LK也提到，其实mac里面你不用扩展名也还可以，对吧？他因为他有一些别的方法可以判断这个文件是一个什么样类型的文件。比如说我们常见的一个方式有一个什么magic number对吧？就是在文件开头可能有几个字，麦克。",
      "speaker": "发言人3"
    },
    {
      "time": "00:43:02",
      "text": "我想迈克是怎么实现的？麦克在资源。",
      "speaker": "发言人2"
    },
    {
      "time": "00:43:06",
      "text": "它这个叫中文叫什么资源差。这个folk在很早以前这个就更复杂了。",
      "speaker": "发言人1"
    },
    {
      "time": "00:43:13",
      "text": "Fork好像是经典，就是卖classic里面的一个概念。",
      "speaker": "发言人2"
    },
    {
      "time": "00:43:17",
      "text": "对，就classical。对因为你那个OS后面又有不一样了。",
      "speaker": "发言人1"
    },
    {
      "time": "00:43:21",
      "text": "因为OS它本质上是一个unix，unix的哲学就是这个文件是不是可执行文件，那我让他的可执行给的可执行的权限，它就是可执行文件喽。That IT, 然后unit实际上是不把原数据，不把文件类型是什么，这个原数据存在任何地方的。就unix你们上面专门有一个命令叫file，你用file它是一个启发式的探针，它就会去看这个文件。",
      "speaker": "发言人2"
    },
    {
      "time": "00:43:44",
      "text": "看起来像你猜。对，就是怎么判断一个文件像什么？它也有很多方法，如果不看文件名的情况下，你看可以看文件头部对吧？它通常一些这种文件格式，它在头部都会有一些特殊的一个标记或者一个什么结构，对吧？他会说这是一个图片，这是一个什么word文档，这是一个什么MP3的一个音频。举个例子。",
      "speaker": "发言人3"
    },
    {
      "time": "00:44:05",
      "text": "是这样，就是好像后来还衍生就是因此而衍生出了一些所谓polyglot文件，这个文件同时是很多种东，比如说他同时一张照片，然后同时然后又是一个RR压缩文档。",
      "speaker": "发言人2"
    },
    {
      "time": "00:44:20",
      "text": "对，这种就是属于专门制作出来的这种hack。但其实说回来就是说windows里面采取的一个方法就是说我它windows没有像类似刚才你说那个file这个命令，它其实没有对应的东西，对吧？他就说我怎么知道这个文件是个什么呢？是个什么东西呢？是个什么种类呢？",
      "speaker": "发言人3"
    },
    {
      "time": "00:44:39",
      "text": "你告诉我喽，有用户告诉他，对你对。",
      "speaker": "发言人2"
    },
    {
      "time": "00:44:42",
      "text": "你告诉我喽，你在这个名字最后加个，你说点JPG，那可能就是一个压缩的图片对吧？你要是个点MP3，那可能就是一个音频文件对吧？你要是点个MP4，那就是个视频，对不对？然后就诸如此类，就是以搞了这么一套扩展名这么一个概念来描述这件事情。然后dos我记得当时8.3是因为它只能存11个字符宽，对吧？八个名字加一个点儿再加三个字母的这个扩展名就齐活了，最多就这样。",
      "speaker": "发言人3"
    },
    {
      "time": "00:45:14",
      "text": "所以当时的文件名最多只能是八个字符，然后扩展名最多也就只有三个字符。就告诉你们他的这个限制非常严格，所以就简称8.3。",
      "speaker": "发言人1"
    },
    {
      "time": "00:45:26",
      "text": "其实我我当时一直我一直想不起来了，就是说最多三个，那其实当时一个或者两个用的多吗？点C.",
      "speaker": "发言人3"
    },
    {
      "time": "00:45:34",
      "text": "兄弟，对，点H。",
      "speaker": "发言人2"
    },
    {
      "time": "00:45:40",
      "text": "你都不用投。",
      "speaker": "发言人1"
    },
    {
      "time": "00:45:43",
      "text": "明白。",
      "speaker": "发言人3"
    },
    {
      "time": "00:45:45",
      "text": "所以现在就是讲什么？我们今天讲这个命名。那命名的话首先是一个文件名的长度问题，对吧？所以像刚才说的，像dos的，它的限限制的是只能有八个字符。然后后面到windows后面就最多是就可以有255个字符了。那个那个多少长也可以，然后扩展名的话好像是后面四个字母也可以的对吧？反正unix的话是随便的都无所谓的，那有有几个字母都无所谓，对吧？",
      "speaker": "发言人1"
    },
    {
      "time": "00:46:17",
      "text": "实际上也没有扩展名这个概念，只不过后来扩展名这个扩扩展名这一套东西归根结底还是有它意义还是有意义的。因为你人不可能去查看文件的额外的meta data，人只能能人能看到的基本上就是一个文件名。所以文件名作为扩展名，作为他一套还是有意义的。所以在后面unix和麦克之类也其实也都怎么怎么说，从善如流，随大流。扩展名当成了文件的类型判断机制的一部分。但是归根结底link links上面实际上是没有扩展名的概念的，就跟麦克一样了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:46:58",
      "text": "其实你们想没想这可能是这个叫什么来着？就是图形界面的一个问题还是怎么着？就是你在一个纯命令行的界面下面，CLI, 我们叫common interface，交互的方式是一定是一个，你叫什么呢？叫动宾结构对吧？",
      "speaker": "发言人3"
    },
    {
      "time": "00:47:15",
      "text": "我就说你先敲一个命令，然后执行什么样的一个参数，那个参数就是那个文件名。这个时候你已经知道了你要用什么东西去处理这后面那个那个宾语吧？那个那个文件。但其实你在这个，比如windows里面，你是要有一个这么一个感。就是比如你在那个创资源管理器里面，你双击一个图片，你的想法是把它打开，对吧？这个时候你有个暗含的假设是说你用什么把它打开，这里存在一个绑定的一个关系，对不对？它不是一个动宾。",
      "speaker": "发言人3"
    },
    {
      "time": "00:47:43",
      "text": "对windows打开文件的机制，也是跟那个扩展名相关的。它在注册表里面把所有的扩展名对应的一个打开工具。",
      "speaker": "发言人2"
    },
    {
      "time": "00:47:53",
      "text": "所以就很蠢的，很死板的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:47:56",
      "text": "这里面就是一个哲学问题，是你先想到了用什么工具，先想到用什么东西打开，然后你再去找那个文件，还是说你先找到那个文件，然后你要你要用这个你要用你要打开这个文件，然后再想这个文件是用对应的是一个什么工具来打开。就这里面我觉得有一个逻辑的前后的一个关系，对吧？",
      "speaker": "发言人3"
    },
    {
      "time": "00:48:16",
      "text": "而且像迈克的话，它没有这个扩展明星，是因为它其实是它是GY的图形设备，他把这些东西都不不用写在就是不用当成扩展名，写在文件名里面。我跟你说就老的那个mac他们是他他用那个folk，就是那个resource fork资源差，它其实是写在文件里头的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:48:38",
      "text": "这个概念可能要给大家解释一下，这个东西其实很除非你对这个底层非常了解，你不然其实你根本不会想到这么一个结构，就是这个resource fork到底是个啥。其实你这么想你创建了一个空白的一个文本文件，对吧？然后这个文本文件在一个最普通文件系统里面，它能记录啥？这个文件叫什么名字，有些原数据什么是什么时候创建的，有多大尺寸。然后就是文件的这个所谓的内容了，假设空的话，就是这个林志杰的，就是临场的一个内容。那这个时候你会回头想说，这个文件是什么类型？这个信息到底存在哪里的问题，对吧？",
      "speaker": "发言人3"
    },
    {
      "time": "00:49:14",
      "text": "刚才我们开始讲了这个dos和这个windows的方案，是说存在这个文件的扩展名里面，对吧？就是最后那个点的后面那个就是文件的扩展名，那这个信息就已经包含了。然后这个mac OS就是不是我们现在就一个就叫做mac OS一的这么一个版本。而是说比如说mac OS789这个时候，它其实在文件系统里面有一个专门存储这种原数据的地方。这个地方叫做资源差resource fork。这个实现细节比较墨迹，就是它是在独立于这个文件本身之外的一个地方去存储这个信息的。有了这个东西之后，你的扩展有没有这个扩展名其实已经不重要了，对不对？因为这个文件类型是存在原数据那个资源差里面的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:49:56",
      "text": "它这样的对应就比较灵活。",
      "speaker": "发言人1"
    },
    {
      "time": "00:49:57",
      "text": "对，但这样也就是有一个代价，就是它它其实首先它跟别的系统的兼容性就比较差。比如你把一个文件从，但那个时候没什么网络，可能这种情况倒不是特别常出现。但你知道现在就说你要把这个文件，比如从那个经典版的mac OS发到一个windows XB上面或者windows 95上面去。这个时候那个资源差是一个mac OS的实现细节，它在windows上面是没有的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:50:20",
      "text": "这个时候你怎么办呢？所以经常会把这个mac的文件拷到windows上，会多出来一套东西。",
      "speaker": "发言人1"
    },
    {
      "time": "00:50:27",
      "text": "对，就包括你现在用那个。我们可能下期节目讲nars的时候，我们之前不是有一期讲过nas，但其实没有提到这个问题。比如说因为是现在基本上所有的nas系统都是以linux系统或者是windows系统为主的。你一个mac的客户端去访问这个nas的时候，那它的那个资源差又又变成什么了，对吧？就变成你就刚才的那个问两个文件，一个文件复制分成两个文件，有一个文件是描述它原数据信息的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:50:54",
      "text": "然后那个文件在其他系统上是没有用的，就跟垃圾一样的，只有mac能用。",
      "speaker": "发言人1"
    },
    {
      "time": "00:51:00",
      "text": "所以就是从从别的那个操作系统角度来看，这个麦克的用户就是一个到处乱扔垃圾的这么一个人。",
      "speaker": "发言人3"
    },
    {
      "time": "00:51:06",
      "text": "对吧？就是我觉得两方互相都看对方不顺眼吗？Windows不是会留下什么sumi.",
      "speaker": "发言人2"
    },
    {
      "time": "00:51:12",
      "text": "麦克也会，有那个DS叫什么DS store。是对，那个也是一个点DS store.",
      "speaker": "发言人3"
    },
    {
      "time": "00:51:18",
      "text": "开始一个文件夹会就多一个出来一个文件。",
      "speaker": "发言人1"
    },
    {
      "time": "00:51:21",
      "text": "每个文件夹都会有一个非常烦人的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:51:22",
      "text": "也是像CN一样的很烦人。",
      "speaker": "发言人2"
    },
    {
      "time": "00:51:25",
      "text": "对，扯扯远了，就是这些都其实都是考古了对吧？其实包括今年的macos我相信应该我们你们有谁用过今年版mac OS吗？我是没用过。",
      "speaker": "发言人3"
    },
    {
      "time": "00:51:35",
      "text": "我用我只在虚拟器里考过。",
      "speaker": "发言人2"
    },
    {
      "time": "00:51:40",
      "text": "然后这个windows 95之前的版本，我们应该还都用过，我们都用过。",
      "speaker": "发言人3"
    },
    {
      "time": "00:51:47",
      "text": "对我当年还用WPS排版。",
      "speaker": "发言人1"
    },
    {
      "time": "00:51:51",
      "text": "WPS是图形版还是这个dos版？",
      "speaker": "发言人3"
    },
    {
      "time": "00:51:54",
      "text": "Dos版的，UCUC dos进去的，用智能ABCWPS.",
      "speaker": "发言人1"
    },
    {
      "time": "00:51:58",
      "text": "然后暴露了年龄，我们都是用过那个时代软件的人。",
      "speaker": "发言人3"
    },
    {
      "time": "00:52:02",
      "text": "而且还不是那个visit的这都是要预览预览在预览等等。",
      "speaker": "发言人1"
    },
    {
      "time": "00:52:07",
      "text": "那个时代除了WPS，还有一个CLI界面下的排版工具，CCDE还是叫什么。",
      "speaker": "发言人2"
    },
    {
      "time": "00:52:15",
      "text": "对对对。",
      "speaker": "发言人3"
    },
    {
      "time": "00:52:15",
      "text": "CCEDE还是叫什么四个字母CC。",
      "speaker": "发言人2"
    },
    {
      "time": "00:52:18",
      "text": "对，没错，是的，有的。对，但是我没有，主要我没用过那个。对我知道，但是没用过。",
      "speaker": "发言人1"
    },
    {
      "time": "00:52:24",
      "text": "其实你想来那个时候还是蛮高级的。那个时候因为不能所见即所得，就是纯那个字符界面的情况下，你其实是在写markdown差不多这种感觉对不对？",
      "speaker": "发言人3"
    },
    {
      "time": "00:52:33",
      "text": "是的，然后我们要做一个花边都要脑补的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:52:36",
      "text": "对对对，我查到了CCED是一款中文字表处理软件。那是1988年，由原北京乾为天电子技术研究所开发，主要开发者是朱崇军。软件在dos时代曾经是中国最流行的文字处理与电子表格软件之一。1998年之后出现了甚至出现了基于windows的版本，连续多年是中国最畅销的软件之一，是中是全国计算机等级考试以及国内不少计算机教育培训的指定内容。我的天哪，你们。",
      "speaker": "发言人2"
    },
    {
      "time": "00:53:04",
      "text": "想想我用打印过连连针式打印机打过东西，就打过文档，确实还用过这个东西，非常上古的感觉。",
      "speaker": "发言人3"
    },
    {
      "time": "00:53:14",
      "text": "后来WPSP了，对，就是这里面写的老对手WPS借助中国政府采购计划恢复了生机，但CCED市场就萎缩等等。2010年2月份CCED2000版发行。",
      "speaker": "发言人2"
    },
    {
      "time": "00:53:27",
      "text": "天哪。",
      "speaker": "发言人1"
    },
    {
      "time": "00:53:28",
      "text": "oh my god, 我要去收一套简直。",
      "speaker": "发言人2"
    },
    {
      "time": "00:53:33",
      "text": "要还要看怀一下旧的，至少等一下怎么扯到那里去。说回来，就其实这几个我们刚才提的那几个古早的操作系统，现在其实基本上都没有了。我们现在目前主流用的还是这个windows的，应该是windows 10对吧？或者是至少是8以后的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:53:54",
      "text": "八和十和那个桌面现在还有人用吗？其实还比较少，所以这个先不算。然后就是这个麦克了，mac OS ten应该说是准确的说是现在叫mac OS了。所以这两个系统我们其实它给到我们限制其实就没有那么多了。其实也可以是文，我记得文件名可以起到多少。",
      "speaker": "发言人3"
    },
    {
      "time": "00:54:15",
      "text": "来的长度。",
      "speaker": "发言人1"
    },
    {
      "time": "00:54:16",
      "text": "你说对长度是可以很长的了，已经。对，但扩展名这个事情在各个系统上面，我现在都基本上都保留下来。不管是在linux上面，还是在micro s上面，还是在这个线上windows上面，基本上扩展名这个事情都已经成为一个约定俗成的东西了。但只是说就刚才说那个区域，它默认是在图形界面下，它是展示还是不展示扩展名的问题。应该我记得windows目前默认应该是不展示的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:54:40",
      "text": "麦克也是默认不展示的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:54:43",
      "text": "然后linux的桌面我就不知道了，因为太多了，然后也不也没不常用，所以就这两个都是默认不展示。就变得很尴尬对不对？本来这个东西是为了说刚才吴涛也讲了，为了让让这个用户一眼能看出这个文件是个什么类型的东西，对吧？但其实因为有了这个叫什么的图标，就是那个file icon，就是文件类型的图标和它。因为如果你按那个叫什么多列排布的，其实不叫多列，就是那个列排案例不叫案例。案例排布它有可能多个，但是应该是表格式，表格式的那个它有一栏，它本来就会显示这个文件是什么类型，所以就有了这两个大概一个是文件图标，一个是文件类型。单独有一列显示的情况下，这个文件名的这个扩展名其实又变得不重要了，对不对？那其实当初就不要搞扩展名。",
      "speaker": "发言人3"
    },
    {
      "time": "00:55:29",
      "text": "对，就好像windows后来就默认隐藏扩展名，对吧？刚装好默认是会隐藏扩展名。",
      "speaker": "发言人2"
    },
    {
      "time": "00:55:36",
      "text": "XP开始就是默认隐藏了，应该是之后还是windows 98开始.",
      "speaker": "发言人3"
    },
    {
      "time": "00:55:40",
      "text": "我就觉得扩扩展名是一个很蠢的一个办法，而且他特别死板，就刚才说他和那个应用程序化只能一对一。像mac系统它是不用这个的，它甚至因为它是通过图标来体现，甚至它那个图它那个资源fog的话，它因为有更详细的一个定义，它还可以比同样比如说是illustrator的的AI的一个文件，它还它那个图标可以体现出AI的版本的不同，它它可以体现在图标上面。",
      "speaker": "发言人1"
    },
    {
      "time": "00:56:11",
      "text": "就同样都是点AI但是有的时候显示的AI比如说是五一个显示AI8这种。对，没错。",
      "speaker": "发言人3"
    },
    {
      "time": "00:56:17",
      "text": "因为它fork可以可以它可以分叉，可以加好多都好好多内容进去的。这个东西只要体现在图标上就是一样，最后给用户的信息是一样的，对用户来讲，这的确就是一个AI的这个版本的一个文件。它达到这个效果，并不一定要用。比如说这个三个字母还得让用户去得记这个三个字母是还对应什么东西。",
      "speaker": "发言人1"
    },
    {
      "time": "00:56:40",
      "text": "所以他其实如果这么来看，他们这个就是文件扩展名这事情。它其实是字符界面向推界面过渡这个时期的一个副产物，对吧？因为在那个字符界面下面，你是没有图标来告诉你和这个文件是什么类型，也没有这个多列的这种就是附属信息在展示。因为那个字符串一般的那个比较窄，就那个栏比较窄。所以这种情况下，在这个过渡时期把这个文件扩展名这个概念给保留下来。但其实到现在发现其实已经完全没有作用了，对不对？就可能是反效果。",
      "speaker": "发言人3"
    },
    {
      "time": "00:57:12",
      "text": "Mac他之所以要用这个扩展名，就是完全屈服于这个网络时代信息。这个文件交换的时候，必须要服屈服于windows的这个蠢。",
      "speaker": "发言人1"
    },
    {
      "time": "00:57:23",
      "text": "的比那个更强势一些，用的人更多。",
      "speaker": "发言人3"
    },
    {
      "time": "00:57:26",
      "text": "对，所以这个就很就是很一个典型的就是向低看起的一个典型的案例。我们很多东西就是好的技术并不并没有得到发现，大家都是用一个很蠢的技术然后再流行起来的对。",
      "speaker": "发言人1"
    },
    {
      "time": "00:57:38",
      "text": "那刚才还说到因为现在这个图形界面都是默认隐藏这个文件扩展名的，它其实有一个比较重要的点，就是说你比如说你在windows里面好还是mac也好，默认情况下你要改一文件的名字，你怎么改？你就是选择那个文件，要不你右键点击改名，或者是你就像我们这种键盘比较数六的，然后你就直接按回车，它就可以改名了，对不对？然后这个时候因为它不显示这个文件的这个扩展名，你们默认改就是所谓的文件名，就是狭义的文件名，就是不含扩展那部分的前缀那部分。但其实如果说你像我们都喜欢，就我比如说我至少是这样的，我不知道你们的默认说是怎么样，我一定会把那个文件这个扩展名展示出来。我知道为什么保留这个习惯，但是就是看起来，因为我可能有可能是因为我要经常在这个字符界面和这个图形界面进行切换，所以还是有这个需求。",
      "speaker": "发言人3"
    },
    {
      "time": "00:58:33",
      "text": "看到那个文件扩改名是什么呢？那这种情况下，你如果要改名，它其实也有很多小小技巧的。比如说我现在试一下给你们看，因我记得应该是这样子。比如说我现在我打开一个麦克，我要改一个文件名。然后这个时候我是显示的一个是显示带扩展名的文件名。我要点我按回车，它默认会把文件名的部分给我选中。但是扩展名是保的是点就扩展名和那个点部分是不动的，什么意思呢？",
      "speaker": "发言人3"
    },
    {
      "time": "00:59:01",
      "text": "就是说他不想让用户错误的更改掉这个扩展，把文件类型修改。对对对，因为其实虽然说我们刚才讲，虽然说这个文件类型不重要，但是如果说你用户明确的说我要把这个文件改成那个类型，比如说很简单一个道理，你现在去网站上下载一张图片回来，还有可能插插载那个。因为现在很多那个网站的图片，他本来就没有想给你下载，对吧？他的那个文件命名也不是按照这个有扩展面的方式来弄你就下面就是一个普通空白的文件，对吧？但这个时候因为那个是一个外部系统来的来来的一个文件，我的这个母系统又不知道这个文件是个什么东西，它就会显示一个叫做什么一个一个generic file，一个通用的一个文件放在那里，就不知道是它是个啥，不知道这个图片，也不知道这个视频，也不知道是个音乐还是什么东西，对不对？这个时候我就说那我要强行给它加一个扩展名，告诉我这个系统说，你把它当做一个图片，或者你把它当做一个音频对吧？然后你再做对应的事情。这个时候我就不知道什么时候能启动类似于这个file这个机制，去探测这个文件是个什么样的类型。对，这里面其实还是有很多讲究的。",
      "speaker": "发言人3"
    },
    {
      "time": "01:00:09",
      "text": "所以从dos windows转过去，在用mac的时候，在mac当年就因为它无所谓扩展名，扩展名你可以随便改。然后这个对于我们从dos转过去的，就觉得这个都能改的。",
      "speaker": "发言人1"
    },
    {
      "time": "01:00:23",
      "text": "你说我想到一个问题，就是mac上面有时候会出现，比如说一个文件它没有扩展名，然后麦克会自动去试图去猜这个文件是什么，尤其是在你按下定格的时候。这就导致了很多人在尤其是对电脑系统不是那么在行的人，会经常我觉得我遇到这个问题就是会有人给你很多没有扩展名的文件，在他的电脑上显示一切正常的，但到你这儿就不行了，因为没有扩展名。",
      "speaker": "发言人2"
    },
    {
      "time": "01:00:54",
      "text": "对，这个时候其实发现有有如果一旦涉及到这个文件的交换，这有有个扩展名明确的规定这个文件是什么样的这个类型。然后至少缩小一个范围，然后那我们再去处理还是会容易很多的对。",
      "speaker": "发言人3"
    },
    {
      "time": "01:01:08",
      "text": "有很多事情你会觉得说这样是方便了用户，但实际上会苦的开发者。",
      "speaker": "发言人2"
    },
    {
      "time": "01:01:16",
      "text": "这是一个两所有的软件设计不都这么干的吗？都是很方便用户。",
      "speaker": "发言人3"
    },
    {
      "time": "01:01:21",
      "text": "对。",
      "speaker": "发言人2"
    },
    {
      "time": "01:01:22",
      "text": "要关着用户的。是的，好吧，那我们文件名的长度差不多，这样我们我觉得这个扩展名的坑太深了。这每次讲不完，我们本来今天重点不是讲这个的。",
      "speaker": "发言人1"
    },
    {
      "time": "01:01:36",
      "text": "前面讲了这么久这个坑。",
      "speaker": "发言人3"
    },
    {
      "time": "01:01:37",
      "text": "对对，下面我们来谈更大一个坑，就是是否文件名命名是否允许包含空格的问题。这个事情就特别扯了。因为大家也知道我们所有的这些系统的话都是从西方语言过来的。那像西文化他们都是按词分写的，词和词之中间都是有空格的。是，我记得dos的文件名是不允许有空格的。",
      "speaker": "发言人1"
    },
    {
      "time": "01:02:04",
      "text": "应该是不允许的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:02:07",
      "text": "我有点不太记不清楚了。",
      "speaker": "发言人3"
    },
    {
      "time": "01:02:08",
      "text": "有可能就是我我学电脑开始就是从dos进来的。所以哪怕直到现在我起我自己起文件名还是不习惯使用空格。我会建议比如用什么用hyphen，用连字符或者下划线来写OK。",
      "speaker": "发言人1"
    },
    {
      "time": "01:02:24",
      "text": "我上次看一个视频，就是一个他叫什么？他叫baby HB guy。他在他的视频里面教你装一个micro s classic的操作系统，然后它很自然而然的把那个主硬盘命名为。Imac空格HD然后我就我就想我就感叹说是果然是祖传mac用户从来不会在意这个名文件名里面可有用这个能不能有空格这种问题。你要是这种古早的windows用户，你绝对不可能做出这种事来。就是把把一个文件对命名为一个带空格的名字。",
      "speaker": "发言人2"
    },
    {
      "time": "01:03:04",
      "text": "有有空格会有什么问题呢？就是在早年的这个命令行，就是字符界面的时候，他比如说我要处理，就比如说我们想象一个什么场景，就是复制，我要把这个假设我有一个文件叫做A点TXT，我要把它复制为B点TXC，我直接就像什么就是这个CP就copy对吧？然后A点TXC然后到这个目标是B点TXC就是完成了，对不对？那你发现这三个部分，一个主语两个宾语，吧？这个动词就一个动词，对，然后你两个这个object，两个目标的时候，你发现他用什么风格呢？用空格风格对不对？这个时候你说那我的文件是刚好是A空格B这个时候怎么办？就很尴尬对不对？",
      "speaker": "发言人3"
    },
    {
      "time": "01:03:46",
      "text": "但其实也是有解决方案的，就是说你把这个带空格的名文件名用引号引起来不就好了吗？对吧？那其实你可以就是copy空格，然后引号开，就是引号，然后A空格B点击TXC然后引号，然后就下一个目标，比如说C点TXC其实也是可以的，对不对？但只是说就增加了一个麻烦，但其实我觉得这个还不是最坑爹的。",
      "speaker": "发言人3"
    },
    {
      "time": "01:04:10",
      "text": "虽然我我我个人觉得就是说你可以允许空格，但是最好是不鼓励使用空格。虽然说像麦克的这个超目前的这个麦克超市怎么样大量的使用了这个空格的这么一个事。因为一旦涉及到空格，你那个文件名就必须要用引号。引号的话就有时候会导致比如说自动补齐的一些问题，还有包括有一些这种有些兼容性的问题。",
      "speaker": "发言人3"
    },
    {
      "time": "01:04:32",
      "text": "比如说我们经常用这个那XRX就是有一个命令，它可以说你把前面的的那个程序的输入全部作为这个命令的参数，来执行这么一个辅助的一个命令。它是怎么判断前面你输入哪些参数给他他就说有个空格分隔开的，那些都是各种各样的参数，对吧？如果你文件名刚好又是个空格，你怎么办呢？就等于说那我就改一个来分隔符来分隔这个参数，就不要用空格分隔参数了。那用一个什么？就说是这个就是零，就是SKI码是零的那个字符，那个no那个字符来分隔这个前面的参数也可以，对不对？但是这个东西就很就就很不自然了。但我觉得其实就用空格的最麻烦的问题，到前面那个都是说只是麻烦，还不是说不至于说完全不能用用空格做在文件名里面。最最坑爹的事情是你到底连续用了几个。",
      "speaker": "发言人3"
    },
    {
      "time": "01:05:24",
      "text": "空格啊哈就是A.",
      "speaker": "发言人1"
    },
    {
      "time": "01:05:26",
      "text": "空格B点TXC这是一个文件，A空格B点TXC这是另外一个文件，对不对？",
      "speaker": "发言人3"
    },
    {
      "time": "01:05:33",
      "text": "这是在一个非等宽字体的显示环境之下非常严重的问题。",
      "speaker": "发言人2"
    },
    {
      "time": "01:05:38",
      "text": "对，你我不知道在分等宽的情况下，那个A和B它可能不是一个宽度。我说A和B可能还看不太出来，就是A和小写字母的那就是在分等宽情况，它肯定是不一样宽的。这个时候你就说一下它中间到底间隔了几个空格，你去数吗？难道或者如果说如果你说一两个的区别可能还比较明显，对吧？五个和六个的区别你能看得出来。",
      "speaker": "发言人3"
    },
    {
      "time": "01:05:59",
      "text": "但这个其实你用下划线或者用hydron，其实面临的问题是一样的，我觉得关键的问题还是在于空格它作为一个特殊的字符，它其实是有别的作用。",
      "speaker": "发言人4"
    },
    {
      "time": "01:06:12",
      "text": "对它作为分隔符用的对。",
      "speaker": "发言人3"
    },
    {
      "time": "01:06:13",
      "text": "一旦你要把它容纳到文件名里，你可能要引入别的机制来保护它。比如你要加。",
      "speaker": "发言人4"
    },
    {
      "time": "01:06:19",
      "text": "引号就escape转移。",
      "speaker": "发言人2"
    },
    {
      "time": "01:06:21",
      "text": "那这样子的话就是我文件名还能不能用引号呢？对，所以就是你必须要引入别的机制。",
      "speaker": "发言人4"
    },
    {
      "time": "01:06:28",
      "text": "对，escape机制在windows上面是非常蛋疼的。就是windows自从支持这个文件命名有空格之后，windows最知名的一个带空格的文件名，大家想想是什么？M空格files真的fuck me，真的每次要进入这个路径，真的是他这么说，unix能有空格，但是uni x支持用back lash做escape，对吧？你打文件打你打文件名打了一半，你发现有个空格，那你back是空格就好了。Windows你要回到一开始的这个参数的最开始加一个双引号。而windows的这个type type auto completion，它虽然会帮你加上双引号，但是它非常的蠢。就是你在用的时候你就会觉得蠢死了。",
      "speaker": "发言人2"
    },
    {
      "time": "01:07:17",
      "text": "而且windows它也没有像那个它那个叫做live editor，就是那个命令行内行的编辑器的时候，它是我记得我他有那个功能吗？就是跳一个一个word一个word.",
      "speaker": "发言人3"
    },
    {
      "time": "01:07:28",
      "text": "跳alt加F是吧？没有alt加，也没有没有W全都没有。",
      "speaker": "发言人2"
    },
    {
      "time": "01:07:33",
      "text": "就比如说你想了一个写一个巨长的什么CC冒号斜杠program。这时候你发现好。",
      "speaker": "发言人3"
    },
    {
      "time": "01:07:40",
      "text": "我要回你想要回到行首，只能按home，你不能按control加A.",
      "speaker": "发言人2"
    },
    {
      "time": "01:07:45",
      "text": "之类的那你就后来从第一个，他就慢慢用这个箭头再挪到对应的那个位置，加引号C前面是吧？",
      "speaker": "发言人3"
    },
    {
      "time": "01:07:51",
      "text": "对，你看那些一直上就德国有些很老的程序员一直缠，然后修改文件名的时候要按那个后退键，按上那么2 34，你看他的时候，你就真的会替他着急。",
      "speaker": "发言人2"
    },
    {
      "time": "01:08:02",
      "text": "Oh my god。所以给人一种德国人做事严谨的感觉，对不对？到磨洋工，我就按给你们听一下。就这种感觉。",
      "speaker": "发言人3"
    },
    {
      "time": "01:08:16",
      "text": "请问键盘什么牌子？",
      "speaker": "发言人2"
    },
    {
      "time": "01:08:18",
      "text": "对，所以就刚才那个back stage其实有那个叫做backstage叫什么。我我我一直搞不清楚哪个是斜杠。",
      "speaker": "发言人3"
    },
    {
      "time": "01:08:24",
      "text": "哪个是反反斜杠。Dark slash是反斜杠。",
      "speaker": "发言人1"
    },
    {
      "time": "01:08:28",
      "text": "等一下斜杠是从哪？从右上角到东南OK，右上到左下这个是斜杠对吧？",
      "speaker": "发言人3"
    },
    {
      "time": "01:08:35",
      "text": "对，斜杠青年是斜杠青年，反斜杠青年、反向青年是用by sash做斜杠青年的。斜杠青年。",
      "speaker": "发言人2"
    },
    {
      "time": "01:08:46",
      "text": "先看这个，右上到左下的是正斜杠，左上到右下的是反斜杠。",
      "speaker": "发言人1"
    },
    {
      "time": "01:08:52",
      "text": "我怎么说呢？我问的这个问题有点抬杠。",
      "speaker": "发言人3"
    },
    {
      "time": "01:08:54",
      "text": "这实际上是一个怎么说右撇子的世界的偏见。因为右撇子在砍人的时候，会自然而然从右上举起来，然后朝左下削下去。",
      "speaker": "发言人2"
    },
    {
      "time": "01:09:04",
      "text": "对吧？",
      "speaker": "发言人3"
    },
    {
      "time": "01:09:04",
      "text": "为什么一定要砍人呢？",
      "speaker": "发言人1"
    },
    {
      "time": "01:09:06",
      "text": "这是slash吗？Slash这个动作不是劈砍的意思吗？Flash是从就是你把你把你的手举起来，你的惯用手举起来。肯定是朝右上举的。对，然后呢，然后批下来是朝左下劈的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:09:21",
      "text": "我这么说，就是在网址里面那个斜杠是正斜杠对吧？",
      "speaker": "发言人3"
    },
    {
      "time": "01:09:25",
      "text": "正斜杠。对，然后windows的那个路径是反斜杠。",
      "speaker": "发言人1"
    },
    {
      "time": "01:09:29",
      "text": "对，windows路径是反斜杠。这是这实际上这实际上也是一个很有意思的，叫什么路径依赖问题。因为unix最开始是用反用斜杠作为那个斜杠的分隔符的对，而dos一开始是dos 1.0，是没有路径这个概念的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:09:44",
      "text": "所以也是后来加的对。",
      "speaker": "发言人3"
    },
    {
      "time": "01:09:47",
      "text": "他们就是继承了当时CPRCPM的那个斜杠作为flag的这个参数，我们作为参数的用法。然后等到他们需要加入这个路径的时候，那就用了反斜杠。",
      "speaker": "发言人2"
    },
    {
      "time": "01:10:02",
      "text": "因为斜杠已经被用掉了，对吧？对，这就造成了另外一个问题，就是你用这个我们讲用back size，这个叫coating，就是以保护那个空格的时候，你会发现好像没法保护对吧？因为我的那个斜杠有别的用途。对，太坑爹了。但现在的主流的操作系统还是最新的。比如说windows和这个麦克S都是允许使用空格，而且是允许有任意多个空格，就是连续也可以对吧？对，所以就会出现我刚才说那个问题，就是那就你非要搞事的话，你要起个文件名吧A，然后隐藏后缀对吧，然后又又起个文件，文件名A空格又隐藏后缀对吧，又起个文件名A空格，空格又隐藏好处。你发现这个文件夹怎么全都是文件。",
      "speaker": "发言人3"
    },
    {
      "time": "01:10:43",
      "text": "都叫A对不对？全是空格文件。",
      "speaker": "发言人4"
    },
    {
      "time": "01:10:47",
      "text": "我这里还有个空白的文件。更猛对吧？这个也很有意思。但所以我觉得允许空格是可以的。但是我觉得能不写空格的话，还是尽量不写空格，避免太多那种坑了。",
      "speaker": "发言人3"
    },
    {
      "time": "01:11:01",
      "text": "所以文件名就是允许空格还好。但是你在编程的时候，那些标标制符标识、标志。",
      "speaker": "发言人1"
    },
    {
      "time": "01:11:10",
      "text": "identify标识符。",
      "speaker": "发言人3"
    },
    {
      "time": "01:11:12",
      "text": "那标识符的话就肯定不能有空格，对吧？那就就是要变会变成两个标识，两个符号了，就是identify吗？",
      "speaker": "发言人1"
    },
    {
      "time": "01:11:21",
      "text": "对，这这那那你就相对好理解，就是说那里至少有一个确的语义，跟写字是一样的。你知道这是你写的是两个word，它不是一个word，你就那肯定要用一个东西来分隔，空格分割天经地义，就是在新闻里面是这样子。",
      "speaker": "发言人3"
    },
    {
      "time": "01:11:34",
      "text": "所以在在编程的时候就开始各种类，各种函数，就开始大家要连起来，于是就有各种各样的这个写法了。对，现在最流行的应该就是那种camel case，对吧？",
      "speaker": "发言人1"
    },
    {
      "time": "01:11:51",
      "text": "这camel case.",
      "speaker": "发言人3"
    },
    {
      "time": "01:11:53",
      "text": "和下划线取决于你干嘛。现在什么key up case，camel case和那个snake case.",
      "speaker": "发言人2"
    },
    {
      "time": "01:12:00",
      "text": "各有用来来来跟大家解释一下这个什么意思。",
      "speaker": "发言人1"
    },
    {
      "time": "01:12:04",
      "text": "先要讲这个场景是什么，对不对？就是说为什么有这个需求？就是说你因为不能用空格去分隔，这个就是编程里面的一个一个词一个一个词是一个标识符，对吧？你不能用空格风格，至少应该我觉得目前主流的编程语言都是不支持这一点的，你甚至你也不能用引号对吧？不能加引号，引号是一个特殊符号，你也不能用吧？",
      "speaker": "发言人3"
    },
    {
      "time": "01:12:25",
      "text": "所以你要去说，那我要分隔，比如说hello word这两个写在一起的时候怎么办？那通常的一种做法就是说我把这两个字连起来一起写。但是hello这个H是大写，然后这个W的这个word的W大写对吧？这个叫做什么来着？",
      "speaker": "发言人3"
    },
    {
      "time": "01:12:42",
      "text": "Camel case驼峰时等等。Camel case第一个一定是小写的对，第一个一定要小写才叫camel case。第一个大写的话叫passing case.",
      "speaker": "发言人2"
    },
    {
      "time": "01:12:52",
      "text": "但这个区别其实好像大家来讲的都不多。大家一般还是讲是首字母大写，我们都是这样。",
      "speaker": "发言人3"
    },
    {
      "time": "01:12:58",
      "text": "对，比如说个人里面那个大写小写是有语义的词。Function实际上是camel是实际上是pascal case，但是很多人会说那是camel case case。",
      "speaker": "发言人2"
    },
    {
      "time": "01:13:07",
      "text": "就是说你看你怎么去理解这个，它的那个定义是啥？就是说你只是说就大就是叫做就有有这个词的这个首字母大写这种这一类你都叫camel case，它也说得过去，但只是说因为在go里面，它的第一个字母是大写和小写，会影响到它这个标识符的visibility的可见性。所以这里面他就说那作用域，我就不好去单独去给它起一个名字，所以就只能就说这一类都叫camel case了。",
      "speaker": "发言人3"
    },
    {
      "time": "01:13:34",
      "text": "好吧，那你可以说poster le case实际上是camel case的一个特例。",
      "speaker": "发言人2"
    },
    {
      "time": "01:13:39",
      "text": "就小驼峰和大驼峰。如果小所谓的小驼峰就是首字母是小写，但是中后面的的那个词，第二个单词的那个是字母是大写，就小驼峰。对对对，然后大驼峰的话就是连首字母也大写，那这样的话也可以叫做帕斯卡。帕斯卡对他是从。",
      "speaker": "发言人1"
    },
    {
      "time": "01:13:59",
      "text": "帕斯卡原来的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:14:01",
      "text": "应该是对，但这里就有一个更坑爹的事情了，就是说我考你们一个，其实有很多人有分歧的。",
      "speaker": "发言人3"
    },
    {
      "time": "01:14:08",
      "text": "缩略词全大写的时候应该怎么办是吗？",
      "speaker": "发言人2"
    },
    {
      "time": "01:14:11",
      "text": "对，怎么办？比如说王岳伦UIL现在基本上那个都大家都基本上都是。如果是在此手段很多都是小写或者是这个也那那也是一个要值得讨论的问题，这个还不是最最坑的，这个是这种比如说是IP地址，IP address, 我写成一个字的时候怎么这么大小写？",
      "speaker": "发言人3"
    },
    {
      "time": "01:14:28",
      "text": "IP两个字必须两个字母必须大写。通常来讲的话，那不就变成pascal case了吗？",
      "speaker": "发言人1"
    },
    {
      "time": "01:14:37",
      "text": "不是，这里就很坑的。在在这个问题在这里，先我们先不考虑go语言这种比较特殊，它对那个首字母大小写有这个语义的区别之外，假设是完全没有逾期的情况下，它其实也有讲究的。比如说是I大写P小写，A大写的IP address，还是说IPA都大写，然后address的后面那个这么多都小写，这是一种写法对吧？还有就是IP都小写，然后A大写，然后dress的小写这种情况下？就是你发现没，他有很多这种不太明确的地方，然后这种你说这个IP的钻石还比较简单对吧？但如果是刚好是这种，算算缩略词，IP是个缩略词，它是internet protocol的这的缩略。如果说我要写IPURL address怎么办？",
      "speaker": "发言人3"
    },
    {
      "time": "01:15:28",
      "text": "这好像这个就是跟你的环境，跟那个语言有关系。然后有些他还是有习惯的，比如说这个叫首字母缩写，如果超过是三个或三个以上的话，那么把后面几个字母小写就有那样的语言。",
      "speaker": "发言人1"
    },
    {
      "time": "01:15:47",
      "text": "是啊所以我就说这个事情，其实是一个相对来说，首先中文里面不存在这个问题对吧？因为只有西文有大小姐这个概念。对，然后在在西文大大小姐里面这种就是会经常导致各种这种所谓的叫做顺湛对吧？各种坚持一定要某一种写法才对，另外一种某种写法才更合理的。这种争论是一直都存在，而且我估计在在我们死后，他应该还是会继续存在的。",
      "speaker": "发言人3"
    },
    {
      "time": "01:16:16",
      "text": "其实他怎么怎么大小写，还是由这个API的设计者他当时拍脑袋想的。因为我们这边有外部开发者，那个XMLHTTP request里面就是XML全大写，但HTTP又不是。",
      "speaker": "发言人4"
    },
    {
      "time": "01:16:31",
      "text": "选那些什么，很奇怪。",
      "speaker": "发言人3"
    },
    {
      "time": "01:16:33",
      "text": "对不对？所以这个完全是看那个开发者当时他拍脑袋，他觉得这样写比较优雅，他就这么写，看心情。",
      "speaker": "发言人4"
    },
    {
      "time": "01:16:43",
      "text": "没有，今天我们讲的是命名规则。像这种东西的话，很多很多时候就是有规则，有的地方是没规则。然后一个语言里面他有时候定了一个规则，他自己都不统一，经常会有这种事情。",
      "speaker": "发言人1"
    },
    {
      "time": "01:16:55",
      "text": "对每个公司都有自己的这个convention.",
      "speaker": "发言人3"
    },
    {
      "time": "01:16:58",
      "text": "毕竟它是一个convention，就是他还是一种约定，他他没有一种很强制的机制去约束他。比如说如果有一个什么机器检测的机制，禁止他做某一件事情，那他可能这个规则才会非常的强烈的。然后comply不过是吧？",
      "speaker": "发言人4"
    },
    {
      "time": "01:17:16",
      "text": "对对对，但从实用主义角度来讲，你你因为这个因为你用camel case要解决什么问题是解决不能用空格分词也没也有就是说也让我们后面会有讲用下划线也是一个办法。如果在不能用空格也不用下划线的，因为我认为下划线是一个空格的变种，对吧？OK那不能用空格也不能用下划线的情况下，你要用这个大小写来来展示词与词之间的区别。那很显然这种情况下你就不应该把那种全大写的词全都真的全大写。这样的话你看不清楚哪个它的那个边界在哪里。就好像刚才你说那个XMHTP request的情况下，那XMLHTP这是一个东西还是两个东西？",
      "speaker": "发言人3"
    },
    {
      "time": "01:17:55",
      "text": "原交易的那种camel case还是比较适合阅读的。虽然说看看起来比较丑，为什么x mail是这么个写法，就好奇怪，感觉怪不怪的。但从读的角度来讲，或者从分词的这个角度来看，你还是要去找到它那个东西的本质是什么呢？它本质不是为了好看，它本质是为了clarity，为了清晰，吧？对，OK就是这是一种命名方式。",
      "speaker": "发言人3"
    },
    {
      "time": "01:18:19",
      "text": "第二种命名方式就跟他讲空格是肯定不行的那为什么我说下划线是空格的一个变种呢？因为下划线它其实就是空格那里那个位置变成了1111条线。要下划线其实有一个区别是比较要紧的，就是在用鼠标双击选词的时候，下划线它不会把那个词断开，对这个其实挺蛮有用的。比如说什么意思？就是说你想象hello word，如果你是空格断开，它肯定你点击我们默认是双击是选一个词，对吧？一个word那应该只会选到hello，然后他选不到后面那个word。他如果说你用下划线把hello word连起来之后，你用你在大多数的这个图形界面，你用双击的方式去选这个词，它会把整个hello下划线word都都圈起来，都都选都高档选择起来，对不对？这个其实还是蛮有用的。",
      "speaker": "发言人3"
    },
    {
      "time": "01:19:08",
      "text": "哼这交互设计为了优化这种字符串，怎么这么做的对。",
      "speaker": "发言人4"
    },
    {
      "time": "01:19:14",
      "text": "它避免了大小写的争端，对吧？这个时候你怎么就大小写就全看你的这个心情了，因为它跟语义和这个分词都不他不都不影响了，对吧？你都可以比如说像刚才那个HTXML下划线，HTTP下划线request，你都可以这么写，对不对？其实不影响这个了，那这个就是好看的问题了。",
      "speaker": "发言人3"
    },
    {
      "time": "01:19:32",
      "text": "不过理论上讲，就是画用下划线的话就没那么碍眼。说实话就既有这个空格的这个空间感，也没那么碍眼。因为它是在下划线，所以它这个名字叫snake case，就像是蛇跌在。",
      "speaker": "发言人1"
    },
    {
      "time": "01:19:49",
      "text": "瘫在地上爬舌头。",
      "speaker": "发言人3"
    },
    {
      "time": "01:19:52",
      "text": "超形象的。我觉得这几个名字都超形象的，像这个沙画这个snake，名字符叫KB对吧？",
      "speaker": "发言人1"
    },
    {
      "time": "01:19:59",
      "text": "烤肉烤串儿，不是烤串case啥意思？对吧？就像一个串儿串在上面好多什么肉叉烧一样那种感觉。",
      "speaker": "发言人3"
    },
    {
      "time": "01:20:08",
      "text": "这一看就是是这个吃货取的。",
      "speaker": "发言人1"
    },
    {
      "time": "01:20:11",
      "text": "这个东西有中文翻译吗？就肉肉夹馍对不对？就是肉夹馍。",
      "speaker": "发言人3"
    },
    {
      "time": "01:20:15",
      "text": "肉夹馍字面意义上keep doing，keep up是旋转烧烤的意思，dunner是do not是旋转，keep up是烧烤，然后连连起来，连在就keep up是实际上是蹲在keyboard b的的简称，就是土耳其烤肉的简称。",
      "speaker": "发言人2"
    },
    {
      "time": "01:20:34",
      "text": "但是在k bob这个词在进入这个英语语系里面，它它其实就是我们理解的那个串儿。",
      "speaker": "发言人3"
    },
    {
      "time": "01:20:40",
      "text": "对，烤吧不是串儿。",
      "speaker": "发言人1"
    },
    {
      "time": "01:20:43",
      "text": "do是旋转ba不是烤K.",
      "speaker": "发言人2"
    },
    {
      "time": "01:20:46",
      "text": "是烤的意思。",
      "speaker": "发言人1"
    },
    {
      "time": "01:20:48",
      "text": "对，但是就是我就说你在。",
      "speaker": "发言人3"
    },
    {
      "time": "01:20:50",
      "text": "那个英语说的语义是说对他这个东西语义变成了莎莎lek。对。",
      "speaker": "发言人2"
    },
    {
      "time": "01:20:56",
      "text": "就是变成了一个串在一起的东西串。",
      "speaker": "发言人3"
    },
    {
      "time": "01:20:58",
      "text": "对，像竹签串起来这样一个东西。",
      "speaker": "发言人2"
    },
    {
      "time": "01:21:01",
      "text": "对，就是有一个棍儿在中间很细，然后上面有一堆更宽的一个物件。这个就是英文里面的开发，目前他他展示了这个，也是这个key back case的这个意思。",
      "speaker": "发言人3"
    },
    {
      "time": "01:21:11",
      "text": "对。",
      "speaker": "发言人2"
    },
    {
      "time": "01:21:13",
      "text": "那这个叫烤串case。串这个字其实还是蛮形象。",
      "speaker": "发言人3"
    },
    {
      "time": "01:21:18",
      "text": "这要是日本人来起的话，就会变成鸟串烧串鸟烧。",
      "speaker": "发言人1"
    },
    {
      "time": "01:21:24",
      "text": "对，但KO的case有一个问题，就是它并不是所有的语言都支持。因为横线就是不是用下划线，是用那个连字符或者叫减号，对吧？他其实有别的含义的，可能是A减B的，也就是k bug。然后杠这个case它可能是一个你那他认为你就要执行一个数学的减的一个操作，所以这个其实在很多语言里其实是不支持这种方式的。",
      "speaker": "发言人3"
    },
    {
      "time": "01:21:47",
      "text": "Key back case最常见的就是在CSS里面。",
      "speaker": "发言人2"
    },
    {
      "time": "01:21:50",
      "text": "很啰嗦。对，这也是因为CSS其实不进行计算的一个原因导致的，对不对？它没有这个compute，除非用那个cock它。",
      "speaker": "发言人3"
    },
    {
      "time": "01:21:56",
      "text": "需要空格4S现在不是支持cock吗？靠所以你靠你在cock里面你要想想写减号的话，减号前后一定要有空格。",
      "speaker": "发言人2"
    },
    {
      "time": "01:22:04",
      "text": "而且这空格不能被压缩掉。对。",
      "speaker": "发言人4"
    },
    {
      "time": "01:22:08",
      "text": "不像有些空格可以压缩，就是那个叫什么？叫做语义敏感的空格。",
      "speaker": "发言人3"
    },
    {
      "time": "01:22:13",
      "text": "对，这个其实也挺不和谐。",
      "speaker": "发言人4"
    },
    {
      "time": "01:22:18",
      "text": "但是你一看就是它其实这种历史背景的原因的，过去没有运算。所以我用这个下划线，用减用这个叫做这不叫减号，叫做这个横线，其实没有什么区别，对吧？但是后来发现，我们今天现在要预算了不怎么办？",
      "speaker": "发言人3"
    },
    {
      "time": "01:22:32",
      "text": "对，这其实一切都是都是一个路径依赖的功能。假如当初键盘设计的时候能明确区分连字符和减号，现在可能也就不会没有这个问题了。",
      "speaker": "发言人2"
    },
    {
      "time": "01:22:42",
      "text": "所以我觉得这也区分不了，这个很难，就好像对于人来说。",
      "speaker": "发言人3"
    },
    {
      "time": "01:22:46",
      "text": "在我们人类在非常自然的情况下，是不会去考虑一个符号的语义跟这个符号的表现是可以分开的这个问题。就我们看到。",
      "speaker": "发言人2"
    },
    {
      "time": "01:22:55",
      "text": "有不精确的物种。",
      "speaker": "发言人3"
    },
    {
      "time": "01:22:56",
      "text": "的看到一个短横，一定会根据上下文来判断它到底是个减号还是一个对吧？但是计算机没有这个功能。",
      "speaker": "发言人2"
    },
    {
      "time": "01:23:03",
      "text": "其实这个是阿拉伯人的问题，对不对？为什么用短横来表示简呢？你用一个更加特殊的符来表示减不就更好吗？",
      "speaker": "发言人3"
    },
    {
      "time": "01:23:11",
      "text": "这是阿拉伯人发明的吗？",
      "speaker": "发言人1"
    },
    {
      "time": "01:23:14",
      "text": "那我们现在这个加减乘除这个四个符号松。",
      "speaker": "发言人3"
    },
    {
      "time": "01:23:16",
      "text": "什么时候开始确定这个标准？就乘号至少不是非常不统一的。历史上乘号有很多很多种表示方法。",
      "speaker": "发言人2"
    },
    {
      "time": "01:23:23",
      "text": "乘号我们除只会在那个地方，就只会在乘法里面用。日常的这个叫什么？日常排版里面并不会用。",
      "speaker": "发言人3"
    },
    {
      "time": "01:23:30",
      "text": "只是抛出一个想法，因为中国古代也不是用减号了，对吧？中国古代减号是啥？所有人都卡了，对自己国家文化这么不了解。看你看看你们九章算术对不对？现在阿拉伯人其实不用阿拉伯数字，阿拉伯数字实际上是西方对印度数字一套一套称呼。所以我怀疑阿拉伯人其实也不是用减号的，所以你不能把锅栽在阿拉伯人头上，阿拉伯兄弟们已经背了太多锅了。好的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:24:00",
      "text": "那就是whoever发明这套东西的时候，他就没想过这个。不，你你其实你这么想，加减乘除那四个符号里面除了加和乘，其他两个都是有歧义的问题的。除除如果你是用那个除还好，就是说这斜杠除也是有这个问题的那其实还是减号的问题比较多。",
      "speaker": "发言人3"
    },
    {
      "time": "01:24:16",
      "text": "对吧？反过来说，现在英语键盘上，就是我有时候觉得挺不可思议的，打字机键盘上居然没有乘号这个符号。就当初发明打字机的人会认为X和你用X来替代称号就好了喽。这是真的路径依赖导致了很多很多原因。",
      "speaker": "发言人2"
    },
    {
      "time": "01:24:31",
      "text": "那你要说这个键盘的话，当年的键盘连小写字母O和数字零都可以用一个位键位。",
      "speaker": "发言人1"
    },
    {
      "time": "01:24:38",
      "text": "对那个可以理解吗？因为赵哥照打司机机械结构那么复杂，能少一个还是能省能少一个？是的。",
      "speaker": "发言人3"
    },
    {
      "time": "01:24:44",
      "text": "在机械打字机的时候是很好，跟X的话那不一样。",
      "speaker": "发言人1"
    },
    {
      "time": "01:24:47",
      "text": "赋予这个字符一个固定的语义。其实我觉得是很很计算机时代的一个事情，因为很晚进的，因为你才需要去识别这些事情。人是一个通过语境和上下文来判断符号意义的动物。它不是他不是要背下来这个符号，或者说他根本就不可能知道一个符号在抽象的一种数据结构里面是一个什么东西。他只是看到他他才知道。",
      "speaker": "发言人4"
    },
    {
      "time": "01:25:12",
      "text": "他这该死的神经网络，对吧？",
      "speaker": "发言人3"
    },
    {
      "time": "01:25:14",
      "text": "好了，我们不讲这个东西了，我们会接着回来讲我们那个空格的事情。",
      "speaker": "发言人1"
    },
    {
      "time": "01:25:18",
      "text": "另外常见的一个命名就是我们各种网站的UIL的。UIL里面是不能有空格的，我想想对。",
      "speaker": "发言人3"
    },
    {
      "time": "01:25:26",
      "text": "12005212联盟的空格会不会编码掉，被转移掉。就变成是多少？",
      "speaker": "发言人2"
    },
    {
      "time": "01:25:32",
      "text": "20% 20%对吧？然后就是我们常见的这个所谓用户名对吧？这个其实我们或者比如说你twitter的这个我们叫handle对吧？",
      "speaker": "发言人3"
    },
    {
      "time": "01:25:42",
      "text": "邮件的这个邮箱的这个就是那个at for前面那部分也是不能有空格的，通常是这样子。那为什么呢？因为就刚刚说那个问题，你什么时候才能确定它是不是一个完整的词，对吧？就跟刚才那个identify其实是一样的。这两个其实它本质上就是一个identify，对不对？标识符可能显然也是不能有空格的那就是你得想想是说那就可以用下划线，有些就基本上下划线都是可以用的对吧？但只是说那个就是横线或者是减号，或者你叫连字符也好，这个能不能用其实就取决于各个系统了。",
      "speaker": "发言人3"
    },
    {
      "time": "01:26:18",
      "text": "这个断词总是一个很纠结的事情，因为西方他们必须要用的空格断词，然后遇到不能用空格的时候，他们就老纠结了。",
      "speaker": "发言人1"
    },
    {
      "time": "01:26:27",
      "text": "那可以想办法沟通解决方案。",
      "speaker": "发言人3"
    },
    {
      "time": "01:26:30",
      "text": "因为现在twitter的用那个hash tag，那用那个标签那个也是好烦的。像他们那个API有时候认那个标签的话，也是得得手工加空格才才会才会认当做一个标签。",
      "speaker": "发言人1"
    },
    {
      "time": "01:26:50",
      "text": "因为他不然你不知道你端到哪个地方，他不知道。对。",
      "speaker": "发言人3"
    },
    {
      "time": "01:26:54",
      "text": "他现在有一些优化。如果你输入一些很明显是标点符号的，或者是特殊符号的字符，它会给你断开，至少我知道汉语的那些标点它都会给你断开。",
      "speaker": "发言人4"
    },
    {
      "time": "01:27:05",
      "text": "好像你说到这个，我想起来twitter的那个hashtag好像不支持high粉。就是你的菜里面不能有hien。",
      "speaker": "发言人2"
    },
    {
      "time": "01:27:13",
      "text": "没有，他跟那个，他跟用户名是一样的，会退用户名，也不能有海粉，你只能用下划线。所以你他他本质上你说你你你回到刚才那个问题，就是说这个hash tag，这个tag本身是个什么东西？它就是一个itif y如果说他是改变法，你想到在编程里面你什么时候你是不是绝大多数地方都不能用这个减号，对不对？那其实也是一个道理的。倒是中文语境下面，这不是问题，就比较奇怪了。你说微博它是用两个，它其实把的这个井号键当成引号来用，对不对？就是两个圈起来的才是因为。",
      "speaker": "发言人3"
    },
    {
      "time": "01:27:49",
      "text": "中文不分词，你不加到后面的话，你也不知道这个串串到什么地方结束。",
      "speaker": "发言人1"
    },
    {
      "time": "01:27:55",
      "text": "对，问题就来了，我是井号，标签井号，标签井号这个时候算啥？你说你说配对问题是吗？对，配对问题就是有这个问题了。这是另外一个还有嵌套问题是吧？对对对，因为引号其实也是一个非常坑爹的事情，正常说我们引号是有这个开引号关引号的区别的。关键为了打字机，我们为了省那个键位，我要合二为一只搞一个了，对不对？",
      "speaker": "发言人3"
    },
    {
      "time": "01:28:25",
      "text": "所以我们这个做字体排印的就深恶痛绝的，千万不要用傻瓜引号，结果都是打自己惹的祸。",
      "speaker": "发言人1"
    },
    {
      "time": "01:28:31",
      "text": "对，就是为了也不叫他打自己惹的祸，就是为了省钱导致没钱。所以微博那个那个双井号，它就是你把它想成引号的用法来用就行了，或者让它想成是啊书名号，都不算书名号，这两个是不一样的，就引号的这种方式来用就可以了。所以其实我觉得以后要发明什么新的方式的这种quoting的方式的时候，一定要配对，就是不要用这个引号来来引了，你就用这个书名号好了，对吧？或者用那个叫方括号号来引号对括弧对吧？阔这种括弧，因为基本上括弧都是肯定是有方有这个有这个开关两个的。",
      "speaker": "发言人3"
    },
    {
      "time": "01:29:10",
      "text": "然后还得让他自动配对，然后还允许嵌套是吧？大跨国上跨过中国。",
      "speaker": "发言人1"
    },
    {
      "time": "01:29:16",
      "text": "对对对，再发现就在你在写lisp.",
      "speaker": "发言人3"
    },
    {
      "time": "01:29:21",
      "text": "所以就不用去数那个缩进或者怎么样是吧？",
      "speaker": "发言人1"
    },
    {
      "time": "01:29:24",
      "text": "对，就完全藐视缩进，缩进了就很烦人了。就是说你你凭什么你凭什么判断这一行前面有十个空格。",
      "speaker": "发言人3"
    },
    {
      "time": "01:29:32",
      "text": "这个凭什么要求我写程序还要带着一把游标卡尺？",
      "speaker": "发言人2"
    },
    {
      "time": "01:29:40",
      "text": "这是一个python梗，回头我们把这个链接放在修罗池里面，吓死我了。",
      "speaker": "发言人3"
    },
    {
      "time": "01:29:48",
      "text": "不过现在campo case就把这个词越练越长了。现在特别是什么object c他们那种的都啰啰嗦嗦的语言，他那个名字超长的那个API的那简直了。",
      "speaker": "发言人1"
    },
    {
      "time": "01:30:00",
      "text": "我之前是不知道，就是我比如说我们现在很多你用的这个IOS的手机，APP很多，因为现在好像是开始变少，以前都是这个时候的这个object c这个语言写的，但现在有有swift这个语言写可能会好一些。Of c object c那个语言的命名规则真是太奇怪了，他就要把一个API的那个全部写全一个API的一个叫什么一个参数，就是五个单词写全。",
      "speaker": "发言人3"
    },
    {
      "time": "01:30:26",
      "text": "对，它的method signature就是叫什么方法？签名是非常长的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:30:31",
      "text": "您认为它就是一个函数名？你可以这么理解对吧？对，这函数名都是要写全，我们通常都是就是按我们过去C的那个都是都写的非常简短对吧？",
      "speaker": "发言人3"
    },
    {
      "time": "01:30:40",
      "text": "C它是可以把单词缩写。",
      "speaker": "发言人1"
    },
    {
      "time": "01:30:43",
      "text": "这一切都要归功于small talk，small talk就有这一套。就是一个参数有两个名字，一个是外调用者看到的名字，另外一个是参数内部看到的名字。这个其实我觉得是非常合理的，哪怕现在swift你看他还是继承了这一套，这个东西还是蛮有用的。而且怎么说呢，我觉得迈克和object c和和java一样，是一个重度依赖于IDE的语言。你没有自动补全的话，你拿来写这个真的是非常自找苦吃的一件事情。但是如果你有自然自动补全的话，那文件名多长也就无所谓了。",
      "speaker": "发言人2"
    },
    {
      "time": "01:31:16",
      "text": "他想的是说你可以直接读到这个参数或者这个函数名的时候，你就从他那个名字就能一眼看出来这个函数是干啥。他会把这个东西的功能定义的非常清晰，对吧？但不像我们之前，在可能上古时代，unique那个时候写这个谁都写的非常短的文件名。",
      "speaker": "发言人3"
    },
    {
      "time": "01:31:34",
      "text": "这个函数名比如说什么从这个terminal几个字符它是什么？Get CH的，看你那个character的。比如说我们正常写那个character，你说character这个是几个单字母的词就比较长。你知道写个car，就CHAR对吧？他连那个VR都不要，他直接get CH对吧？你自己猜CH后面是个啥。",
      "speaker": "发言人3"
    },
    {
      "time": "01:31:53",
      "text": "对，这实际上也是一个例，这实际上还是一个路径依赖的问题。就是你想大型机在60年代那个时代，你每次连上主机去写程序的时候，你会希望自己的按的键能需要按的键越少越好。因为就像现在我有时候所有人都work from home，对吧？你有时候连公司的那个虚拟机还是会觉得慢。你打一个键，我们好像有一期节目聊过这个问题。就是你按一个键之后，多久之内得不到也得不到延迟，你个人就会非常焦躁，你会觉得整个思路被打断了。我现在就经常会遇到这种状况，我现在就希望说，我靠。",
      "speaker": "发言人2"
    },
    {
      "time": "01:32:29",
      "text": "赶紧使用墨西默写。",
      "speaker": "发言人3"
    },
    {
      "time": "01:32:32",
      "text": "有道理，但是我要连公司的虚拟机，这个过程是没有办法用mosh来实现的对，我要先给我连到公司的version machine上，然后再从world machine上mosh到公司内部的远程界面。那那这个过程那就没有什么延迟了，对吧？所以就是60年60年代的时候，人们写程序当然会希望说需要输入字符越少越好。",
      "speaker": "发言人2"
    },
    {
      "time": "01:32:51",
      "text": "而且是那些很常用的底层的功能，它可能会被反复调用。然后他刚才你说那个stop small talk，还有内外区别力的机制，但其实在C里面应该是之前是没有的对吧？对，那就是你要会反复调用。如果你的文件不那个函数名太长的话，其实会浪反复浪费掉很多字节去存储调用的这个entry point在哪里呢？",
      "speaker": "发言人3"
    },
    {
      "time": "01:33:12",
      "text": "对，而到了objec或者是java的时代，基本上所有的人都在本地。",
      "speaker": "发言人2"
    },
    {
      "time": "01:33:18",
      "text": "客户端都是不会省的。一个字节的后客户端。",
      "speaker": "发言人3"
    },
    {
      "time": "01:33:21",
      "text": "的响应都是在本地的，所以你就不会说需要有把名字弄短这个需求，对吧？只只有只有奇葩的PHP是个。",
      "speaker": "发言人2"
    },
    {
      "time": "01:33:32",
      "text": "现在最好的语言。你说什么？",
      "speaker": "发言人3"
    },
    {
      "time": "01:33:35",
      "text": "就奇葩的PHP是用这个函数名的长度作为一个hash。你能想象吗？这是一个让人匪夷所思的决定，所以PHP的函数名有长有短，是故意有长有短的，不可思议。",
      "speaker": "发言人2"
    },
    {
      "time": "01:33:52",
      "text": "但是就是说回来，但是object c的那个那个韩树明真的是过于长了，即便是在现在的目光的这个观点来看。",
      "speaker": "发言人3"
    },
    {
      "time": "01:34:02",
      "text": "还是过于差。我觉得对于写ja的人来说真的不算什么。就是很啰嗦。对，这java里面也有很啰嗦的传输名啊不要太多。",
      "speaker": "发言人2"
    },
    {
      "time": "01:34:10",
      "text": "至少java的那些有些参数，你每个参数要写参数名吗？不用吧？",
      "speaker": "发言人3"
    },
    {
      "time": "01:34:16",
      "text": "不用，那倒不用。",
      "speaker": "发言人2"
    },
    {
      "time": "01:34:16",
      "text": "对，那object是要写的。",
      "speaker": "发言人3"
    },
    {
      "time": "01:34:19",
      "text": "对吧？Object它每个method它它还会把那个用那个冒号就连起来，它后面带了一个参数。",
      "speaker": "发言人1"
    },
    {
      "time": "01:34:25",
      "text": "对。",
      "speaker": "发言人3"
    },
    {
      "time": "01:34:26",
      "text": "然后就可以串的超长。",
      "speaker": "发言人1"
    },
    {
      "time": "01:34:28",
      "text": "超长的那个是函数签名的一部分，这个是可以理解。好像就好像C语言的函数签名，其实也要把函数的类型带上的，只不过不像object VC写的非常显示了，就是你必须显示的，告诉对方我要调用这个方法里面这个参数叫这个名字。但是在有些函数里面，你比如说java的函数签名实际上也是包含类型的，是就是你必须写出类型来。而OGC是不用写出类型来的，但是他要写出那个别名来OK.",
      "speaker": "发言人2"
    },
    {
      "time": "01:34:56",
      "text": "那那至少我们可以讨论另外一件事情，就是假设你还是我们都认可，还是要把这个写的尽可能清晰为准。但有个限度，这个限度在哪里的问题。比如说我们这个修note今天给的这个例子，这个是一个苹果的一个API，是p kit的什么NSATS type setter里面有一个我要我要念一下这个函数的。先深吸一口气，就你们你你请深吸一口气，我先深吸一口气，你们请听听好了。Should break line by height before character at .",
      "speaker": "发言人3"
    },
    {
      "time": "01:35:30",
      "text": "index nation。你要加ING.",
      "speaker": "发言人1"
    },
    {
      "time": "01:35:34",
      "text": "对have那对对我我先测量一下这个有一共有掏出你的作为。",
      "speaker": "发言人3"
    },
    {
      "time": "01:35:38",
      "text": "一个python程序员掏出你的游标卡尺来。",
      "speaker": "发言人2"
    },
    {
      "time": "01:35:42",
      "text": "50个字.",
      "speaker": "发言人1"
    },
    {
      "time": "01:35:43",
      "text": "OK假设，当然肯定当然吴涛也说了，因为都是图形界面，不存在这个问题。假设你在这个纯字符界面，你是一个80乘以25行宽的这么一个编辑器的窗口里面，这50个字就已经干掉一整行了，对吧？你还不用干别的。",
      "speaker": "发言人3"
    },
    {
      "time": "01:36:00",
      "text": "对，这还不是coq最长的一篇shows里面。",
      "speaker": "发言人4"
    },
    {
      "time": "01:36:03",
      "text": "大家看那个API名最强选手全了吗？你们打开那一页看看。",
      "speaker": "发言人1"
    },
    {
      "time": "01:36:06",
      "text": "这你看你会发你打开那个看的话，你会发现最长的是java windows dot net。",
      "speaker": "发言人2"
    },
    {
      "time": "01:36:11",
      "text": "对。",
      "speaker": "发言人4"
    },
    {
      "time": "01:36:13",
      "text": "还是点net比较没有。最关键是什么呢？像coco，像objec，他啰嗦就啰嗦也就算了。但是因为他啰嗦，他是因为他不缩写词，他都很有语义，所以读起来还算是OK的。你不像这个doll net，他即使写那么长了，他看不懂他什么意思，还带缩写，他带了缩写还看不懂什么，而且还很啰嗦。你看就比如说这个例子，103个字母那什么鬼我觉得coco.",
      "speaker": "发言人1"
    },
    {
      "time": "01:36:42",
      "text": "还有coco的API还有一点很有意思的，就是或者说导致了间接导致了他名字比较长的一点，就是他会用什么should did来表示before after就是在别的API里面，比如说什么窗口load这件事，别的API会叫做before windows load或者是after windows load。然后在coco这里叫做windows should be loaded，或者是windows did loaded。这个还蛮有意思的，算是coca一套，就哪怕现在swift也是这样的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:37:19",
      "text": "但我我我有时候在想，这个是不是跟另外当时他们诞生那个背景有一个思潮有关系？就是你们还记得那个叫apple script那个语言嘛？嗯就是他是他的那个语言就是全性化是吧？",
      "speaker": "发言人3"
    },
    {
      "time": "01:37:32",
      "text": "就像自然语言。",
      "speaker": "发言人1"
    },
    {
      "time": "01:37:35",
      "text": "对所谓自然语言描述这个东西，那么它就会有什么描述呢？就是说就全部都是用这个，我们现在都是用什么符号来表达一些特殊的语义的地方，他都尽可能用这个英文来来表述。这是你比如说定义参数，定义函数，这些都是这种方式来做。它其实可能跟那个时候的那种思潮有一定的关系。",
      "speaker": "发言人3"
    },
    {
      "time": "01:37:53",
      "text": "但是你说should和did会比before after更贴近人的使用习惯吗？我觉得不见得了不不。",
      "speaker": "发言人2"
    },
    {
      "time": "01:38:00",
      "text": "before after跟秀秀的这个肯定是语义上是不一样的，这个是个判断对不对？他如果秀的就是说你会得到一个是还是不是？但你before after他就他得到的一个结果不是一个bulley.",
      "speaker": "发言人3"
    },
    {
      "time": "01:38:11",
      "text": "就是要就得出一个布尔值对吧？",
      "speaker": "发言人1"
    },
    {
      "time": "01:38:14",
      "text": "对他得到他其实是做一个逻辑判断，就是说你这个时候是得到的一个是是还是否对吧？但如果你是before breakfast light，你得到这个什么东西你是看不出来的。",
      "speaker": "发言人3"
    },
    {
      "time": "01:38:21",
      "text": "问题是我说的这个API是一个，比如说它是在写你在写GUI的时候，你要写一个函数，这个函数应该在窗口被绘制之前调用OK这个函数。",
      "speaker": "发言人2"
    },
    {
      "time": "01:38:32",
      "text": "名在O.",
      "speaker": "发言人3"
    },
    {
      "time": "01:38:32",
      "text": "S ten里面叫做before .",
      "speaker": "发言人2"
    },
    {
      "time": "01:38:35",
      "text": "shoot .",
      "speaker": "发言人3"
    },
    {
      "time": "01:38:36",
      "text": "present。比如说但是在别的编程员里面，他可能就叫before joining之类的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:38:43",
      "text": "那可能就是语义的问题了，就是你怎么去定义这个东西。总体来讲他还是想维持一个所谓的真正意义上的可读性。可读什么意思？就是你用嘴去念那个东西，他还是得到的一些一些概念的对，那这个东西不一定是适合。比如说假设你是一个非英语母语的人，比如说中国很多程序员就这样。为什么老说中国程序员所有的API比较奇怪，对吧？",
      "speaker": "发言人3"
    },
    {
      "time": "01:39:10",
      "text": "因为他不是难懂。",
      "speaker": "发言人2"
    },
    {
      "time": "01:39:12",
      "text": "对，他是难懂。他根本他他脑子里面不是用那套英文那个逻辑来思考的。所以他你怎么可能要求他得出一套should break out by everything before character这种语句出来的，他肯定不会这么做，对不对？",
      "speaker": "发言人3"
    },
    {
      "time": "01:39:25",
      "text": "所以我们只好写文言文了。不不不，中国程序员最大的特点不是用拼音缩写吗？包括很多政府网站都是政府网站缩写为ZFWZ，我靠oh my god。",
      "speaker": "发言人2"
    },
    {
      "time": "01:39:39",
      "text": "那这也是对这也是一个很很有意思的一个事情。就是说如果他不用拼音缩写，他还能用啥？你说我先把那个翻译译成英文。",
      "speaker": "发言人3"
    },
    {
      "time": "01:39:49",
      "text": "对，这好吧，我承认刚才我有点英语本位主义的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:39:54",
      "text": "不就是不也不是说英文为主义。其实我觉得在纯这个技术范围里，其实是应该以英文为主义的。因为你的所有的底层的那些逻辑都是英文的方式来命名的，对不对？这个毫无疑义。",
      "speaker": "发言人3"
    },
    {
      "time": "01:40:08",
      "text": "没有问题。不，你要真真到底层的话是二进制，就我觉得不是我就说在在。",
      "speaker": "发言人2"
    },
    {
      "time": "01:40:13",
      "text": "那个你还比如说你还是会讲这个council，你会讲device，你会讲什么socket这些概念，这些还是逃不掉的。就是现在的那些操作系统软件系统的那些构建单元，它还是以这个英文来命名为主的。就像我说那个东西，虽然说确实有事，你是有这个句柄对吧，你有套接字对吧？但是你不会真的去写这几个字，你他还是写的是handle HDL，或者是这个soccer手柄window handle.",
      "speaker": "发言人3"
    },
    {
      "time": "01:40:41",
      "text": "这是一个windows编程的材料。",
      "speaker": "发言人2"
    },
    {
      "time": "01:40:43",
      "text": "就是说这种底层的概念是应用的，那么你基于它构建的东西，你就肯定还是以这个英文来描述它。你才这条逻这个才自洽，才通顺，对吧？这个是没有，这个我觉得是毫无疑问的。问题是出在刚才你说那个就不能泛化，比如说你说那个UR里面，它是说我们随便想一个政府网站，这是今日公告对吧，反正是今JRJGG对吧？那你你说那肯定是这么写的那他是说today's news他不会就对吧？他没有一个底层，没有一个foundation去给你构建这个东西，所以就那个不成立，所以就是这两个情况我觉得还是不一样。如果你们能够讨论的最小的那个单位，或者就是常用的单位，它是一个什么样的语言描述的。你可能其上构建的东西还是要以这个为主。就好像哪怕你用文言文文言编程的时候，除非你把底层的什么句柄和这个套接字都都用文言来描述，不然你已经很尴尬了。",
      "speaker": "发言人3"
    },
    {
      "time": "01:41:42",
      "text": "知乎上不是有一个答案是说如果就是问题是什么？如果计算机是中国人发明的，那么底层会是什么样的？其实他就把那把周易的那一套话术套套进去了，阴阳这样。",
      "speaker": "发言人2"
    },
    {
      "time": "01:41:56",
      "text": "对对对，所以我觉得你要去评价这个做法合不合理的时候，你都是不能单点来看你肯定是要成体系的来看。现在的这个情况就是说计算机的所有的底层的这个体系都是以英语为方为这个主体来构建的那你没有办法了，你就只能跟着这样写了。",
      "speaker": "发言人3"
    },
    {
      "time": "01:42:18",
      "text": "不知道有没有什么大神可以做一个兼容unix的，完全是自从最底层开始就由中文构建的操作系统。",
      "speaker": "发言人2"
    },
    {
      "time": "01:42:26",
      "text": "Linux chin x不行，我我说说这个的时候就已经输了，对不对？为什么会这么写呢？一定要用中文来描述这些东西。",
      "speaker": "发言人3"
    },
    {
      "time": "01:42:39",
      "text": "没有必要，我觉得那个趋势是融合，就融合出一种杂糅的一对。",
      "speaker": "发言人4"
    },
    {
      "time": "01:42:46",
      "text": "你看那个什么什么课的这种比较好的科幻片里面，未来都是中西文夹和克里奥利语。",
      "speaker": "发言人3"
    },
    {
      "time": "01:42:54",
      "text": "对，就是网上现在所谓的这种什么00后用的那种网络缩写语。它不就是用那种英语的单词和这个汉语拼音的缩写给它混在一起，然后再用一个首字母缩写，就这种例子非常的多。",
      "speaker": "发言人4"
    },
    {
      "time": "01:43:07",
      "text": "什么NMSL这种的对。",
      "speaker": "发言人3"
    },
    {
      "time": "01:43:10",
      "text": "就这种当然是完全的，这个是汉语拼音的手机，还有一些就是借用了英语的。因为现在有些英语单词。",
      "speaker": "发言人4"
    },
    {
      "time": "01:43:18",
      "text": "就像那个泰国网友，泰国网友反击的时候说，NMSL knees，你妈死了knees。",
      "speaker": "发言人2"
    },
    {
      "time": "01:43:25",
      "text": "这就是一个很典型。",
      "speaker": "发言人3"
    },
    {
      "time": "01:43:27",
      "text": "的柯杨二科言二语的例子。",
      "speaker": "发言人2"
    },
    {
      "time": "01:43:36",
      "text": "我们来聊这个特殊字符，刚才讲了一个空格，这个特殊字符其实可能是比较常见，其实有很多其他的特殊字符不能在很多地方使用的对吧？",
      "speaker": "发言人3"
    },
    {
      "time": "01:43:46",
      "text": "主要是windows的那个限制很多，像mac都没有你在。",
      "speaker": "发言人1"
    },
    {
      "time": "01:43:51",
      "text": "windows里面命名一个非法的文件的时候，它会跳出来一个对话框，里面苦口婆心的告诉你哪些文件是哪些符号是不能用的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:44:00",
      "text": "一大堆。",
      "speaker": "发言人1"
    },
    {
      "time": "01:44:01",
      "text": "这个还蛮贴心的。我觉得这个我觉得很好啊，就是像迈克那种过于自由，我觉得是有问题的。最好建议你不要这样干，对吧？那就是说你就直接禁止你这么干不更好。",
      "speaker": "发言人3"
    },
    {
      "time": "01:44:11",
      "text": "但是mark现在也会跳出一个对话框，其实mark也是有禁止字符的。Mark其实是不能用那个冒号，唯一一个不能用的就是在文件名里面是不让用冒号的。如果你要改冒号的时候，它会跳出一个对话框，然后提醒你。但是他说的他说那句话就是比就比windows说的这个很温柔。他说请尝试使用字符较少或不含标点符号的名称。",
      "speaker": "发言人1"
    },
    {
      "time": "01:44:38",
      "text": "那圆点算不算标点符号，对吧？这就很奇怪了对不？",
      "speaker": "发言人3"
    },
    {
      "time": "01:44:41",
      "text": "因为其实是可以用的。对你在麦克其实都可以。",
      "speaker": "发言人1"
    },
    {
      "time": "01:44:44",
      "text": "对，其实要想一下，为什么即便可以用，我觉得还是不建议使用这些特殊字符作为文件里其实有很多比较实际的问题，比如说这里我们这个修道只能列了几个，就是这个大于号、小于号，对吧？因为这个在类unix的系统下面，它就有这个管道重定向的，它都有其他的特殊意义。你这样用了之后，那别人要调用或者是要指向你这个文件的时候，就必须用这个coating或者打引号的方法。其实会增加比较多的麻烦，对吧？包括这个bar，这个pipe这个字符。",
      "speaker": "发言人3"
    },
    {
      "time": "01:45:17",
      "text": "其实也是可以用监控号。因为问题是你们可以用监控号做文件名吗？",
      "speaker": "发言人2"
    },
    {
      "time": "01:45:22",
      "text": "可以，你就引起来。OK就现在现在都是这样子，就是你要往一边写理论，理论上都是可行的。它唯一阻挡你的地方无非就是在那个资源管理器的时候弄一个你。但是你自己非要写个程序去生成这么一个文件名，然后再把它放到文磁盘上面去，这个是可都是可行的。因为文件系统本身它没有这个限制，不让你存这个东西。OK对他说还就是一个数字。",
      "speaker": "发言人3"
    },
    {
      "time": "01:45:47",
      "text": "在我就是说从对从实用主义的这个观点来讲，就是尽量去避免这些容易出问题的自负会比较好。所以其实就回到了最开始的那个命名规则了。就是说如何命名你的这个文件会导致减少问题。就是不要用标点符号，其实是最好的。任何标点符号包括空格是最好的。那个下划线不算。",
      "speaker": "发言人3"
    },
    {
      "time": "01:46:10",
      "text": "又要抬杠了。空格是标点符号吗？对，这个标点其实是指的是英语世界里的标点。",
      "speaker": "发言人4"
    },
    {
      "time": "01:46:17",
      "text": "对对对，中文的话就完全不存在这个问题。你比如说什么要用中文的书名号，就根本就这个就计算就不认为它是个特殊符号，对吧？这没什么区别。",
      "speaker": "发言人3"
    },
    {
      "time": "01:46:26",
      "text": "对，主要还是因为英语的这个标点符号，就日常书写中的标点符号，也被这个程序代码借用来表达了很多特殊的意义。",
      "speaker": "发言人4"
    },
    {
      "time": "01:46:35",
      "text": "对，是的。",
      "speaker": "发言人3"
    },
    {
      "time": "01:46:37",
      "text": "我记得当初刚学编程的时候，有些有就有些同学会很疑惑，为什么英文的就是它输入法只装的中文输入法，然后再用中文？为什么用中文的标点符号就看起来跟英文的一模一样，但是在程序都跑不起来呢？这是一个非常。",
      "speaker": "发言人2"
    },
    {
      "time": "01:46:53",
      "text": "疑惑的问题。",
      "speaker": "发言人3"
    },
    {
      "time": "01:46:54",
      "text": "困扰初学者的问题。",
      "speaker": "发言人2"
    },
    {
      "time": "01:46:56",
      "text": "特别是在只有十个像素乘以十个像素宽的时候，到底这个中文引号，那中文这个括号和英文空有啥区别？看不太出来就很坑，所以又变成之前u unicode的那个玄学的问题了。两个看起来一样的符号，它应该是一个一个码位，是不是一个深坑？",
      "speaker": "发言人3"
    },
    {
      "time": "01:47:16",
      "text": "是，不过我每次看到这个反斜杠就想到日文系日文windows的那个日元符号。",
      "speaker": "发言人1"
    },
    {
      "time": "01:47:22",
      "text": "那个是因为什么？因为那是因为他刚好是把那个那个位靶位给占了，所以对就asked.",
      "speaker": "发言人3"
    },
    {
      "time": "01:47:28",
      "text": "里面借用了一下。",
      "speaker": "发言人4"
    },
    {
      "time": "01:47:29",
      "text": "为什么会借用到这个呢？",
      "speaker": "发言人3"
    },
    {
      "time": "01:47:31",
      "text": "就他们那时候一一一拍脑袋，就觉得好像说这个反斜杠不用，日本的人要用那个要用日元符号，所以就在这个马位上面放上了这个日元符号嘛嘛。",
      "speaker": "发言人1"
    },
    {
      "time": "01:47:45",
      "text": "这个日元符号是在SK的那个头128个里面的。对，我知道了。",
      "speaker": "发言人3"
    },
    {
      "time": "01:47:51",
      "text": "就是这样反斜杠的位置。所以当年的话日本的那个系统，他就打不出反斜杠的，就只能打日元服。",
      "speaker": "发言人1"
    },
    {
      "time": "01:47:59",
      "text": "这叫什么来着？以日本为代表的东亚文化，试图对欧美主导的什么什么的一个突破，对吧？逆袭唯一成功的一次。对，因为其实你看在基本上所有的编码里面，那个SK都是作为一个神圣不可动摇的一个基础的。对。",
      "speaker": "发言人3"
    },
    {
      "time": "01:48:19",
      "text": "而且我觉得他们的脑子很奇怪，如果要换的话，也应该把把美元符号换成日元符号，对吧？那么为什么要去？",
      "speaker": "发言人1"
    },
    {
      "time": "01:48:26",
      "text": "那不行，那那那到时候美国爸爸就不开心。",
      "speaker": "发言人3"
    },
    {
      "time": "01:48:29",
      "text": "这还是不可能的。我觉得把日元符号换成美元符号比换掉后back slice更不可取。那个时候美元是多重要的一个东西，现在很重要。",
      "speaker": "发言人2"
    },
    {
      "time": "01:48:40",
      "text": "所以他们当时肯定是觉得说这个反斜杠很不重没不重要，所以就又给挪掉了。结果谁知道？Windows把这个反斜杠来做路径了，结果日本的windows的是满满眼都是日元符号，都是钱。对对等一下，等一下，刚才忘记说了一个就是在mac里面的唯一个不让用的是冒号，对吧？其实这个冒号是我们这平时用的这个GUI，就是在图形界面上不让用冒号的。因为是他们这个路径其实用的是冒号，对吧？所以是他这个路径的保留字，其实就是老翻译的里面。",
      "speaker": "发言人1"
    },
    {
      "time": "01:49:19",
      "text": "等一下我试一下，命令行也是可以用冒号的。",
      "speaker": "发言人3"
    },
    {
      "time": "01:49:22",
      "text": "在命令是可以用冒号的对吧？然后对在图形界面是可以用斜杠的。但是同样一个文件名，在命令行里面这个协但会变成冒号。",
      "speaker": "发言人1"
    },
    {
      "time": "01:49:35",
      "text": "等一下我刚才在在命令行里面建了一个带冒号的文件，然后在图形界面看它变成了一个斜杠。对。",
      "speaker": "发言人3"
    },
    {
      "time": "01:49:44",
      "text": "就交替了一下。",
      "speaker": "发言人4"
    },
    {
      "time": "01:49:46",
      "text": "对，是反着的。",
      "speaker": "发言人1"
    },
    {
      "time": "01:49:49",
      "text": "为什么是会这样？",
      "speaker": "发言人3"
    },
    {
      "time": "01:49:51",
      "text": "因为冒号在GOI里面有别的作用吗？",
      "speaker": "发言人4"
    },
    {
      "time": "01:49:54",
      "text": "我靠太神奇了。好，冒号在图形界面有什么用？",
      "speaker": "发言人3"
    },
    {
      "time": "01:49:57",
      "text": "在图形界面里面是不让用冒的文件名。",
      "speaker": "发言人1"
    },
    {
      "time": "01:50:01",
      "text": "那他为什么要显示成斜杠呢？",
      "speaker": "发言人2"
    },
    {
      "time": "01:50:03",
      "text": "这个很难理解。",
      "speaker": "发言人3"
    },
    {
      "time": "01:50:05",
      "text": "反正现在你现在mac的处理方式就是图形界面和和这个命令行里面冒号和斜杠是反。",
      "speaker": "发言人1"
    },
    {
      "time": "01:50:13",
      "text": "着的互相替代。",
      "speaker": "发言人4"
    },
    {
      "time": "01:50:15",
      "text": "因为在早期的finder里面的这个路径是用冒号隔开的。",
      "speaker": "发言人1"
    },
    {
      "time": "01:50:23",
      "text": "真的我真的会反就是会反过来。我第一次知道有这个事情，就是我在finder里面建一个。",
      "speaker": "发言人3"
    },
    {
      "time": "01:50:30",
      "text": "for斜杠，把在terminal里面显示为terminal，显示为负冒号把。我我我不跟你说了。",
      "speaker": "发言人2"
    },
    {
      "time": "01:50:37",
      "text": "我再说一遍，就是在老的finder，就是老的系统里面就是classical classical的这个mac里面，finder的路径的分隔符是用冒号路径分隔符。Windows是反斜杠吗？在finder里面是冒号。",
      "speaker": "发言人1"
    },
    {
      "time": "01:50:52",
      "text": "OK果然是一个用过classic mac的人。",
      "speaker": "发言人2"
    },
    {
      "time": "01:50:57",
      "text": "我怪不得。",
      "speaker": "发言人3"
    },
    {
      "time": "01:50:58",
      "text": "我就说所以这个是老老mac系统里面唯一一个的预留字。",
      "speaker": "发言人1"
    },
    {
      "time": "01:51:03",
      "text": "Ok明白。",
      "speaker": "发言人3"
    },
    {
      "time": "01:51:06",
      "text": "所以这直到现在为止，mac也是指不让用，然后这个他会跟斜杠转移。Ok但现在。",
      "speaker": "发言人1"
    },
    {
      "time": "01:51:14",
      "text": "其实已经没有再有这个classic mac了，对吧？所以这个转移其实完全没有什么现实意义了。",
      "speaker": "发言人3"
    },
    {
      "time": "01:51:23",
      "text": "对它就变成这个图形界面finder的一个spec掉了。",
      "speaker": "发言人1"
    },
    {
      "time": "01:51:27",
      "text": "OK这个很有意思。",
      "speaker": "发言人3"
    },
    {
      "time": "01:51:29",
      "text": "所以说这让我想起了windows。Windows上面其实除了文件名不能用特殊字符之外，还有不能用一些特殊保留字。比如说你不能把一个文件名叫做come.",
      "speaker": "发言人2"
    },
    {
      "time": "01:51:39",
      "text": "come是因为什么？是因为那个串口的。",
      "speaker": "发言人3"
    },
    {
      "time": "01:51:42",
      "text": "因为come是council，然后还有什么PRN还是PNT，还有x oxy的也不行。",
      "speaker": "发言人2"
    },
    {
      "time": "01:51:51",
      "text": "对，这个当时是为什么？我记得有这个事儿，但我忘了原因是什么了。",
      "speaker": "发言人3"
    },
    {
      "time": "01:51:55",
      "text": "Come是council，就是你要是打copy come，然后空格target点TXT，你就可以输入从那个council上输入字符，然后把它存成target点TXT就是抗实际上是council.",
      "speaker": "发言人2"
    },
    {
      "time": "01:52:11",
      "text": "的一个有特殊意义的这个名字，对吧？对它不是不能存在这个文件名。",
      "speaker": "发言人3"
    },
    {
      "time": "01:52:16",
      "text": "对，相当于一个相当于特相当于terminal里面的保留字了。",
      "speaker": "发言人2"
    },
    {
      "time": "01:52:22",
      "text": "对，但这个还蛮不我觉得这个还蛮不合理的。这个其实很很常用。他如果要是为了解决这个问题，直接禁掉了好几个比较短简短的名字。那你如果这样这如果这样，你还不如直接用一个什么特殊符号引引起来。",
      "speaker": "发言人3"
    },
    {
      "time": "01:52:38",
      "text": "或者你在前面加一个escape也可以。比如说下划线ox都要比ox好吧。",
      "speaker": "发言人2"
    },
    {
      "time": "01:52:45",
      "text": "或者是就是你用你你反正已经有那么多特殊字符不能用了，对吧？你就把用一个特殊字符来作为一个前缀了。或者用比如说美元符号这种情况，对吧？因为基本上不会有人把文件命名为美元符号开头的文件名。那也难说说所以。",
      "speaker": "发言人3"
    },
    {
      "time": "01:53:04",
      "text": "那个时候假如我们来做系统的话。",
      "speaker": "发言人1"
    },
    {
      "time": "01:53:09",
      "text": "就是当时这种选择肯定有它不合理的这个傻逼的地方，对吧？但是肯定有很多情况，也是有有不得已而为之的办法。",
      "speaker": "发言人3"
    },
    {
      "time": "01:53:18",
      "text": "Legacy路径依赖真的可以解决很多解释很多问题。",
      "speaker": "发言人2"
    },
    {
      "time": "01:53:22",
      "text": "对，你看你说刚才讲为什么卖QS现在里面你用一个反斜杠会变成在在图形界面为字符界面会变成冒号，对吧？然后冒这个冒号，这个会这边又反过来，不就是因为和这个classic mac要兼容，这个也是非常坑的。",
      "speaker": "发言人3"
    },
    {
      "time": "01:53:40",
      "text": "而且因为我们原来我自己原来是最早学道士的，我是打死我也不会赶在一个文件命令一用斜杠的，说是会出问题，多恐怖的一件事情。然后现在在麦克居然可以用斜杠，首先这是第一个意外，然后我再用这个命令行再去看一下，就发现变成冒号了，又变成第二个意外。",
      "speaker": "发言人1"
    },
    {
      "time": "01:54:02",
      "text": "就疯掉了。所以他到底那个情况在那里，他存的是冒号还是存的是斜杠的？就是在怎么描述这件事情，应该以还是以字符界面的为准。就只是说发现它是个显示的问题。",
      "speaker": "发言人3"
    },
    {
      "time": "01:54:15",
      "text": "真的unix上面的文件名是存在哪儿的？是存在。",
      "speaker": "发言人2"
    },
    {
      "time": "01:54:20",
      "text": "i node上的应该。",
      "speaker": "发言人3"
    },
    {
      "time": "01:54:24",
      "text": "看那个文件系统是吧，所以你要用一个，所以你要在去文件系统里面看这个东西到底是底层是被存成了哪一个字符。",
      "speaker": "发言人2"
    },
    {
      "time": "01:54:32",
      "text": "是对我很好奇这件事情他到底存在那里，存的是啥？",
      "speaker": "发言人3"
    },
    {
      "time": "01:54:36",
      "text": "我我我押冒号。",
      "speaker": "发言人2"
    },
    {
      "time": "01:54:39",
      "text": "我也读应该是冒号。",
      "speaker": "发言人3"
    },
    {
      "time": "01:54:42",
      "text": "我也觉得应该是冒号。对。斜杠只是给你们这些愚蠢的人类看一看而已。",
      "speaker": "发言人1"
    },
    {
      "time": "01:54:48",
      "text": "斜杠is the illusion，对吧？追寻它底层到底是什么字符，这个问题就留给real当做他的课后作业了。",
      "speaker": "发言人2"
    },
    {
      "time": "01:55:00",
      "text": "好的，所以你看如果这种情况发生，你们想怎么办，就是会发生什么事情？这个也是一个小作业，麦克上可以的文件名往windows上，比如说你拿个U盘复制过去对吧？或者是反过来，windows上可以有的文件名往mac上复制会发生什么？它会帮你改掉，还是会报错。",
      "speaker": "发言人3"
    },
    {
      "time": "01:55:24",
      "text": "它不会报错，它会自动帮你改掉。",
      "speaker": "发言人1"
    },
    {
      "time": "01:55:26",
      "text": "就是直接越俎代庖了，说你只能这么干。",
      "speaker": "发言人3"
    },
    {
      "time": "01:55:29",
      "text": "对吧？改掉是什么意思？",
      "speaker": "发言人4"
    },
    {
      "time": "01:55:30",
      "text": "他还会替换掉。",
      "speaker": "发言人1"
    },
    {
      "time": "01:55:32",
      "text": "我有个问题，就比如说我现在有一个U盘，然后我把mac上一个包含了windows非法字符的文件拷过去了。然后我这U盘插到windows上，它的资源管理器看起来是什么样的。",
      "speaker": "发言人4"
    },
    {
      "time": "01:55:45",
      "text": "在非法的边缘试探。",
      "speaker": "发言人2"
    },
    {
      "time": "01:55:47",
      "text": "不直接炸了。",
      "speaker": "发言人3"
    },
    {
      "time": "01:55:50",
      "text": "你自己试一下。",
      "speaker": "发言人1"
    },
    {
      "time": "01:55:54",
      "text": "比如说我我要我要整11个1个你整一个U盘的这个ox杠1-2 com 3抗的LPT1都放进去，然后你怎么办？然后拿到屋子上去无法打开，不可以打开。",
      "speaker": "发言人3"
    },
    {
      "time": "01:56:06",
      "text": "这个就不可以打开，是后来的，我首先我还能不能看到这文件呢？这文件是在直接在我的U盘上就是看不到了吗？是怎么样。",
      "speaker": "发言人4"
    },
    {
      "time": "01:56:16",
      "text": "的不知道，我们可以做个实验试一下。",
      "speaker": "发言人3"
    },
    {
      "time": "01:56:19",
      "text": "还是会被转移掉呢？还是。",
      "speaker": "发言人1"
    },
    {
      "time": "01:56:21",
      "text": "那个那个符号可以转译，但是像那个windows的那几个不能就不可不可能存在的文件名，你肯定就比较尴尬了。",
      "speaker": "发言人3"
    },
    {
      "time": "01:56:30",
      "text": "这让我想起了那个VMRC。如果你手工创建一个以点开头的文件的话，是做不到的。但是你可以通过编辑器把它另存为这样一个文件，在windows里面是可以的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:56:43",
      "text": "那点开头的文件在unix下面，它是叫做隐藏文件的意思，就是你listing是看不见的是吗？对，麦克斯麦克斯是麦克斯坦，他继承了这unix那套逻辑，他也是用了这个东西的。",
      "speaker": "发言人3"
    },
    {
      "time": "01:56:56",
      "text": "Unix在早期的时候没有隐藏文件这个概念，它只不过在比如说你在IOS或者是在什么的时候，它默认会跳过那些点和点点。因为代表本级目录和上级目录，所以有些人就发现，我直接把文件一点，它对它就不会列出来了。",
      "speaker": "发言人2"
    },
    {
      "time": "01:57:14",
      "text": "所以就是为了不写代码，为了省事儿，为了省事这样的一个hack。其实也好了，这种为了省事儿，至少我觉得还有一个什么客观的理由，对吧？Come一怎么一回事？就是这个。这很过分的，你知道吗？始终不能忘记有更好的选择。对，还是这样。",
      "speaker": "发言人3"
    },
    {
      "time": "01:57:33",
      "text": "这个com从1 2 3 4 5 6 7 8 9 10，然后还有那个LPT，LPT的123456789都是不能的。",
      "speaker": "发言人1"
    },
    {
      "time": "01:57:43",
      "text": "是什么？是打印机那个什么接口吗？",
      "speaker": "发言人3"
    },
    {
      "time": "01:57:45",
      "text": "还是什么玩意儿？LPT好像是打印机。",
      "speaker": "发言人2"
    },
    {
      "time": "01:57:48",
      "text": "但是我记得就当年那个针式的打印机有这个接口是这样子。对，OK终于可以聊大小写的问题了，又是一个坑。我想我先理一下现在是什么一个情况，就是说我们我们我们都我们不考古了，就只聊现代这个文件系统。",
      "speaker": "发言人3"
    },
    {
      "time": "01:58:09",
      "text": "现在这个操作系统在mac上面默认情况下是可以叫什么来着区分，这里要先讲两个概念，什么叫大小写敏感和大小写保留，对吧？这两个概念是什么意思呢？就是说假设我写这个AB然后A大写B小写和弦AB都小写的情况下，它是应该是一个文件还是两个文件的问题。如果说它两个是你认为它是两个是一个文件，它说明这个系统是大小写不敏感，对吧？因为他认为它是同等的一个东西。这个时候比如说我们从从这个从这个实现的逻辑来讲，你就可以认为说那存的时候都是把这个东西转译成这个小写，然后存到文件系统里面去，或者是都是存都是做成大写存在文件系统里面去，这个不重要。",
      "speaker": "发言人3"
    },
    {
      "time": "01:58:54",
      "text": "但是比如dos dos的标准操作好像全都是大写。",
      "speaker": "发言人2"
    },
    {
      "time": "01:58:58",
      "text": "对对对，这个是敏就是敏不敏感的问题。这个保不保留，或者叫英文里面叫做preserving，就是case preserving的问题。就是说虽然你可以不敏感，但是你也可以保留这个的区别就是什么意思？但你还是知道说虽然说A大A小B和小A小B都是你认为是等价的，但是你还是把这个大A小B给存下来了，对吧？",
      "speaker": "发言人3"
    },
    {
      "time": "01:59:23",
      "text": "抄只是照抄而已，但是还是把它当成一样的。",
      "speaker": "发言人1"
    },
    {
      "time": "01:59:27",
      "text": "对，所以这里面我就一直没想明白这个事情。就是说既然大小姐都都这个叫什么呢？都不敏感了，对吧？你为什么还要保留呢？其实没什么用。",
      "speaker": "发言人3"
    },
    {
      "time": "01:59:38",
      "text": "我觉得是为了客户用户方面。因为用户有时候就看起来对。",
      "speaker": "发言人2"
    },
    {
      "time": "01:59:43",
      "text": "这就是拉丁字母本位的表现。因为使用拉丁字母的人他们有大写和小写，但是他们在他们脑海中对这个大写和小写的区分的语义的识别能力会相对弱一点，他们会认为他们是一样的。",
      "speaker": "发言人4"
    },
    {
      "time": "01:59:58",
      "text": "意思上是一样的，对形式上写的不一样。",
      "speaker": "发言人1"
    },
    {
      "time": "02:00:02",
      "text": "其实跟那个unicode t的那个问题是有点类似的，对吧？",
      "speaker": "发言人3"
    },
    {
      "time": "02:00:06",
      "text": "而且刚才也不说了各种这种各各种什么camel case这种东西，它其实它大小写只是为了容易读，对吧？意思其实是一样的，所以就是看起来好看而已，然后还是当做一个东西。",
      "speaker": "发言人1"
    },
    {
      "time": "02:00:21",
      "text": "但这些这里其实是在不同语境下面，这个东西是有非常大的区别的。虽然说我们我们又回到刚才那个camel case那个地方，那个讲的是什么？那个讲的是identify，就是识别符对吧？在绝大多数语言里面，这个识别符都是大小写敏感的。就是刚才说这个大A小B和小A小B它明显是它可以是两个它是两个不同的一个变量也好，两个不同的一个名字对吧？但是在绝大多数的这个名five作为ID的时候，作为一个比如用户账户用户名的时候，他通常是不敏感。",
      "speaker": "发言人3"
    },
    {
      "time": "02:00:53",
      "text": "比如说我们讲twitter的这个对推特就是这么一个典型的例子。推特它是是大小写保留，但是大大小写不敏感对吧？比如说我的这个twitter的handle叫做real job对吧？就是我的R和J大写就是两个词。但是你在UIL里面，你写这六个字母的任意大小的组合，它都是带到我的那个页面上面去的。所以他这一点他其实twitter的这个命名这一点，他其实是跟这个麦克上默认的文件名命名的那个大小写的敏感方式是一样的，叫做case insensitive。大家也不敏感，but case preserving对吧？但是保留大小写。",
      "speaker": "发言人3"
    },
    {
      "time": "02:01:30",
      "text": "现在的你们有人写vision basic吗？就visual basic应该是大小写不敏感的，但是vision basic是不是大小写保留的呢？我记得不太清楚了。因为当时vvv当时被最被人吐槽了以后，被最被职业成员吐槽的一点就是他居然是一个大小写不敏感的语言。你可以想象吗？",
      "speaker": "发言人2"
    },
    {
      "time": "02:01:54",
      "text": "等一下，到net它整个命名规则是一样的吗？",
      "speaker": "发言人1"
    },
    {
      "time": "02:01:58",
      "text": "不一样，到net只是一个run time.",
      "speaker": "发言人2"
    },
    {
      "time": "02:02:00",
      "text": "不一样的端内短好多语言。",
      "speaker": "发言人3"
    },
    {
      "time": "02:02:02",
      "text": "当然是底层肯定是区分大小写的，就是那套IL mac.",
      "speaker": "发言人2"
    },
    {
      "time": "02:02:07",
      "text": "上面其实是可能这个问题相对复杂的。因为mac上它存在一个同一个文件系统，它有另外一种方式是可以大小性感。",
      "speaker": "发言人3"
    },
    {
      "time": "02:02:15",
      "text": "的日志是区分大小写。",
      "speaker": "发言人1"
    },
    {
      "time": "02:02:18",
      "text": "我那个时候就是傻不拉几的把自己的那个分区隔成了这个区，就是严格区分大小写的文件系统。后来好多游戏装不了，就是装游戏的时候他会说你不能把这个程序装在一个大小写敏感的分区上面。",
      "speaker": "发言人2"
    },
    {
      "time": "02:02:34",
      "text": "很扯它，因为它不一样。对对对，这是另外一个比较。对，因为比如说mac上我们现在用的主流的这个这个叫做是固态存储。固态存储它现在默认的那个文件系统的格式是APFS。但是在mac上面，它是用的是mac的这APFS的大小写不敏感的那套默认值。但是在iphone上面虽然你看不见，但是在iphone上面他默用的默认是APFS大小写敏感的那一套。",
      "speaker": "发言人3"
    },
    {
      "time": "02:03:00",
      "text": "Iphone是区分大小写的，就是APAPFS.",
      "speaker": "发言人1"
    },
    {
      "time": "02:03:04",
      "text": "区分大小写的，APFS是大小写敏感的。对对对，很奇怪对吧？所以我觉得其实这是一个问题。因为我是觉得就是从信息的这个角度来讲，肯定说是区分是更好的。只是说从叫什么来着idea proof这个角度来看可能稍微差一些。但是在IOS上面去，用户是并不能直接读写文件系统的，所以不存在这个问题。既然他们自己不是idiot，那就没有这个问题了。",
      "speaker": "发言人3"
    },
    {
      "time": "02:03:35",
      "text": "好吧。",
      "speaker": "发言人1"
    },
    {
      "time": "02:03:36",
      "text": "等一下windows现在什么状况，我有点忘了。Windows是大小敏感吗？",
      "speaker": "发言人3"
    },
    {
      "time": "02:03:39",
      "text": "不敏感。Windows现在是大小写保留。",
      "speaker": "发言人2"
    },
    {
      "time": "02:03:42",
      "text": "那就跟麦克一样的。",
      "speaker": "发言人1"
    },
    {
      "time": "02:03:43",
      "text": "那就不敏感了。",
      "speaker": "发言人3"
    },
    {
      "time": "02:03:44",
      "text": "对。",
      "speaker": "发言人2"
    },
    {
      "time": "02:03:46",
      "text": "OK然后那个NTFS是没有这个大小写敏感的选项的对吧？应该是没有的。这个其实大小写叫什么呢？大小写不敏感，但是大小写保留其实在实践上其实有有会导带来一个更麻烦的事情，就是你要存。比如说你你你你想一下，你要去判断这个文件到底在这个目录里面存不存在的时候，你要做什么？你要先把这个文件名找到目标文件文件名你要先把它统一化成一个，比如说周小写或者大写，然后你还得把这个叫什么来着？就是这所有目录里已经有的文件名都得统一成都想都都想你才能够逐个字符逐个这个字符比较，对不对？所以我觉得这个其实其实效率挺低的对对，所以我觉得大小写敏感还是一个更好的一个方案。然后就是另外一个更加坑爹的问题了，就是那文件名可不可以用UUNIL de的来写。",
      "speaker": "发言人3"
    },
    {
      "time": "02:04:44",
      "text": "用EMOJI来写是吧？",
      "speaker": "发言人2"
    },
    {
      "time": "02:04:46",
      "text": "现在是可以的，是是是。",
      "speaker": "发言人1"
    },
    {
      "time": "02:04:48",
      "text": "现在是，现在已经可以了。就好像那个swift最开始不就是好多例子里面都出现了用unique做来的发言吗？就非常坑爹。对你想要对来一个自动完成都做不到。",
      "speaker": "发言人2"
    },
    {
      "time": "02:05:04",
      "text": "一个现代的语言，它基本上都是以这个unicode的友好为或者叫做unicode的兼容为卖点一个标准。对，为卖点你可以直可能也是就是刚才我们讨论的另外的一个问题了。既然你就说不要以这个英语为中心主义的话，那我的文件不我的这个变量命名为什么不可以是中文呢？既然都可以是中文，为什么不能是一个的礼貌级呢？",
      "speaker": "发言人3"
    },
    {
      "time": "02:05:34",
      "text": "所以他可以，你刚才发出了一个什么声音？",
      "speaker": "发言人2"
    },
    {
      "time": "02:05:39",
      "text": "就是一个某一种表情符号。",
      "speaker": "发言人3"
    },
    {
      "time": "02:05:42",
      "text": "那呕吐的那个是，你刚才同学们刚才real念出了呕吐这个表情。",
      "speaker": "发言人2"
    },
    {
      "time": "02:05:51",
      "text": "我为他赋予了语音。",
      "speaker": "发言人4"
    },
    {
      "time": "02:05:53",
      "text": "这毕竟是一个纯听觉的节目，你要我怎么办？我只能采用通感的方式给你们讲，我们感受到了。感受到了，是的。",
      "speaker": "发言人3"
    },
    {
      "time": "02:06:04",
      "text": "以后real应该出一套，应该在节目里面出一套这个EMOJI的发音指南。",
      "speaker": "发言人2"
    },
    {
      "time": "02:06:09",
      "text": "不叫做或者叫做podcast em user guide。",
      "speaker": "发言人3"
    },
    {
      "time": "02:06:15",
      "text": "比如说笑出猪叫声这个emerge。",
      "speaker": "发言人2"
    },
    {
      "time": "02:06:22",
      "text": "有这个疑问，基本没有这个疑问。我我我这个就不叫一磨叽了，这个叫什么？这叫voice模具对吧？Audio墨叽这根本就不是墨迹。",
      "speaker": "发言人3"
    },
    {
      "time": "02:06:38",
      "text": "对，其实就是在这里就是用unique的作为这个命名的方式，刚才也会出现类似于最开始提到的那个这个中文的括号和英文的括号怎么长得都是一样。但是为什么我始终找不到这个文件，这个问题对不对？但unique的也提供了我们之前也解释过，有那个叫叫什么克莱德的那个方案，对不对？虽然这两个它不是同一个码位，但是我们在搜索或者是在true的时候，认为它们在语义上是等价的对，所以理论上你只要找到这个东西，也能找到另外一个。但这个就是程序要做更加复杂的特别的handle，就不能简单的。我只要比较这两个字符串的它每一个字节是不是一样就可以了，对吧？就是就会变得更加复杂，那个超复杂的。所以什么为什么我们不能有一个简单安全的应用的系统，可能就是这帮人干的。",
      "speaker": "发言人3"
    },
    {
      "time": "02:07:36",
      "text": "你们记不记得当年，应该是好好有好几年前了，就是iphone的在某某最开始的几年的时候经常会出现。因为你收到一条短信，里面包含了一个奇怪尤尼克伯符合，然后你的系统就崩溃了，对系统就死机或者崩溃了这种情况对吧？对，你可以说这个是这个叫什么那个程序员写的这个代码，这个软件质量不够高，没错，事实至少也是这样的对吧？但是这个复杂度是因为什么东西引起的呢？",
      "speaker": "发言人3"
    },
    {
      "time": "02:08:04",
      "text": "所以现在unicode他们在做很多事情的话，很首先就是在安全性上面是他们很大的一个考虑因素。",
      "speaker": "发言人1"
    },
    {
      "time": "02:08:14",
      "text": "对，这个在各家实现的时候要考虑。",
      "speaker": "发言人3"
    },
    {
      "time": "02:08:16",
      "text": "因为他们进行这个信息交换的时候，就全部都传过去了。你这一传过去的话。",
      "speaker": "发言人1"
    },
    {
      "time": "02:08:22",
      "text": "对对对，就是本质上你从信息安全的角度来讲，这个是就是你只要从外部传过来的一段信息，你就认为默认它应该是不可信的，对吧？然后又恰巧碰碰上了这个unicode的这么一套复杂的要死的系统之后，那就很容易出现问题，因为复杂度越高bug越多。",
      "speaker": "发言人3"
    },
    {
      "time": "02:08:42",
      "text": "对，所以一开始他们就有些朋友可能就觉得很奇怪，尤尼克不就是一个文字的编码吗？怎么还会跟这个信息安全产生关系，对吧？其实就是因为它里面有很多复杂的，就各种文字都夹在里面，所以很容易做文章。",
      "speaker": "发言人1"
    },
    {
      "time": "02:08:59",
      "text": "现在逼得我们吴涛都已经不再从事安全行业了，对吧？都是这个用户需求的坑。",
      "speaker": "发言人3"
    },
    {
      "time": "02:09:05",
      "text": "我觉得主要还是怎么说呢？安全行业需要人们有意识，就是只有人们认为安全是重要的时候，安全是安全，全行业才有前途。现在只能说大部分人都太没有，就太不在乎了，只有等到失窃的时候才会后悔，真的。",
      "speaker": "发言人2"
    },
    {
      "time": "02:09:23",
      "text": "那是那肯定对。但我就说你的这个解决方案什么，那就只能说就加大投入。但我的想法就是说能不能不能够可以不要加大成本，就是不要给我搞那么有点扣的麻烦事，好吧。为什么要组合？一个字一个马位代表一个字不好吗？你又不缺那几个马位，对吧？组合个毛线。",
      "speaker": "发言人3"
    },
    {
      "time": "02:09:43",
      "text": "对，你知道有一种比如说路，路就是一个所谓asking clean的这么一个编程语言，它的核心的整个library是不会触及到这个SKI的。第八位的就全部。",
      "speaker": "发言人2"
    },
    {
      "time": "02:09:57",
      "text": "都100，就是前七位搞定。",
      "speaker": "发言人3"
    },
    {
      "time": "02:09:59",
      "text": "所有的东西都在耳熟能详，所有的计算机，所有的C源系统都支持的这些码位里面。这也是一个思路，就是走这个绝对可行的最小的集合。",
      "speaker": "发言人2"
    },
    {
      "time": "02:10:12",
      "text": "但是不行，人用户需求提出来，我就要看这个对你摸起怎么办。",
      "speaker": "发言人3"
    },
    {
      "time": "02:10:21",
      "text": "Rio是本日。",
      "speaker": "发言人2"
    },
    {
      "time": "02:10:23",
      "text": "最佳声优对吧？所以最终还是向这个用户需求妥协了，对吧？还是必须得硬着头皮上，就把这些bug就都给修了，然后拿着那个超级厚unicode现在都应该是出到11了，对不对？对。",
      "speaker": "发言人3"
    },
    {
      "time": "02:10:39",
      "text": "十三了。",
      "speaker": "发言人1"
    },
    {
      "time": "02:10:40",
      "text": "十三了，我又out了。那个那个册子有多少页了，现在他那个规范，你说这那个那个PDF.",
      "speaker": "发言人3"
    },
    {
      "time": "02:10:49",
      "text": "这要问梁海了。",
      "speaker": "发言人2"
    },
    {
      "time": "02:10:51",
      "text": "对，应该得上百兆了。我估计unicode.",
      "speaker": "发言人3"
    },
    {
      "time": "02:10:55",
      "text": "的第11版的core specification的PDF版本是976页。",
      "speaker": "发言人1"
    },
    {
      "time": "02:11:05",
      "text": "那13肯定超过1000了。",
      "speaker": "发言人3"
    },
    {
      "time": "02:11:09",
      "text": "但是一个这个PDF1共才14.2M.",
      "speaker": "发言人1"
    },
    {
      "time": "02:11:14",
      "text": "还好，这还只是core，那还有周边的。",
      "speaker": "发言人3"
    },
    {
      "time": "02:11:17",
      "text": "这只是core specific，就不带那个码表。",
      "speaker": "发言人1"
    },
    {
      "time": "02:11:21",
      "text": "对的，附录还有那些数据表非常的多。",
      "speaker": "发言人4"
    },
    {
      "time": "02:11:23",
      "text": "对，这只是specification.",
      "speaker": "发言人1"
    },
    {
      "time": "02:11:26",
      "text": "的一个超级无敌的深坑，想想就是累。对于我们这种尽可能说砍用户需求，不要增加复杂度的这种思维方式的人，这个叫什么过于复杂可以不做，对吧？好吧，今天我们这个脑洞也比较多哈，然后聊聊了天哪从哪里聊到哪里了。",
      "speaker": "发言人3"
    },
    {
      "time": "02:11:55",
      "text": "不过挺好的。就是这整个命名规则，对吧？就是文像这个长度，自然字符串长度，然后空格，就这个保留字不允许的字符不允许的这些文件名是否区别大小写，这个就是命名的。该说都说了，对吧？也了了我一桩心愿。",
      "speaker": "发言人1"
    },
    {
      "time": "02:12:18",
      "text": "了了一桩心愿。",
      "speaker": "发言人2"
    },
    {
      "time": "02:12:21",
      "text": "结果憋了好久没说了。",
      "speaker": "发言人1"
    },
    {
      "time": "02:12:22",
      "text": "这个人可以瞑目了。",
      "speaker": "发言人3"
    },
    {
      "time": "02:12:25",
      "text": "并没有明目，我们还要把你抓来串台。好了，你们可以收个尾OK。",
      "speaker": "发言人1"
    },
    {
      "time": "02:12:32",
      "text": "您刚才收听到的节目是内核恐慌，一堂贴尽量贴近计算机主技术主题的娱乐podcast。我们号称硬核，但是也没有什么干货，想听就听，不想听的就别听。我们的网址是PAN dot ICU。您可以在网站上找到订阅我们节目的方法，以及联络我们的方式。",
      "speaker": "发言人2"
    },
    {
      "time": "02:12:50",
      "text": "如果您期待我们更频繁的更新节目，欢迎您到爱发电为我们捐款。捐款地址是爱发电dos net flash at kero panic先发电后催更，文明催更从你做起。如果您觉得意犹未尽，也欢迎您去收听real和黄海主播的风投圈，rio和人均主播的提前怀旧，以及基本不由吴涛主播的自弹自唱。好。",
      "speaker": "发言人2"
    },
    {
      "time": "02:13:20",
      "text": "我们的发电时间太长了，你要念他去我们官网点边接，谁记得住？",
      "speaker": "发言人3"
    },
    {
      "time": "02:13:26",
      "text": "说的是回头我把这个删了，好吧？再次感谢大家收听本期的自弹自唱的串台节目。自弹自唱。如果大家对我们的节目有什么意见或者反馈，都可以写邮件给我们的邮箱地址是podcast at the type点com PODCST at THETYPE点COM。同时大家也可以在推特、在微信以及在微博上面搜索the type，找到我们THETYEP，在facebook上搜索the type或者type is beautiful，都可以找到我们。",
      "speaker": "发言人4"
    },
    {
      "time": "02:13:59",
      "text": "这比我们啰嗦多了。",
      "speaker": "发言人2"
    },
    {
      "time": "02:14:00",
      "text": "我觉得没有对比就没有伤害。",
      "speaker": "发言人3"
    },
    {
      "time": "02:14:05",
      "text": "自弹自唱基本上是不需要催更的，我们是隔周二播出，从开播以来就从来没有间断过。所以大家可以顺便来给我们催更的话，来加强我们的自弹自唱的这样一个串台节目的催更工作。",
      "speaker": "发言人1"
    },
    {
      "time": "02:14:20",
      "text": "专门催自弹自唱。",
      "speaker": "发言人3"
    },
    {
      "time": "02:14:23",
      "text": "希望我们下次的这个串台不会一年之后。",
      "speaker": "发言人1"
    },
    {
      "time": "02:14:26",
      "text": "再见OK。好。",
      "speaker": "发言人3"
    },
    {
      "time": "02:14:27",
      "text": "感谢大家的收听。本次节目是eric在mac OS上剪辑制作完成的，我们下次节目再见。",
      "speaker": "发言人1"
    },
    {
      "time": "02:14:38",
      "text": "拜拜。",
      "speaker": "发言人3"
    }
  ],
  "lab_info": {
    "summary": "本期播客，讨论者深入探讨了计算机命名规则及其在不同操作系统中的应用，包括文件名的命名规则、路径分隔符的使用以及大小写敏感性问题。他们强调了特殊字符的使用限制，讨论了命名规范对编程、文件管理和系统操作的重要性，并涉及技术细节如Unicode编码的复杂性及其对系统安全的影响。讨论还触及了各种编程语言和操作系统在命名规则上的差异，以及用户需求与技术实现之间的权衡。同时，播客还回顾了节目演变，强调了技术、设计和文化价值的追求，讨论了自弹自唱和内核恐慌的创新尝试，以及跨平台兼容性和用户界面设计。节目还分享了与听众互动的经验，突出了听众反馈在节目发展中的重要性。",
    "qa_pairs": [
      {
        "question": "自弹自唱和内核恐慌串台的自弹自唱总共有多少期了？",
        "answer": "我们串了九期了。",
        "time": "00:01:11"
      },
      {
        "question": "自弹自唱从第99期更新到第126期，内核同框从第55期更新到了第58期，中间经历了多久的时间和变化？",
        "answer": "中间经历了整整一年的时间，我们的自弹自唱和内核同框都有了更新。",
        "time": "00:01:22"
      },
      {
        "question": "你们的logo和官网字体都发生了什么变化？",
        "answer": "对，我们这个是2020年改头换面，包括更换了logo和官网字体。",
        "time": "00:02:04"
      },
      {
        "question": "之前考虑过换成点阵字，但为什么最后没有采用？",
        "answer": "点阵字虽然体积问题理论上可以解决，但在实际使用中受限于web字体格式不支持内嵌点阵，且考虑到兼容性和显示效果，最终采用了矢量模拟点阵的方案。",
        "time": "00:03:43"
      },
      {
        "question": "对于字体大小的处理，点阵字有何限制？",
        "answer": "点阵字每个字号需要一套对应的点阵，而假点阵（矢量模拟点阵）则可以随意缩放，不受此限制。",
        "time": "00:07:34"
      },
      {
        "question": "在高分辨率屏幕下，如何实现整数倍缩放以保持清晰锐利的显示效果？",
        "answer": "目前显卡技术上通常通过插值算法来达到接近整数倍缩放的效果，但对于点阵字来说，由于渲染限制并不能做到像素点对像素点的精确对应，可能导致边缘模糊或次像素平滑问题。",
        "time": "00:09:52"
      },
      {
        "question": "mac和IOS设备中，关于高分屏或者说retina屏幕，它们的像素比例是怎样的？",
        "answer": "大部分mac和新基、试用中的IOS设备采用的是高分屏，即retina屏幕。其中常见的mac设备一般是二叉屏，而像iPhone 11 pro这样的设备则是333倍（可能是3倍）的三叉屏。对于逻辑像素与物理像素的关系，以15个像素的逻辑对应30个像素的物理为例，这意味着物理分辨率是逻辑分辨率除以1/10这个缩放值后的结果。",
        "time": "00:13:21"
      },
      {
        "question": "macbook pro 13寸机型的屏幕分辨率情况是怎样的？",
        "answer": "最新的macbook pro 13寸机型的屏幕面板分辨率是2560乘以1600，但在默认设置下，并非点对点清晰显示，而是采用了缩放模式，推荐分辨率是1440乘以900，物理上并不能完全除尽，实际显示面积为1440乘以900，而非原生的2560乘以1600。",
        "time": "00:15:06"
      },
      {
        "question": "对于点对点显示的问题，您是如何处理的？",
        "answer": "我通常会手动将分辨率调整为点对点的模式，例如对于15寸设备，我会改为其原生的两倍分辨率，虽然这样会使可显示的实际面积感觉变小，但保证了文字大小和设计元素的正常显示。",
        "time": "00:16:19"
      },
      {
        "question": "系统为何推荐使用缩放模式而非点对点显示？",
        "answer": "苹果系统推荐使用scale mode（缩放模式）是为了让屏幕内容看起来更容量大，展示更多信息，但这会影响显示质量，尤其是对于追求点对点清晰度的用户来说。不过，普通用户可能察觉不到差异。",
        "time": "00:16:12"
      },
      {
        "question": "低像素点阵在不同设备上的应用情况如何？",
        "answer": "在一些设备上，如macbook笔记本，由于系统默认设置并非点对点清晰，需要手动调整至点对点模式以达到最佳视觉效果。而在IOS设备上，由于其限制，目前还无法实现点对点显示。对于开发者而言，在显卡处理能力、面板带宽以及面板工艺限制下，系统做出了一种折中解决方案，但并不是理想状态。",
        "time": "00:17:39"
      },
      {
        "question": "在实际应用中，低像素点阵字的易读性和实用性如何？",
        "answer": "在特定场景下，比如网站内容以中文和英文为主且无需高度精细排版的情况下，低像素点阵字表现得相对较好，具有较高的易读性。例如，在官网中用于口号、代码片段等简单文本，虽然在某些情况下可能不如常规字体清晰，但在自适应宽度下，点阵字仍能呈现出独特的风格和不错的可读性。",
        "time": "00:22:15"
      },
      {
        "question": "在mac和windows上使用相同的CSS规则是否能达到同样的效果？",
        "answer": "不完全一样，由于底层操作系统的问题，即使使用同样的CSS规则，在mac和windows上得到的效果也会有所不同。",
        "time": "00:26:54"
      },
      {
        "question": "对于次像素平滑问题，各家浏览器的表现如何？",
        "answer": "次像素平滑这个问题在各家浏览器中表现较多问题，特别是在关掉次像素平滑功能时，效果尤其不佳。",
        "time": "00:26:59"
      },
      {
        "question": "是否有针对点对点渲染效果的CSS规则或实现？",
        "answer": "提到了一个名为“tax rainer's”或“font render”的CSS规则，但目前只有Mozilla和WebKit有不同的实现，且效果在不同平台上表现不一。",
        "time": "00:27:09"
      },
      {
        "question": "是否有案例尝试通过CSS来复原老版Windows操作系统的视觉效果？是否可以通过特定技术手段实现网页在不同系统上的像素级别对齐？",
        "answer": "是的，有案例在做这样的尝试，甚至有人尝试用CSS模拟出早期Windows XP时代的像素感字体和界面元素，但受限于技术局限，无法实现完全点对点渲染。虽然存在一些挑战，但如果对要求降低，例如只针对网格排布等设计，理论上可以通过调整CSS或使用canvas API直接画出像素级别的对齐效果，尽管这可能会影响网页的可访问性。",
        "time": "00:27:58"
      },
      {
        "question": "是否讨论过将网站设计成Rachel风格，即模拟复古风格的操作系统界面？",
        "answer": "是的，目前在设计界兴起了一股复古风潮，包括网页设计也开始流行模仿90年代的操作系统风格，但这对于同时追求复古外观和高可用性的网站来说是个难题。",
        "time": "00:32:09"
      },
      {
        "question": "什么是8.3规则？",
        "answer": "8.3规则是指在Windows 3.1开始支持长文件名，但为了向下兼容，当文件在DOS下显示时，仍会显示为8.3格式。其中，文件名由8个字符组成，扩展名由3个字符组成，以一个波浪号和数字表示。",
        "time": "00:41:29"
      },
      {
        "question": "Unix系统是如何处理文件类型的？",
        "answer": "Unix系统没有扩展名的概念，其文件类型判断主要依赖于文件头部的特殊标记或结构，而非文件名。用户可通过命令如file来推测文件类型，而无需依赖于直观的扩展名标识。",
        "time": "00:43:44"
      },
      {
        "question": "在文件系统中，文件名的命名规则是怎样的？",
        "answer": "文件名的命名规则因操作系统不同而有所差异。在早期的移动first generation（可能是笔误，应为mobile first generation）系统中，即Windows 95之前的时代，遵循了8.3规则，即文件名最多8个字符，扩展名3个字符。而在Mac OS系统中，早期并没有扩展名的概念，而是通过资源叉（resource fork）来存储文件类型等元数据，这样就不再受限于扩展名长度。到了现代，Windows系统支持长达255个字符的文件名，Unix系统则相对灵活，不强制要求扩展名。",
        "time": "00:45:14"
      },
      {
        "question": "为什么文件会有扩展名？文件名长度和扩展名的规定是怎样的？",
        "answer": "文件扩展名起源于70年代CPM操作系统，创始人认为文件类型信息应该包含在文件名中。Windows系统采用扩展名来描述文件类型，用户通过扩展名判断文件类型，如.txt、.jpg等。而Mac OS中虽然默认不显示扩展名，但其实也有类似机制，只是实现方式不同，例如通过资源叉存储文件类型信息。在DOS时代，文件名最长8个字符，扩展名最长3个字符；Windows系统后来放宽了这个限制，可以有更长的文件名和扩展名；而在Mac OS中，虽然默认不显示扩展名，但资源叉的存在使得文件类型信息依然可以被获取，从而实现了灵活且兼容性较好的文件系统结构。",
        "time": "00:46:17"
      },
      {
        "question": "为什么Windows系统后来默认隐藏了文件扩展名？",
        "answer": "Windows系统最初保留文件扩展名是在字符界面与图形界面过渡时期，为了在没有图标和详细信息展示的情况下区分文件类型。但随着图形界面的发展和文件类型图标化，扩展名的重要性逐渐减弱，且为了避免用户误改文件类型，Windows系统从XP开始默认隐藏扩展名。",
        "time": "00:56:40"
      },
      {
        "question": "在现代操作系统中，比如Windows 10或macOS上，是否还普遍使用文件扩展名？对于需要在字符界面和图形界面切换的用户，如何更改包含扩展名的文件名？",
        "answer": "现在主流的操作系统如Windows 10和macOS（准确说是mac OS）默认情况下都不会展示文件扩展名，但在图形界面下可以选择不展示扩展名。不过，在文件类型图标和详细信息视图中，扩展名仍然存在且具有作用。例如，在macOS中，由于有更详细的图标展示，扩展名并不是必需的，而Windows系统则默认隐藏扩展名以减少用户对文件类型记忆的需求。在Windows系统中，即使默认不显示扩展名，当用户想要改名文件时，可以直接输入要改的新文件名（包括扩展名），系统会保留原有扩展名不变，仅更改文件名部分。而在macOS中，若要改名包含扩展名的文件，需使用特定技巧，如在命令行中使用引号包围带空格的文件名。",
        "time": "00:57:38"
      },
      {
        "question": "文件名中是否允许包含空格？",
        "answer": "文件名是否允许包含空格是一个复杂的问题。早期操作系统如DOS并不允许文件名中有空格，而在西方文化习惯中，文件名通常按词分写，包含空格。然而，在命令行操作中，空格可能导致参数识别混乱，例如复制文件时源文件名和目标文件名间用空格分隔可能导致错误。虽然可以通过引号解决这一问题，但空格的存在仍会带来诸多不便，因此建议尽量避免在文件名中使用空格。",
        "time": "01:01:37"
      },
      {
        "question": "在文件名中如何处理空格？Windows系统中如何处理带有空格的文件名？",
        "answer": "在文件名中，为了容纳空格，需要引入escape机制，例如使用双引号（\" \"）进行转义。Windows系统对空格的处理较为复杂，需要在文件名中加上双引号，并且其命令行编辑器（Live Editor）在处理空格时功能并不完善。在Windows系统中，文件名不能直接使用空格，必须通过双引号进行转义。此外，Windows没有类似Unix那样的便捷编辑器功能，比如无法通过特定组合键直接跳转到文件名的开头。",
        "time": "01:06:28"
      },
      {
        "question": "Unix系统和Windows系统在路径符号上有什么不同？",
        "answer": "Unix系统使用正斜杠（/）作为路径分隔符，而Windows系统早期使用反斜杠（\\），但现在主流的操作系统如Windows和macOS都允许使用空格，并且能有任意多个空格。",
        "time": "01:09:29"
      },
      {
        "question": "编程中的标识符是否可以包含空格？",
        "answer": "在编程中，标识符不能包含空格，因为它们不支持空格作为分隔符，通常采用 camel case 或 snake case 等命名规则来代替空格，以保持语义清晰和便于阅读。",
        "time": "01:11:53"
      },
      {
        "question": "编程语言中关于首字母大写和小写的规范是怎样的？",
        "answer": "在一些编程语言中，如Go语言，首字母大写会影响标识符的可见性。而Camel Case（驼峰式）和Pascal Case（帕斯卡式）是两种常见的大写字母使用规范，其中Camel Case首字母小写，后续每个单词首字母大写；Pascal Case则是所有大写字母。",
        "time": "01:13:39"
      },
      {
        "question": "对于缩略词和特定词汇在编程中的大小写处理应遵循何种规则？",
        "answer": "缩略词和特定词汇在编程中的大小写处理并没有固定规则，往往根据API设计者的习惯和编程语言规范来决定。例如，XML和HTTP的写法就有不同。实践中，开发者可能会根据上下文、语义以及个人或公司内部的约定来处理这类特殊情况。",
        "time": "01:16:16"
      },
      {
        "question": "在编程中，使用下划线命名的风格叫什么？",
        "answer": "这种命名风格叫做snake case，形象地说就像蛇在跌倒后爬行的样子。",
        "time": "01:19:32"
      },
      {
        "question": "肉夹馍的英文名字中，“K”代表什么？",
        "answer": "“K”是\"Keep Doing\"的首字母，\"B\"是\"Keep Up\"的首字母，整体上代表土耳其烤肉的意思。",
        "time": "01:24:31"
      },
      {
        "question": "Key back case在哪些地方常见？",
        "answer": "Key back case最常见的应用是在CSS中。",
        "time": "01:21:47"
      },
      {
        "question": "为何在CSS中使用连字符（-）可能导致问题？",
        "answer": "因为连字符在某些语言中可能被误解为数学运算中的减号，因此在不支持这种用法的语言中会出现问题。同时，连字符在CSS中不能被压缩，这与一些场景下的语义敏感空格不同。",
        "time": "01:22:08"
      },
      {
        "question": "计算机是否能像人类一样根据上下文理解符号含义？",
        "answer": "计算机无法像人类那样自然地根据上下文判断符号含义，而人类则能够根据上下文来识别符号的意义。",
        "time": "01:22:46"
      },
      {
        "question": "为什么在打字机时代没有专门的乘除符号，而是用X和斜线表示？",
        "answer": "这是由于早期打字机设计时路径依赖的问题，以及机械结构的限制导致的。当时键盘上很多符号可以共享同一个键位，所以没有专门设定用于乘除的符号。",
        "time": "01:24:16"
      },
      {
        "question": "在网站和邮件系统中，为何用户名和邮箱不能包含空格？",
        "answer": "用户名和邮箱在这些系统中不能包含空格是因为系统需要确定其作为一个完整词的边界，而空格的存在使得识别变得困难。不过，下划线通常可以被接受作为替代。",
        "time": "01:25:42"
      },
      {
        "question": "微博中的井号标签（#）有什么特殊用法？",
        "answer": "微博中的井号标签被视为引号使用，即两个连续的井号会被当作一个整体（类似双引号的功能），以解决中文不分词导致的标签识别问题。",
        "time": "01:27:49"
      },
      {
        "question": "在编程语言如Object C中，为何函数名和API命名规则如此冗长？",
        "answer": "Object C等语言要求将函数名和API完整写全，目的是为了让程序员直接从名字就能清晰了解函数功能，同时这种做法有助于在没有自动补全的情况下提高编程效率。这种命名规则源于Small Talk语言，并被Swift等现代语言继承和发展。",
        "time": "01:30:43"
      },
      {
        "question": "在60年代编程时，为何人们希望减少输入字符的数量？",
        "answer": "因为当时的人们写程序时，希望尽可能输入更少的字符，尤其是对于那些常用的底层功能，频繁调用可能导致函数名过长，浪费存储空间。",
        "time": "01:32:32"
      },
      {
        "question": "Java等语言对于函数命名有何特点？",
        "answer": "Java等面向对象语言中，函数命名虽然不像C语言那样严格要求，但仍需清晰表达参数信息，且某些情况下需明确写出参数名。",
        "time": "01:34:10"
      },
      {
        "question": "C语言中是否存在函数名过长的问题？现代编程语言中，函数名长度问题是否依然存在？",
        "answer": "在C语言时代，由于没有像面向对象语言那样的内省机制和字符串操作的便利性，函数名过长确实会占用更多字节。在一些语言如PHP中，函数名长度是有意设计得故意有长有短，例如使用函数名长度作为哈希值的一部分。",
        "time": "01:37:19"
      },
      {
        "question": "是否应该为了提高可读性而允许函数名过长？",
        "answer": "虽然提高可读性很重要，但也不能过分追求字面意义上的“清晰”，尤其是在非英语母语的程序员群体中，他们可能难以理解过长且英文逻辑复杂的函数名。",
        "time": "01:38:43"
      },
      {
        "question": "底层系统与API命名应遵循哪种语言规范？",
        "answer": "底层系统和API通常以英文为主要命名基础，因为这是底层逻辑和操作系统的核心语言。尽管可以有中文或其他语言的界面和交互，但构建底层框架和组件时仍需遵循主流英文命名规范。",
        "time": "01:39:54"
      },
      {
        "question": "在编程中，为什么英文输入法只装中文输入法，然后用中文标点符号会导致程序无法正常运行？",
        "answer": "这是因为程序代码中很多地方借用了英语世界里的标点符号来表达特殊意义。中文的书名号等符号并不被认为是特殊符号，但在程序编程中，英文标点符号具有特定功能，如果使用中文标点符号，可能导致程序解析和运行出错。",
        "time": "01:46:26"
      },
      {
        "question": "为什么日元符号会出现在反斜杠的位置上？",
        "answer": "当初设计Windows系统时，为了满足日本用户对日元符号的需求，在特定位置放入了日元符号。但在后来Windows将反斜杠作为路径分隔符时，导致日本系统中大量出现日元符号。",
        "time": "01:47:31"
      },
      {
        "question": "在Mac系统中，为什么不让使用冒号作为文件名，而在命令行里却可以使用？",
        "answer": "在Mac图形界面中，冒号是禁止用作文件名的，因为它在图形界面路径中作为分隔符使用。但在命令行环境下，冒号可以使用，这是因为不同环境下对文件名的处理方式有所不同。",
        "time": "01:49:22"
      },
      {
        "question": "Windows系统中为什么不能使用一些特定的文件名，如“COM1”、“PRN”等？",
        "answer": "这些文件名是Windows系统中的保留字，具有特殊含义，比如“COM1”通常代表串口1，因此系统禁止用户创建这样的文件名以避免冲突和混淆。",
        "time": "01:51:29"
      },
      {
        "question": "Unix系统上文件名的存在形式是怎样的？",
        "answer": "在Unix系统中，文件名是存在i节点上的，即文件系统内部存储的字符形式，但显示给用户时，可能会根据不同的环境（如Mac或Windows）呈现为不同的字符形式，如斜杠或冒号。",
        "time": "01:54:24"
      },
      {
        "question": "当把Mac上的包含Windows非法字符的文件拷贝到Windows上时，会出现什么情况？",
        "answer": "Windows系统会自动帮助转换这些非法字符，确保文件能在Windows环境下正常显示和使用。例如，如果将Mac上的一个包含非法字符的文件复制到U盘中，再插入Windows电脑中，资源管理器可能无法直接打开该文件，但文件实际上仍存在于U盘上，并且会被正确识别为隐藏文件。",
        "time": "01:55:32"
      },
      {
        "question": "在大多数编程语言中，识别符是否对大小写敏感？",
        "answer": "在绝大多数语言里，识别符（变量名）通常是大小写敏感的，即大A和小b会被视为两个不同的变量。",
        "time": "02:00:21"
      },
      {
        "question": "Visual Basic是否区分大小写？",
        "answer": "Visual Basic是大小写不敏感的，但同时它会保留大小写的特性，类似于某些文件系统的命名规则。",
        "time": "02:03:39"
      },
      {
        "question": ".NET框架中的命名规则是什么样的？macOS上文件系统的命名规则是什么？",
        "answer": ".NET运行时的命名规则与Visual Basic类似，即不区分大小写，但底层的IL和macOS上的文件系统可能区分大小写。在macOS上，同一个文件系统中存在大小写不敏感但大小写保留的默认设置，但不同设备（如iPhone与Mac）可能有不同的大小写处理方式。",
        "time": "02:02:02"
      },
      {
        "question": "是否可以用Unicode编码的emoji来命名文件或变量？",
        "answer": "目前是可以使用Unicode编码的emoji来命名文件或变量的，但这会导致一些复杂性，例如在搜索和比较文件名时需要进行额外的处理。",
        "time": "02:06:38"
      },
      {
        "question": "Twitter的用户名是否区分大小写？Windows系统中文件名是否区分大小写？",
        "answer": "Twitter的用户名是大小写保留但不敏感的，用户可以在任意大小写的组合中输入，最终都会指向同一个页面。Windows系统中文件名是大小写不敏感的，但实际文件系统层面上仍然是区分大小写的。",
        "time": "02:03:39"
      },
      {
        "question": "对于文件名长度、特殊字符及大小写的处理，是否有更简洁安全的方案？",
        "answer": "当前系统在处理这些问题时已采取了一定的复杂措施以保证安全性和兼容性，但理论上如果能简化并标准化处理流程会更为理想。然而，由于用户需求的多样性和技术限制，实现起来具有一定挑战性。",
        "time": "02:06:38"
      }
    ],
    "chapters": [
      {
        "time": "00:00:00",
        "title": "自弹自唱与内核恐慌播客合作记",
        "summary": "本期节目中，自弹自唱和内核恐慌团队分享了他们合作的历程和经验。在过去的一年里，自弹自唱从第99期更新到了第126期，而内核恐慌也从第55期更新到了第58期，尽管更新频率不一，但两个团队都在努力进步。他们还谈到了节目的变化，包括图标、域名和官网字体的更新，以及对未来节目的展望。"
      },
      {
        "time": "00:03:09",
        "title": "探讨点阵字体与矢量字体在网页设计中的应用",
        "summary": "讨论了点阵字体在网页设计中的局限性，特别是它们不适用于网页字体（web fonts）格式的内嵌。提出使用矢量字体来模拟点阵字体的风格作为解决方案，讨论了这种做法的可行性和优势，包括文件大小的可接受性以及适应不同显示大小的灵活性。"
      },
      {
        "time": "00:07:41",
        "title": "探讨显卡性能与屏幕显示效果的关系",
        "summary": "讨论集中在如何在当前显卡技术限制下，处理屏幕的整数倍缩放问题，特别是在4K屏幕上显示1080P内容时的清晰度和锐利度问题。分析了使用非整数倍缩放时，显卡通过插值(interpolate)方法来提升显示效果，以及网页设计中遇到的CSS宽度设定问题，如何影响点阵字体的显示效果。特别提到了伪点阵技术的优势和遇到的挑战，包括次像素平滑导致的边缘模糊问题，以及在不同设备上字体显示的一致性问题。"
      },
      {
        "time": "00:12:10",
        "title": "探讨点阵字体缩放与高分辨率屏幕适应技巧",
        "summary": "在讨论中，提出了在使用特定点阵字体（如丁卯体，只有七像素和九像素两种尺寸）时，如何在高分辨率屏幕上保持字体清晰和锐利的问题。通过实例说明了在CSS中设置字体尺寸的技巧，强调即使在放大字体尺寸（如设置为15像素）时，也要考虑到屏幕分辨率和像素密度（如Retina屏幕），以确保文字的清晰显示。同时，讨论也触及了物理像素与逻辑像素的关系，以及现代设备（如新基和iOS设备）普遍采用的高分辨率屏幕对字体显示的影响。"
      },
      {
        "time": "00:14:34",
        "title": "Macbook分辨率和显示模式讨论",
        "summary": "讨论主要围绕Macbook的分辨率设置及其显示模式。13寸Macbook的屏幕分辨率为2560乘以1600，但默认不采用点对点清晰显示，而是采用缩放模式，逻辑分辨率为1440乘以900，以适应更广泛的显示需求。虽然缩放模式能让屏幕显示更多内容，但可能会导致视力更快下降。对于追求点对点显示的用户，需要手动调整设置，但这会减少实际可显示的面积。"
      },
      {
        "time": "00:16:49",
        "title": "探讨设备显示设置对设计作品影响",
        "summary": "对话集中在如何设备的显示设置，特别是字体大小和空间的选项，对设计作品的最终呈现效果产生影响。指出系统设计限制了用户只能在较小的字体和更大的空间之间做出选择，这可能会影响设计的清晰度和用户最终的观感。进一步讨论了即使设计师交付的作品清晰，用户看到的效果也可能因设备的显示设置而有所折扣。特别提到了iOS设备的显示限制和普通用户对此可能的无知，以及这背后涉及到的技术妥协，包括显卡处理能力、面板连接带宽及工艺限制。"
      },
      {
        "time": "00:18:00",
        "title": "应对高分辨率屏幕和文本识别挑战",
        "summary": "在使用27寸5K屏的iMac时，显卡处理压力显著，特别是在刷新屏幕和渲染高清图片时。一位团队成员通过实践发现，即便是在处理高分辨率的图像文件时，如11个PNG文件，显卡也要承受巨大压力。此外，讨论了在低保真点阵图像上的工作，包括挑战和优化低保真图标的过程，以及如何在不牺牲识别度的前提下，为网站引入独特的视觉风格。还提到了关于文本易读性的测试，特别是在低保真条件下，通过上下文提示能够提高识别率。此外，还涉及到了针对特定语种符号的处理，如日文符号的适应性工作，以及对阿拉伯文和希伯来文的支持考量，最终决定基于项目需求去除不必要的复杂性。"
      },
      {
        "time": "00:22:15",
        "title": "解决中老年程序员节目中的字体问题",
        "summary": "在为面向中老年程序员的节目中，遇到字体排版问题。初期使用六七像素的字体存在一些问题，随后定制了等宽的点阵字，但这些字体与中文不完全匹配。在处理英文口号的排版时，发现斜体字有需求，因此定制了一套斜体字的丁卯点阵英文字符。初期尝试使用程序生成的字体，但最终还是需要人工调整来满足节目需求，特别是对于英文斜体字的处理。这一过程中，注意到中英文斜体字的使用差异，明确了英文口号使用斜体的需求，而对于中文，则采用其他字体形式。经过调整和优化，最终满足了节目的特殊排版需求。"
      },
      {
        "time": "00:24:58",
        "title": "探讨网页字体可读性与浏览器渲染差异",
        "summary": "对话集中在讨论网页中斜体字体的可读性问题，特别是伪斜体与真斜体的差异，以及在不同浏览器和操作系统上字体渲染的不一致性。参与者分享了对于字体显示效果的看法，包括在特定条件下，字体边缘可能出现的模糊或灰边问题，以及如何通过调整CSS设置来尝试缓解这些问题。同时，讨论还涉及了网页设计在Mac和Windows系统上的表现差异，强调了浏览器渲染字体时存在的技术挑战，以及如何应对这些挑战以提升用户体验。"
      },
      {
        "time": "00:27:55",
        "title": "复原Windows XP和DOS的像素风格",
        "summary": "两周前，发布者在浏览新闻时发现有人尝试使用CSS复原Windows XP时代的界面设计，包括640x480像素的显示屏和当时的常用字体如banana、George、Times New Roman等，目的是重现那个时代的像素感。虽然Web技术不支持帧像素字体，但通过类似的手法实现了伪像素的效果，保持了文字的可选性。此外，他们也探讨了是否能够复原DOS环境的中文界面，但存在技术难题。类似地，有团队在网络上成功运行古老操作系统的拟真效果，采用的是PC时代IBM PC机内嵌的字体。在技术实现上，提出使用HTML5的Canvas API直接绘制文字点阵，但这也带来了文字不可选的问题。最后，讨论了在不同分辨率下，如何通过调整布局来尽可能地实现像素对齐，以适应不同的显示设备。整个讨论体现了对复古界面设计的探索和尝试，以及技术上面临的挑战。"
      },
      {
        "time": "00:32:09",
        "title": "怀旧风潮与设计复古的流行趋势",
        "summary": "对话内容涉及了多个主题，包括Rachel风格的流行、蒸汽波Y的兴起、90年代日本流行音乐与动画的结合、百代在YouTube上发布旧动画、魔神英雄传的回忆与更新、以及大白兔奶糖的复古设计等。讨论覆盖了复古风在音乐、动画、设计等领域的复兴，以及人们对于怀旧元素的热爱和对旧时美好回忆的追忆。"
      },
      {
        "time": "00:39:06",
        "title": "文件系统的命名规则及其历史演变",
        "summary": "讨论重点在于文件系统命名规则的历史和变化，特别是Windows系统中的8.3命名规则及其对现代操作系统的影响。讨论中还提到了不同操作系统如Mac和Unix在处理文件命名和识别文件类型方面的差异，以及这些差异如何影响用户和开发者。此外，还涉及了扩展名的重要性及其在不同系统中的实现方式，以及一些特殊文件格式的处理方法。"
      },
      {
        "time": "00:45:43",
        "title": "操作系统中文件命名和类型识别的演变",
        "summary": "讨论重点在于操作系统中文件命名的长度限制及扩展名的使用，以及它们如何随时间演变。最初，DOS系统限制文件名长度为8个字符，后来Windows放宽限制至255个字符，并引入了扩展名来标识文件类型。Unix系统对文件名长度没有明确限制，且不强制使用扩展名，而是通过其他方式标识文件类型。讨论也涉及了Mac操作系统使用资源叉（resource fork）来存储文件的元数据，这种方法虽灵活但与其它系统兼容性较差。此外，还提到了在不同操作系统间传输文件时可能遇到的兼容性问题，以及操作系统特定的文件（如.DS_Store）对其他系统用户的影响。"
      },
      {
        "time": "00:51:35",
        "title": "回忆旧时代软件：WPS与CCED",
        "summary": "对话者回忆使用Windows 95之前的软件，包括在DOS环境下使用WPS进行排版，以及未使用的另一款CLI界面下的排版工具CCED。CCED是1988年由北京乾为天电子技术研究所开发的文字处理与电子表格软件，在DOS时代非常流行，后来也有基于Windows的版本。对话中还提及了使用针式打印机打印文档的经历，并感叹时代变迁，现在主流使用的是Windows 10或更高版本。"
      },
      {
        "time": "00:53:53",
        "title": "文件扩展名的历史和现状讨论",
        "summary": "对话中讨论了文件扩展名的历史，指出它是在字符界面向图形界面过渡时期的产物，原本用于帮助用户识别文件类型。随着时间的推移，图形用户界面的普及使得文件图标和文件类型列的出现，减少了对扩展名的依赖。尽管如此，出于兼容性和网络信息交换的需要，扩展名仍然被保留下来，尤其是在Windows系统中，默认隐藏扩展名的做法被提及。相比之下，Mac系统通过图标来表示文件类型和版本信息，体现了对扩展名不同处理方式。整体上，讨论反映了技术发展对文件扩展名使用的影响以及不同操作系统间对此的不同态度。"
      },
      {
        "time": "00:57:38",
        "title": "文件扩展名的重要性和处理技巧",
        "summary": "讨论集中在文件扩展名在不同操作系统中的显示和处理方式，及其对用户和开发者的影响。在默认情况下，许多系统为了防止用户误改文件类型而隐藏文件扩展名，这可能导致用户在需要更改文件类型时遇到困难。对话中提到，展示文件扩展名对于经常在字符界面和图形界面之间切换的用户来说尤为重要，因为它能帮助明确文件的类型。同时，讨论还涉及到在文件交换时，明确的扩展名对于识别文件类型的重要性，以及不同系统（如从DOS、Windows到Mac）对文件扩展名的不同处理方式给用户带来的困扰。这反映出软件设计需要在用户便利性和系统兼容性之间找到平衡点。"
      },
      {
        "time": "01:01:37",
        "title": "文件名中使用空格的利弊讨论",
        "summary": "对话集中在讨论文件名中是否允许包含空格的问题，特别是从操作系统的历史背景出发，分析了使用空格带来的便利和困扰。早期的DOS系统不允许文件名中包含空格，而现代系统如MacOS则大量使用空格。讨论强调了空格在命令行界面处理时的复杂性，需要使用引号来明确文件名，增加了操作的麻烦。进一步探讨了使用空格可能导致的兼容性和显示问题，提出了用下划线或连字符替代空格的建议。"
      },
      {
        "time": "01:06:28",
        "title": "Windows文件命名及编程标识符的讨论",
        "summary": "讨论集中在Windows操作系统对文件名中空格的处理方式以及编程语言中标识符的命名惯例。Windows允许文件名中有空格，但处理起来较为麻烦，特别是路径中的空格需要额外的转义字符。此外，讨论了Unix系统对于空格的处理方式以及Windows和Unix在路径分隔符（斜杠和反斜杠）上的差异。还探讨了编程语言中标识符的命名约定，如camel case、snake case和Pascal case，以及它们在不同场景下的应用。"
      },
      {
        "time": "01:14:07",
        "title": "探讨编程中命名规则的复杂性",
        "summary": "对话中深入讨论了编程命名规则的复杂性，特别是缩略词全大写和大小写使用的问题，如IP地址的写法和缩略词的使用规范。指出大小写在不同情况下可能引起混淆，同时强调了命名规则在编程中的重要性，以及开发者需要考虑到的多种因素，包括语言特性、可读性及语义清晰度。此外，也讨论了使用下划线（snake case）作为区分词与词的方法，以及其在不同编程环境下的实用性。"
      },
      {
        "time": "01:21:47",
        "title": "探讨CSS中的空格问题及符号历史",
        "summary": "讨论集中在CSS不执行计算导致的复杂性，特别是关于如何处理减号（横线）及其周围空格的规则。进一步探讨了历史上符号（如减号、乘号）的使用和设计问题，指出符号的语义和表示在计算机处理时的差异，以及这些差异对现代编程和设计的影响。此外，还提到了阿拉伯数字的起源和使用，以及键盘设计中的符号选择问题，强调了路径依赖在技术发展中的作用。"
      },
      {
        "time": "01:25:18",
        "title": "互联网标识符命名规则及挑战",
        "summary": "讨论集中在互联网和编程领域中命名规则的复杂性，特别是对于不支持空格的环境，如URL、用户名、电子邮件地址等。探讨了如何处理这些环境中的命名问题，例如使用下划线、连字符或特殊符号替代空格，以及这些做法在不同系统中的适用性。同时，还讨论了编程语言中标识符命名的挑战，包括API命名的长度和复杂性，以及如何通过自动配对和嵌套支持来简化这一过程。此外，还提到了特定情境下的命名实践，如Twitter的hashtag使用和中文环境下的分词问题。"
      },
      {
        "time": "01:30:00",
        "title": "从Objective-C到Swift：编程语言的演进与命名规范",
        "summary": "随着iOS开发从Objective-C转向Swift，讨论集中在了编程语言的命名规则变化上。Objective-C因其冗长的方法签名而被讨论，这些签名遵循了Smalltalk的传统，有着对参数内外名称区分的机制，尽管在无IDE支持下编写变得困难。Swift虽然继承了某些命名规则，但相比Objective-C，在代码自明性与长度之间找到了更好的平衡。讨论还提到了其他语言如Java和PHP的命名习惯，以及如何随着时间的推移，编程语言的命名习惯如何因应需求和技术进步而演变。"
      },
      {
        "time": "01:35:30",
        "title": "编程语言中的命名哲学和文化影响",
        "summary": "讨论集中在编程语言中API命名的复杂性，特别是对比了Java、.NET和Cocoa的命名风格。讨论者指出，Cocoa的命名方式虽然啰嗦，但因其不使用缩写且具有明确的语义，使得代码易于理解。进一步，讨论扩展到语言命名对非英语母语程序员的影响，以及如何在技术文档和代码注释中保持语义的清晰度。特别地，讨论触及了文化差异对于编程语言设计的影响，以及如何在国际化团队中保持代码的可读性和可维护性。最后，讨论转向了对未来可能的中文编程语言的设想，以及技术社区对命名约定的普遍看法。"
      },
      {
        "time": "01:42:53",
        "title": "探讨网络缩写语和特殊字符在文件命名中的应用",
        "summary": "网络上流行的一些00后使用的缩写语，如NMSL，是将英语单词和汉语拼音缩写混合使用，这些缩写在不同文化和语境中有不同的解读。讨论还涉及了在Windows和macOS系统中，某些特殊字符如空格、大于号、小于号等在文件命名时的限制和建议。特别指出，尽管文件系统可能允许使用这些特殊字符，但从实用主义角度出发，避免使用标点符号和空格以减少潜在问题是一个更好的做法。"
      },
      {
        "time": "01:46:37",
        "title": "编程初学者常遇的字符编码疑惑及历史背景",
        "summary": "讨论集中在编程初学者常见的字符编码问题，特别是中文标点和英文标点在编程中的区别，以及如何解决这些问题。此外，还探讨了日元符号替代反斜杠的历史原因，以及Mac系统中冒号和斜杠的使用差异，反映了字符编码在不同文化和系统中的应用与挑战。"
      },
      {
        "time": "01:51:29",
        "title": "Windows文件命名规则及系统兼容性探讨",
        "summary": "讨论集中在Windows操作系统中文件命名的限制，特别是不能使用特殊字符和一些系统保留字作为文件名，如COM、PRN等。此外，也讨论了Windows与Mac系统之间文件命名的兼容性问题，以及当尝试在不同系统间移动含有特定字符的文件时可能遇到的问题。对话中还提到了一些技术解决方案和对系统设计选择的批评，指出有时候系统限制可能是出于对遗留系统兼容性的考虑。"
      },
      {
        "time": "01:56:42",
        "title": "隐藏文件和大小写在Unix及现代文件系统中的应用",
        "summary": "在Unix系统中，以点开头的文件被视为隐藏文件，这种做法被继承到了类似系统中，如麦克斯麦克斯（指代可能为Mac OS）。早期Unix并未有隐藏文件的概念，但通过简单的hack，将文件名以点开头就可以避免在目录列表中显示，这是一种为省事而采取的做法。此外，还提到了COM和LPT，暗示着这些与打印机等硬件接口相关。最后，转而讨论了文件系统中大小写的问题，暗示了在不考古的前提下，关注现代文件系统的相关议题。"
      },
      {
        "time": "01:58:09",
        "title": "操作系统中大小写敏感与保留的区别及应用",
        "summary": "对话详细解释了操作系统中大小写敏感和大小写保留的概念，以及它们在实际应用中的差异。讨论了这些概念如何影响文件系统的管理和用户交互，特别是在Mac操作系统和编程语言（如Visual Basic）中的具体应用。此外，还提到了大小写敏感性在不同平台（如iOS）和文件系统（如APFS）中的设置差异，及其对软件安装和用户可见性的影响。"
      },
      {
        "time": "02:03:35",
        "title": "Windows文件系统大小写处理及文件名编码讨论",
        "summary": "讨论集中在Windows文件系统对于大小写的处理方式，确认Windows是大小写不敏感但保留大小写。进一步分析了这种做法在实践中的潜在问题，比如在判断文件是否存在时需要进行额外的文件名统一化步骤，导致效率低下。同时，提出大小写敏感可能是一个更优方案。最后，讨论转向文件名是否可以使用Unicode编码书写的问题。"
      },
      {
        "time": "02:04:43",
        "title": "探讨编程语言中Unicode的兼容性和表情符号的使用",
        "summary": "讨论集中在现代编程语言对于Unicode的兼容性以及如何在代码中使用表情符号。指出使用独特表情符号作为变量命名可能导致的问题，如自动完成功能的挑战，以及表情符号在听觉媒介中表达的困难。同时，提出了对于表情符号在编程中使用的未来展望，比如制定专门的发音指南，以解决表情符号在不同语境下的理解和应用问题。"
      },
      {
        "time": "02:07:35",
        "title": "Unicode复杂性与信息安全的关联",
        "summary": "讨论重点在于Unicode的复杂性如何影响信息安全。早期iPhone遇到的问题展示了当系统接收到包含特定Unicode字符的短信时可能会崩溃。这突出了Unicode在软件质量、安全性和复杂度之间的关系。进一步探讨了Unicode的广泛应用和标准化对于信息安全的重要考虑，以及对于编码系统复杂度的看法和对用户需求的妥协。最终，对话触及了对Unicode版本更新的感慨，以及信息安全意识的重要性，强调了即使在技术不断进步的背景下，保持对安全的关注仍然是关键。"
      }
    ],
    "mindmap": {
      "children": [
        {
          "children": [
            {
              "children": [
                {
                  "children": [],
                  "content": "不同操作系统对文件命名有不同的限制"
                },
                {
                  "children": [],
                  "content": "应避免使用特殊字符以减少问题"
                },
                {
                  "children": [],
                  "content": "尽量不使用空格，推荐使用下划线或连字符"
                }
              ],
              "content": "限制与标准"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "children": [],
                      "content": "在早期系统中，空格被视为特殊字符，限制其使用"
                    },
                    {
                      "children": [],
                      "content": "现代系统中空格的使用较为普遍，但可能导致路径处理问题"
                    }
                  ],
                  "content": "空格"
                },
                {
                  "children": [
                    {
                      "children": [],
                      "content": "不同系统对反斜杠和斜杠的处理方式不同，可能导致兼容性问题"
                    }
                  ],
                  "content": "反斜杠与斜杠"
                },
                {
                  "children": [
                    {
                      "children": [],
                      "content": "在Mac系统中，图形界面与命令行中冒号的显示不同，可能引起混淆"
                    }
                  ],
                  "content": "冒号"
                }
              ],
              "content": "特殊字符"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "children": [],
                      "content": "默认隐藏文件扩展名"
                    },
                    {
                      "children": [],
                      "content": "特殊保留字（如COM1，PRN等）不能作为文件名"
                    }
                  ],
                  "content": "Windows"
                },
                {
                  "children": [
                    {
                      "children": [],
                      "content": "不显示文件扩展名"
                    },
                    {
                      "children": [],
                      "content": "文件名中避免使用冒号"
                    }
                  ],
                  "content": "MacOS"
                },
                {
                  "children": [
                    {
                      "children": [],
                      "content": "文件名可包含大多数特殊字符，但应避免空格以减少路径处理问题"
                    }
                  ],
                  "content": "Linux/Unix"
                }
              ],
              "content": "系统差异"
            }
          ],
          "content": "文件命名规则"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [],
                  "content": "空格可能导致路径处理问题，建议使用下划线或连字符代替"
                }
              ],
              "content": "空格使用"
            },
            {
              "children": [
                {
                  "children": [],
                  "content": "扩展名的使用和隐藏方式在不同系统中有所不同，导致兼容性问题"
                }
              ],
              "content": "扩展名"
            },
            {
              "children": [
                {
                  "children": [],
                  "content": "空格、反斜杠、斜杠、冒号等特殊字符在不同系统中处理方式不同，应谨慎使用"
                }
              ],
              "content": "特殊字符处理"
            },
            {
              "children": [
                {
                  "children": [],
                  "content": "在不同系统间移动文件时需注意文件命名的兼容性问题"
                }
              ],
              "content": "系统兼容性"
            },
            {
              "children": [
                {
                  "children": [],
                  "content": "避免使用可能引起问题的特殊字符"
                },
                {
                  "children": [],
                  "content": "考虑不同系统的处理差异"
                },
                {
                  "children": [],
                  "content": "确保文件名在各种系统中的兼容性和可读性"
                }
              ],
              "content": "建议"
            }
          ],
          "content": "命名挑战与解决策略"
        }
      ],
      "content": "文件命名规则与特殊字符处理"
    }
  }
}