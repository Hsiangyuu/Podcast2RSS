{
  "pid": "5e284e0c418a84a0462693e4",
  "eid": "5e84c3ac418a84a0462df973",
  "title": "21. Debugging",
  "task_id": "3kprqlg8l6yg9xgd",
  "transcription": [
    {
      "time": "00:00:00",
      "text": "欢迎收听IPM podcast网络旗下的IT技术主题节目，技术主题娱乐节目内核恐慌我们号称扣，但是没有干货，想听人听，不想听你就别听。内核恐慌的网址是IPN dot IOS flash kernel panic。我们推荐大家使用podcast客户端订阅我们的节目。如果您不知道该用哪一个客户端，欢迎访问IPN dot IOS flash FAQ。",
      "speaker": "发言人1"
    },
    {
      "time": "00:00:23",
      "text": "同样欢迎您为我们的节目捐款，捐款地址是IPN dot LI slash current panic slash donate。捐款金额随意，只要是能够被八整除的正整数就可以。捐款不会为你带来什么，不捐也不会让你失去什么。我们的口号是no hot feelings。好了，今天是第二十一期节目。你嗓子怎么样？",
      "speaker": "发言人1"
    },
    {
      "time": "00:00:49",
      "text": "还凑合，现在你怎么样？这段不是故意加的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:00:58",
      "text": "这段千万要抹掉。我在女朋友的悉心照料之下，现在已经好了九成，但是剩下的一成总是在总是一直困扰着我。就是说一句话还是会咳嗽一下，然后就会产生那种。第一句话前面说的比较平缓，后面越说越急，说完之后开始咳了。",
      "speaker": "发言人1"
    },
    {
      "time": "00:01:17",
      "text": "有气儿是吧？对我我发现有这个状况是上次感冒了，好像一直叫这个叫什么来着？支气管炎对吧？",
      "speaker": "发言人2"
    },
    {
      "time": "00:01:24",
      "text": "对，其实就是咽炎转化成支气管炎。",
      "speaker": "发言人1"
    },
    {
      "time": "00:01:28",
      "text": "这怎么算？同病相怜，还是说什么隔空传染。",
      "speaker": "发言人2"
    },
    {
      "time": "00:01:36",
      "text": "对，这个病毒现在已经可以电子化了，然后数据digitalized，然后传到你这边。",
      "speaker": "发言人1"
    },
    {
      "time": "00:01:42",
      "text": "For real virus spread across cyber net. 然后生物能。",
      "speaker": "发言人2"
    },
    {
      "time": "00:01:50",
      "text": "不能真的有一天以数字化的形式存在？",
      "speaker": "发言人1"
    },
    {
      "time": "00:01:54",
      "text": "理论上可以，就是那边探测一下DNA，然后这边合成一下不就出来了吗？Make a movement对吧？搞个3D打印机直接打印病毒出来。",
      "speaker": "发言人2"
    },
    {
      "time": "00:02:04",
      "text": "你说的是传输生命，我的我我我想的是能不能就让生命就这么生活的生存在网络上，就不用再转化为一个实体应用。",
      "speaker": "发言人1"
    },
    {
      "time": "00:02:16",
      "text": "那天我们还在IT功能里面聊这个事情，就要要实现这一点，我们先要解决一些哲学上的问题，什么叫生存是不是，什么叫意识对不对？现在其实这个问题有有答案了吗？我现在还没有看到有一个什么确切的靠谱的点。",
      "speaker": "发言人2"
    },
    {
      "time": "00:02:35",
      "text": "不知道我觉得下次你们可以请脑科学博士赵晨上一次你们的节目，然后OK。好吧，那我们先再加上一些反馈。",
      "speaker": "发言人1"
    },
    {
      "time": "00:02:52",
      "text": "好，我有一个反馈，有一位叫做denmark的朋友在微博上给我们留了个言哈他这个消息这么说的。有个问题想问real在看不到源码的情况下，如何知道one password不是一个密码专业盗窃器呢？以上期测试的语言来说，我们只能把程序当作一个黑箱给一些输入来观察输出。但是我们并不能证明打引号它是可信的，也就是说实质上是我们选择相信one password。想请问real是依据哪些因素认为one passmore可信的呢？然后他的第二个问题是说，是否real只在one passmore存储安全等级较低的密码。那我能问一就是那能问一下安全等级较高的信息，比如财务相关的real会数字化吗？如果会的话，我的方案是什么？",
      "speaker": "发言人2"
    },
    {
      "time": "00:03:49",
      "text": "这里集中解答一下。首先我已经不用玩password，其实我也没怎么用过它，当时就有有有买，还是很久以前了。对，还是它的2.0，还是二点几的版本，我买过，然后用了一下，我觉得还凑合。后来那个那个苹果的kitchen不是出了那个i cloud kitchen，就是可以跟那个i cloud通过同步到你的其他的IIIOS设IOS设备或者是mac上面，然后选择全部都存在你kitchen里面。我的绝大部分信息都是数字化的，然后比较一些比较机密的，什么银行卡账号密码之类的，也是存在那个kitchen里面的。所以刚才那个问题就是说如果没有源码的话，你怎么去选择相信这个one password或者是kitchen的安全性呢？正确答案是你没法确信，因为你没有源代码。",
      "speaker": "发言人2"
    },
    {
      "time": "00:04:45",
      "text": "对吧？也也不不尽然。你可以自己弄一个中年人攻击，你可以把自己的路由器，你可以嗅探自己路由器，然后看他到底在和哪些网站联络。",
      "speaker": "发言人1"
    },
    {
      "time": "00:04:58",
      "text": "通信对吧？对，所以还是当做黑盒来处理，去观察它的输入输出。或者说你做的再彻底一点，你去反编译他的那个那个可行可执行文件，看他有在哪哪些地方调用网络。然后你足够牛逼的话，应该能缓解出来说他在哪些时候传输了，那这个传输之前做了一些什么东西。但是我相信绝大部分理智的正常人是不会去做这件事情。",
      "speaker": "发言人2"
    },
    {
      "time": "00:05:23",
      "text": "如果你足够多疑的话，那就是如果你paranoid达到这个程度的话，那基本上你肯定不会使用任何密码管理软件的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:05:31",
      "text": "比如我当然不是，应该是说如果你你需要这个层级的确信的话，要么你就学那个Richard stallman，就是一样的用的所有软件。我注册就是所有软件，包括像那个硬件的BIOS，什么就把其他的中间都不说了，什么操作系统，应用程序，都必须要去开源的，你才能够去确保每个东西。然后你对硬件的要求也是有高要求。你必须用那种所谓的open hardware，就是不要有那种藏有私有代码的那种硬件，就包括某一个，比如说现在很多用硬盘或者SSD上面不会有很多芯片，对吧？你的那些芯片的要求也是要求他们能能开源的，能知道你他在里面在做什么。你这个时候你才可以就是你在有所有的源码的基础上，你才可以确信的说这个机器没有做，你不想让他做的事情。",
      "speaker": "发言人2"
    },
    {
      "time": "00:06:26",
      "text": "但是我觉得child stand是用happy hiking keyboard的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:06:31",
      "text": "对他接一个那个。",
      "speaker": "发言人2"
    },
    {
      "time": "00:06:32",
      "text": "对，如果是的话，p hacking keyboard的controller是必然的是吗？",
      "speaker": "发言人1"
    },
    {
      "time": "00:06:38",
      "text": "是啊，OK所以这就又又存在一个漏洞了，对吧？你不确定他那个那个键盘里面有那个key log，就是键盘记录器，对吧？对，这又是一个不确定因素。所以其实你看在现在这种情况下，你要求说每个步骤都是被可以被audit，就是可审计的，基本是不现实的对，是非常难的一件事情。对。",
      "speaker": "发言人2"
    },
    {
      "time": "00:06:59",
      "text": "所以这个时候怎么办呢？那你只能选择相信一些人或者是一个人了。这个时候就可以你可以选择是说你相信苹果，还是相信one password呢？当然你选择相信one password，你刚刚跑的就是mac系统的话，你最终还是得选择相信苹果，对吧？所以我的策略就比较简单了，我就相信苹果好了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:07:19",
      "text": "It's leap of face. 相信上帝一样的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:07:23",
      "text": "没错，苹果酱那个一拜一拜。对，这个时候你就只能选择相信，然后为什么我选择相信苹果呢？这个流也很简单，因为什么他已经把这个牛逼吹出去了，对吧？就是我们不不不销售这个用户隐这个隐私信息，我们也不植入后门，我们也不做一些什么对用户有害的事情。",
      "speaker": "发言人2"
    },
    {
      "time": "00:07:44",
      "text": "因为我比较缺锌的点是，如果被人爆出来说，苹果有意在那个kitchen里面或者其他麦克里面做了什么手脚，最后被人发现的话，他对他的这个叫做商誉，就想说我们在这个在会计上是有这么一个概念，叫做商誉，叫goodwill。就是公司的品牌，这些东西的价值。我如果苹果被发现，他故意，比如说因为NSC给他下了给他什么，改成秘密法令，让他就在电脑里面做什么手脚。如果他真这么做了，我相信对他商誉是非常损非常大的损失。那这个损失通常是以多少billion dollars，就是10亿美元为单位来计价的对，所以这个时候我相信在如此大的这个压力下，以及从他们这么多年坚持在道德观念来看，我觉得我相信他们是可以的。但至于说你信不信，请你自己做自己的选择和判断。",
      "speaker": "发言人2"
    },
    {
      "time": "00:08:45",
      "text": "对，比如说我就选择不信，因为这世界上没有什么东西是可信，我不是故意跟你唱反调。但是。",
      "speaker": "发言人1"
    },
    {
      "time": "00:08:54",
      "text": "Rich Richard folk storm你好，我们来玩一游戏。",
      "speaker": "发言人2"
    },
    {
      "time": "00:09:00",
      "text": "对我反正我也顺便说说自己的选择，我我是不用任何密码管理软件。",
      "speaker": "发言人1"
    },
    {
      "time": "00:09:07",
      "text": "所以你的密码是靠一套机制来实现的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:09:10",
      "text": "是吧？对我我有一套比较详尽的密码存储和管理机制，然后你们。",
      "speaker": "发言人1"
    },
    {
      "time": "00:09:16",
      "text": "大脑自带密码生成器。",
      "speaker": "发言人2"
    },
    {
      "time": "00:09:18",
      "text": "对我曾经在知乎上写一个答案，反正简单的来说就是密码要分三层。最基本的密码是一个大概一两年换一次密码。哼然后这个密码可以是在所有这些网站上都一样的。比如说什么，你你去你想要下载一个SQL developer，从oracle网站上下一个SQL developer，你可以他强迫你注册。然后你此时你可以选择去下一个什么bug in notes之类的浏览器插件，它自动帮你填一个已经有人注册过的弱密码。另外一个选择就是你自己维护一个非常弱的密码，然后基本上最低的最低级的这一层密码，我就是用一个一一一直用一个最一样的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:10:07",
      "text": "哼第二层密码是每个网站不一样，而且但是你有一部分是一样的。这个是比如一些比较重要的网站，比如像什么知乎或者是微博之类的这种跟你的identity相关的东西。然后这些密码有一套生成机制，就是我看到他的网址，或者是一般是看到网址的时候，会想到这个密码应该是怎么构建的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:10:37",
      "text": "哼然后第三层密码就是什么网银的密码、信用卡密码，或者是啊什么报税的税务局密码之类的。这个密码是每个网站都不一样，而且跟网站本身没有关系。而且我自己自己有时候必须去看一个reminder才能看出来，才能想起来。",
      "speaker": "发言人1"
    },
    {
      "time": "00:10:57",
      "text": "所以你还是记录了密码在某一个地方，对吧？",
      "speaker": "发言人2"
    },
    {
      "time": "00:11:00",
      "text": "但我只是等于我只记录了这个密码的south.",
      "speaker": "发言人1"
    },
    {
      "time": "00:11:03",
      "text": "你可以理解为hint，应该是。",
      "speaker": "发言人2"
    },
    {
      "time": "00:11:07",
      "text": "salt就是看到这个看到这一串东西，我才能够重新构建出那个密码这么一个。对，所以说是salt.",
      "speaker": "发言人1"
    },
    {
      "time": "00:11:18",
      "text": "是你已经有一个密码，然后你通过加这个salt这个盐变成一个新密码去输入的是吧？你是这么。",
      "speaker": "发言人2"
    },
    {
      "time": "00:11:26",
      "text": "一个过程。OK你说的对是吧？好吧，我因为我在那个纸上写了soft这个词，所以我一直叫做soft。但你说的没错，是只能说是一种。",
      "speaker": "发言人1"
    },
    {
      "time": "00:11:36",
      "text": "个int对，是一个提示，让你想起来密码是什么。",
      "speaker": "发言人2"
    },
    {
      "time": "00:11:40",
      "text": "对，然后最重要的是比如说。",
      "speaker": "发言人1"
    },
    {
      "time": "00:11:42",
      "text": "什么飞流直下三千尺。",
      "speaker": "发言人2"
    },
    {
      "time": "00:11:43",
      "text": "是不是没有那么弱，我或者说我文学素养没有那么高。但最重要的是就是第二层和第三层密码要比第一层密码换的更勤快一些，就是银行密码可能两个月就要换一次OK，这是比较重要的。但是这是一个parana的人的人才会。",
      "speaker": "发言人1"
    },
    {
      "time": "00:12:04",
      "text": "需要做的事情。",
      "speaker": "发言人2"
    },
    {
      "time": "00:12:05",
      "text": "哼另外就是所有能够采用两二部叫什么双方验证的对两步验证的网站一定要使用。",
      "speaker": "发言人1"
    },
    {
      "time": "00:12:15",
      "text": "两边是手机上做的是吧？用什么google Sunny tor还是用什么？",
      "speaker": "发言人2"
    },
    {
      "time": "00:12:21",
      "text": "对我是用google 3 dator，然后battle net有一个对，然后部分德国银行会给你一个卡，这卡上。",
      "speaker": "发言人1"
    },
    {
      "time": "00:12:29",
      "text": "可以按那个是玩耍，这是密码器。对对对，中国有很多，现在银行也有了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:12:36",
      "text": "我觉得那个其实是比较安全的一个选择。",
      "speaker": "发言人1"
    },
    {
      "time": "00:12:40",
      "text": "对对对，我的那个密码管理方法上，我在在同一个支付问题下，我也有打好，我们都有在那里回答，到时候把那个链接贴出来。我的就是比我的比你更机器化，然后更做的更绝，就是所有的策略都是一样的。每个网站都是随机生成的密码，我自己都不知道，必须用密码管理器看。",
      "speaker": "发言人2"
    },
    {
      "time": "00:12:59",
      "text": "但此时就是你你可能会选择在省，你必须在省心和有安全感之间找到一个baLance。我的方法肯定不适合任何人的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:13:14",
      "text": "对我我的也肯定不适合任何人，因为太麻烦了，但是我是不介意麻烦的。然后你刚才说是你有些网站是共享一个密码的吗？对我都是每个都是不同的密码的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:13:31",
      "text": "对，从这个角度讲，仪表你要不安全一些，但没错。",
      "speaker": "发言人1"
    },
    {
      "time": "00:13:35",
      "text": "而且我连每个的邮箱账号都是不一样的，就每个注册账号的邮箱都是不一样。",
      "speaker": "发言人2"
    },
    {
      "time": "00:13:40",
      "text": "我觉得这个是没有最变态的一点。他他能有一个一个自己的耳朵，故APP是吧？对对对，然后他给每一个网站都有一个自己不同的用户名。然后导致有时候我会想要在这个网站上给他分享一个什么东西。",
      "speaker": "发言人1"
    },
    {
      "time": "00:13:55",
      "text": "然后他得先问我是哪个账。",
      "speaker": "发言人2"
    },
    {
      "time": "00:13:58",
      "text": "那晚上又是另外一个。",
      "speaker": "发言人1"
    },
    {
      "time": "00:13:59",
      "text": "然后我就反对。对，因为为什么要这么做？其实除了在一个安全上，还有一个就是一个匿名信的问题。就是很多现在很多那个网站，它是可以通过你使用同一个账号判断出你在那个网站用的另外一个什么服务，对吧？我不希望这样被他们通过交叉比对账号的方法tracking的。因为有很多这个就其实我们可以讲一下之前很多人账号被泄露出去的原因也比较简单，就是很多人都是用同样一个账号。比如说你有某一个固定的邮箱地址，或者是你的手机号码，或者是某个人固定一个ID对吧？",
      "speaker": "发言人2"
    },
    {
      "time": "00:14:35",
      "text": "一个一套固定的密码注册多个账号，就像你说第一层那种这种不怎么安全的东西，然后其中某一个服务被人脱裤了，就是所谓他的那个密码，用户账号的那个那个数据库那张表被人爆出来。这样的话别人拿到这个信息之后，他可以挨个去试。常见的网站上，你就同一个账号，同一个密码，有没有注册其他同类的服务，对吧？就可以依次连带攻陷你的好多这种东西。所以我这个就可以从根源上阻断这一点。第一个，你没有办法把我的那个不同的网站的账号能够串起来。第二个，就算你就就算你发现我的这个账号是在这个人用的这个账号是等于那个人在那个账号上面去。你你你从用同一个密码去试也是不行的，因为每个密码都是不一样的。然后我跟你有一点不一样，就是我不怎么去更换密码，就是我不会说隔三差五就换他一轮，就是比较不频繁，也换，但是不是非常频繁。因为我的理念是这样子的，就是照按照我这种用法和注意事项的结果，如果账密码被泄露，一般是因为对方网站被脱库了，这个时候你换不换密码是没有任何区别的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:15:50",
      "text": "因为我的确是有道理。",
      "speaker": "发言人1"
    },
    {
      "time": "00:15:54",
      "text": "但对然后我已经很麻烦了，我就不想再给自己添更多的麻烦。然后关于两步验证，我也是基本上就是重要的服务。其实提供两步验证的基本上是重要的服务。对，然后就基本上有两步验证的我都开了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:16:11",
      "text": "然后我在那个IOS上装了一个叫做offer的一个应用。之前也用那个google sonnica or，不过发现它不太好使，就是那个界面也比较糟糕。然后OC会稍微好一点点。其实当年最主要的原因是LSOC有一个mac就是OSN的一个应用。它理论上是可以通过蓝牙和你手机上那个OC连接，这样的话你就不用打开手机，就能通过电脑上那个OC的插件，直接把那个那个应该是一个六位数的数字读出来。后来我发现其实不行的，那个那个是要求手机的那个OC是在工作状态才可以的，所以最终你还是得开一个手机上的office，然后再开电脑上那个office去跟他蓝牙共享，这样比较麻烦。所以我来讲还是就直接在手机上，反正六位数也不是特别麻烦，对吧？就是可以输一下还可以。然后后来那个IOS8还是7，不是有了那个叫做notification center，不是我的那个today toy什么today extension，还是叫什么来，就是从顶上对对，today you对，从顶上拉下来，然后offset它加了重点功能，就是它可以直接在里面加个快捷访问，就可以直接拉下来翻到office的那一栏，然后点击某一个账号进去，再输一下这个密码或者验一下指纹，就可以直接取到6位数的验证码了，对吧？就这样的话还是比较方便的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:17:46",
      "text": "然后还有一种方式，就是用一个硬件的USB设备。一个国内叫什么？",
      "speaker": "发言人1"
    },
    {
      "time": "00:17:54",
      "text": "国内大家都很熟，叫做U盾。",
      "speaker": "发言人2"
    },
    {
      "time": "00:17:56",
      "text": "对。",
      "speaker": "发言人1"
    },
    {
      "time": "00:17:57",
      "text": "用那个银行的弄，它其实还有好几种形式，它不光是有UUSB的，就USB的都有好几种。第一种是最传统的那个，我记得当年是工行，我开办了第一个U盾就插上去，它里面是其实就是内置一个私钥了。所以对，不是，它是一个容器，它是这它就是一个内置的私钥。",
      "speaker": "发言人2"
    },
    {
      "time": "00:18:19",
      "text": "没有密码生成器。",
      "speaker": "发言人1"
    },
    {
      "time": "00:18:20",
      "text": "没有密码生成器，它是验证那个系统用的。我如果我理解没错，应该是这样子，它它就是可以签名用的。那个私钥它是一个叫做HSM hardware security module，应该是叫叫。",
      "speaker": "发言人2"
    },
    {
      "time": "00:18:34",
      "text": "他名字我给，因为我们当时有一个同学在研究这个，他说里面是一个他或者他的意思是每次给出来的私钥只是所有可能需要之中一种。",
      "speaker": "发言人1"
    },
    {
      "time": "00:18:47",
      "text": "就是这么高级。对，OKI反正anyway就是逻辑上应该这样子，它里面是一个只有硬件本身才知道的一个秘密，而这个秘密是不能通过UUSB接口读取的。它只能说你提供一个东西，可以他帮你验证，帮你做一个签名，这个签名再返回到你电脑里面，然后再传输给对方网站。然后那个应该是对，然后那边可以通过这个签名验证，确实是经过这个私钥的签名过的东西，这么大概这么一个过程。",
      "speaker": "发言人2"
    },
    {
      "time": "00:19:17",
      "text": "对，然后还有一种是USB的，不是USB，就是刚才说那个密码器，就是一个它不需要不不需要通过USB接口来插的。他就是一个叫ISC。美国那家公司他有一个小小的一个挂钥匙串上一个小东西，一个小屏幕，它就是那个RC的硬件版本，它毎隔可能15秒30秒它会换一个数字，然后这个数字它那个顺序，那个sequence就是那串数字的顺序是既定的。然后这个可以通过当前的时间来来判定，就可以。对方服务器上也知道说这个时候是不是这个数字就这个sequence就可以通过，这个就是一个随机数列。",
      "speaker": "发言人2"
    },
    {
      "time": "00:20:01",
      "text": "对，其实我刚才想说的就是另外一种形式，就是要求你一定要插入电脑里面，而不是。",
      "speaker": "发言人1"
    },
    {
      "time": "00:20:06",
      "text": "一个USB的那个对，就是key.",
      "speaker": "发言人2"
    },
    {
      "time": "00:20:09",
      "text": "就是要求你比较插的那种。对。",
      "speaker": "发言人1"
    },
    {
      "time": "00:20:11",
      "text": "但这个有个问题，就是现在不是很多手机了吗？没有USB接口怎么办？后来上次我看他们有一种另外的一些方案，就是那个是可以插USB口，也可以通过一个音频的接口，就是那个耳机线耳机插线，然后插到手机上，然后他那个银行软件做了一个什么特殊的协议。通过播放这个声音就是就猫。大家记得以前那个拨号上面的猫吱吱吱那个声音，对吧？对它其实是通过那个东西来，就通过那个呃语音来编码一串数字信息。它这个就是用了一样的原理，就通过那个那个手机的耳机那个接口去输入输出一段声音。然后那个声音是包含一些特殊的编码过的这个私钥的认证的信息的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:20:59",
      "text": "然后德国还有一种方法，就是它会在屏幕上不停的闪烁一组二进制的纹样。然后你用它的那个密码生成器上背后有一个类似摄像头，或者说应该是不是就是一个感光元件OK。然后你把那个感光键hold在屏幕的上方，然后等一会儿之后，这个你可以识别，会就识别出来，然后生成一个密码给。",
      "speaker": "发言人1"
    },
    {
      "time": "00:21:25",
      "text": "这个好恶心好吧，那这样不是很费电吗？那个密码器。",
      "speaker": "发言人2"
    },
    {
      "time": "00:21:29",
      "text": "密码器就像我说的，它只是一个感光元件而已，它要就是密码需要。",
      "speaker": "发言人1"
    },
    {
      "time": "00:21:34",
      "text": "有有供电才可以识别。对，密码器是装电池的对。",
      "speaker": "发言人2"
    },
    {
      "time": "00:21:38",
      "text": "这样电池不就废的很。我前四年前申请的一个scanner现在还能用，而且这个scanner要求你当时要把银行卡插进去。",
      "speaker": "发言人1"
    },
    {
      "time": "00:21:51",
      "text": "对，好吧？那个RSC那个那个密码器也是就是一个小电池，可以用好几年了这样。但是过了几年它就会它有一个有效期。Spire就是过了就跟那个什么SSL证书一样，有个有效期，过有效期就作废了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:22:06",
      "text": "瑞士银行发的那个密码生成器，也是就是一张信用卡，然后信用卡里面有一个肯定有一块电池，因为它上面可以显示一个数字，然后我估计那个电池可以一直用到这个卡作废为止。所以。",
      "speaker": "发言人1"
    },
    {
      "time": "00:22:18",
      "text": "对，一般就是什么三五年这样子。上次ISA这家公司不是被黑了吗？就是好多国内的企业也因为要全部换一轮发出去的新闻器。我记得好像有这么一个事，所以安全还是挺难的一件事情。",
      "speaker": "发言人2"
    },
    {
      "time": "00:22:37",
      "text": "对，一会儿新闻环节里面我们也要谈聊一聊最近的这个hiking team。被被其实对。",
      "speaker": "发言人1"
    },
    {
      "time": "00:22:43",
      "text": "其实说到这个也顺便聊一下，你用那个登录服务器，SSH登录服务器，你是用密码还是用那个证书？用证书也不是用key.",
      "speaker": "发言人2"
    },
    {
      "time": "00:22:54",
      "text": "就是就用private key。",
      "speaker": "发言人1"
    },
    {
      "time": "00:22:56",
      "text": "对对对，然后我基本上我的那些服务器的话都是尽量密码登录，然后用key的。我只有root是这样的，其实我觉得只有root这样好吧。你还有其他账户吗？",
      "speaker": "发言人2"
    },
    {
      "time": "00:23:06",
      "text": "有我你难道平时用root账户登录吗？",
      "speaker": "发言人1"
    },
    {
      "time": "00:23:09",
      "text": "不是，就你其他账户只可以用密码登录吗？",
      "speaker": "发言人2"
    },
    {
      "time": "00:23:12",
      "text": "我其他账户可以用密码登录，因为有说比如说临时抓了一个ipad，必须SHSSH连上去怎么办？",
      "speaker": "发言人1"
    },
    {
      "time": "00:23:20",
      "text": "那其他的可以速度吗？",
      "speaker": "发言人2"
    },
    {
      "time": "00:23:23",
      "text": "可以。",
      "speaker": "发言人1"
    },
    {
      "time": "00:23:24",
      "text": "那那你跟root没有什么区别呢？说也是对吧？你说那个ipad那个方案可以在这其实正确的用key的就是密钥的认证的方法是每一个设备有自己的一个私钥公钥一套。",
      "speaker": "发言人2"
    },
    {
      "time": "00:23:39",
      "text": "对，但有时候是拿不到这样一个设备怎么办呢？",
      "speaker": "发言人1"
    },
    {
      "time": "00:23:43",
      "text": "也是这还是给现实给跪了是吧？对，其实我觉得私钥公钥这套方法是挺方便的。因为用私钥解决了这个密码和认证两个问题，就身份认证和密码登录两个问题。因为现在你你去一个开一个就一个普通的网络服务注册一个账号，他还让你输账号，还得输密码，对吧？多麻烦。你用那个私钥就直接给他公钥就好了，而且他永远不知道你的私钥是什么对错。所以其实之前有很多尝试，像什么最近一次应该是moza搞那个叫什么secure ID还是什么之类的东西，还是personal，我忘了忘了名字了，反正就是想把这一类类的比较方便很安全的系统去替换掉这个密码。但是这个我觉得可能对大多数人来讲，理解起这个四大公钥加密这么一个过程，或者说任何一套其他非密码的这么一个替代方案，可能还是有点成本的，所以并没有大规模推动起来。不过倒是在一些什么程序员的一些社区里面，其中的也不多很少用。我觉得最显著的是你知道有一家专门生成本身是免费SS证书的网站，叫start SSL。",
      "speaker": "发言人2"
    },
    {
      "time": "00:25:04",
      "text": "好像听过吧。",
      "speaker": "发言人1"
    },
    {
      "time": "00:25:06",
      "text": "他的那个他是要登录账号才能有一个账号系统的。他就是通过客户端的证书来实现他没有一个账号密码的这么一个概念。这是我用的唯一一家通过这种客户浏览器证书的方式来实现登录。",
      "speaker": "发言人2"
    },
    {
      "time": "00:25:26",
      "text": "其实我只是说我觉得要一个人接受抢口令和验证码这件事情有时候已经很难了。我不知道，因为咱们接触的人可能平时都比较taxi的。有其实很多很多用户都不知道验证码到底是拿来干什么用的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:25:44",
      "text": "你说哪个验证码。",
      "speaker": "发言人2"
    },
    {
      "time": "00:25:46",
      "text": "就是防止图灵测试验证。",
      "speaker": "发言人1"
    },
    {
      "time": "00:25:49",
      "text": "人机测试那个验证。",
      "speaker": "发言人2"
    },
    {
      "time": "00:25:51",
      "text": "对，在这种情况下，你要向他解释什么是公钥、私钥，以及它为什么更安全。",
      "speaker": "发言人1"
    },
    {
      "time": "00:25:55",
      "text": "其实是对的。所以还是一个教育的问题。",
      "speaker": "发言人2"
    },
    {
      "time": "00:25:59",
      "text": "对，也许我觉得可能过两三代人会觉得公钥私钥是一个非常天经地义的概念，就好像钥匙和锁一样，那就已经非常容易理解。",
      "speaker": "发言人1"
    },
    {
      "time": "00:26:07",
      "text": "你既然这么乐观，过两三代人就可以了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:26:10",
      "text": "两三袋还不够。",
      "speaker": "发言人1"
    },
    {
      "time": "00:26:11",
      "text": "我也不不要高估群众的智商。",
      "speaker": "发言人2"
    },
    {
      "time": "00:26:16",
      "text": "你你这句话太精英主义了，你要不要抹掉了。",
      "speaker": "发言人1"
    },
    {
      "time": "00:26:21",
      "text": "不要让他们来批我。",
      "speaker": "发言人2"
    },
    {
      "time": "00:26:23",
      "text": "好吧？好，那我们接下来就进入新闻环节。不如一不如就接着刚才的话头说最近这一次比较严重的一个内一个安全事件。应该说这个事件严重到严重的程度，就是它关乎你我的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:26:43",
      "text": "怎么说呢？先介绍一下怎么回事儿。",
      "speaker": "发言人2"
    },
    {
      "time": "00:26:47",
      "text": "对，好，有一个安全公司，他这个公司的名字叫做hacking team，就好像。",
      "speaker": "发言人1"
    },
    {
      "time": "00:26:53",
      "text": "什么黑客小分队。",
      "speaker": "发言人2"
    },
    {
      "time": "00:26:55",
      "text": "对，要有有一家客栈，他的名字叫做有家有间客栈一样。然后这个安全公司，这个hacky team就叫做hacker team。然后hacking team这家公司被黑了。",
      "speaker": "发言人1"
    },
    {
      "time": "00:27:08",
      "text": "对，他他不叫hacking team，叫hacked team。",
      "speaker": "发言人2"
    },
    {
      "time": "00:27:11",
      "text": "对，然后hacking team is hacked。然后这首先这家公司是以什么为生呢？他们其实就是专门搞破解。但是他搞了破解之后，不会告诉那些被破解了的或者是被黑了的网站或者公司说你们的产品有问题。而是把这些漏洞藏起来，放在什么货架？对，放在那货架上，然后包起来卖给这些。比如说NSA，或者是也是中国人，也有他们的客户，或者是一些商业间谍。",
      "speaker": "发言人1"
    },
    {
      "time": "00:27:46",
      "text": "会说世界各国政府和这种大机构，对。等一下，他们不是直接卖这些破解版，他是卖这个打包的服务，好像是对他。",
      "speaker": "发言人2"
    },
    {
      "time": "00:27:58",
      "text": "有部分漏洞是会卖出去。就是你如果你只买服务的话，你会需要你付的钱少一点。但是如果你要把整个比如说知识产权加引号买药，对，那是要花很大一笔钱，没错。然后他们靠这个赚钱攒了400 giga bites的数据。当然后来有有消息说400这个bug里面有很多很多都是email，就没什么用。",
      "speaker": "发言人1"
    },
    {
      "time": "00:28:24",
      "text": "没有很有用的。好吧，就是各种机密都在email.",
      "speaker": "发言人2"
    },
    {
      "time": "00:28:29",
      "text": "里面暴露在数据方面，他就是在400G没很多只是数据，而真正和方法相关的部分可能只有几百兆。但是无论如何，这里面全都是非常机密的信息，然后这些数据全都被黑了，然后被放在了网上，就现在你我他都可以去搞下来。哼就是所以。",
      "speaker": "发言人1"
    },
    {
      "time": "00:28:51",
      "text": "你下载了吗？",
      "speaker": "发言人2"
    },
    {
      "time": "00:28:53",
      "text": "没有，何必？400G我硬盘都装不下了。",
      "speaker": "发言人1"
    },
    {
      "time": "00:28:58",
      "text": "400G现在随便一个小硬盘都能可以。",
      "speaker": "发言人2"
    },
    {
      "time": "00:29:01",
      "text": "我只问你前面是SSD，我的SSD是装不下。我SSD就512，然后还装了一个游戏。",
      "speaker": "发言人1"
    },
    {
      "time": "00:29:08",
      "text": "所以买个那个什么。",
      "speaker": "发言人2"
    },
    {
      "time": "00:29:09",
      "text": "那个YGYG盘有啊。",
      "speaker": "发言人1"
    },
    {
      "time": "00:29:12",
      "text": "但何必装那没用的东西。",
      "speaker": "发言人2"
    },
    {
      "time": "00:29:14",
      "text": "是不是就装了很多觉得自己会看的，其实根本不会看东西。不要想歪了，我是说电子书。",
      "speaker": "发言人1"
    },
    {
      "time": "00:29:24",
      "text": "对吧。",
      "speaker": "发言人2"
    },
    {
      "time": "00:29:27",
      "text": "然后在所有这些已经被下载、已经被破解、被爆出来的工具里面，有一个比较严重的漏洞是在flash上面。就是臭名昭著的flash竟然只有一个。",
      "speaker": "发言人1"
    },
    {
      "time": "00:29:39",
      "text": "我也很吃惊。",
      "speaker": "发言人2"
    },
    {
      "time": "00:29:40",
      "text": "或者说目前被发现的只有一个，它是一个非常严重的flash zero day。然后它最大的问题是它可以让任何网站，这个网站上面有flash的话，可以让你在访问这个网站并且运行这个flash的时候，在你的机器上以管理员权限执行任何他想执行的代码。只是一件就你可能听起来没有什么，但你硬盘上所有的短信、邮件、艳照，总之你就裸奔了。对，全都跟班，最后全都跟那个就像陈冠希，无辜的把他的电脑交给了修理电脑的人一样，暴露在这个网站下面。然后当时紧急的把紧急的patch已经出来了，但是我相信很多人还是没有装。所以如果你听节目听到这里的话，最好赶紧去装一下，真的是为了自己。",
      "speaker": "发言人1"
    },
    {
      "time": "00:30:42",
      "text": "所以这件事情怎么说呢？就是说就之前大家都知道说这些安全漏洞是可以私下买卖交易，然后可以用来去去黑进别人电脑。当然可能大家都抱着一个是一个侥幸心理，觉得没事谁来搞我，我又不是什么重要人物是吧？对。",
      "speaker": "发言人2"
    },
    {
      "time": "00:31:02",
      "text": "但我觉得这次暴露就是你让我吃惊的是，原来可以有这么多这么惊人的海量的数据可以供人购买。以前总觉得。",
      "speaker": "发言人1"
    },
    {
      "time": "00:31:18",
      "text": "所以现大家都以前觉得只看那个冰山一角，现在看到看到冰山的半截，对，其实下面还有更庞大的生态链，我们是看不到的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:31:27",
      "text": "不小心扔了个深水炸弹，然后我靠浮上居然浮上来这么多破碎的宾语。",
      "speaker": "发言人1"
    },
    {
      "time": "00:31:33",
      "text": "对，但是有什么问题呢？就是这些还是我公开就用的，就在他做成这个商业化的产品的之前，已经有很多人受害了。只是你不知道而已。我们我们也就我也我可能这个时候我们在录音对吧，是不是也谁来监控，我们也很难讲。",
      "speaker": "发言人2"
    },
    {
      "time": "00:31:54",
      "text": "对，在报出来的数据里面，报出来的资料里面有，据称hacking team有在所有的几乎所有的windows客户端上安装远程桌面的方法，包括windows form。就是你在用手机，你手机上显示什么，可能已经有人可以去看了，只不过他是从来没有看过而已。",
      "speaker": "发言人1"
    },
    {
      "time": "00:32:15",
      "text": "还没来得及看一下。",
      "speaker": "发言人2"
    },
    {
      "time": "00:32:16",
      "text": "对，那前一阵子那个VKX爆出来，从施罗德到梅克尔所，每一任德国总理全都被NIC窃听。",
      "speaker": "发言人1"
    },
    {
      "time": "00:32:25",
      "text": "政府要人肯定是逃不掉的，这点什么不用想，只是说我们现在关注我们这种什么小老百姓对吧？",
      "speaker": "发言人2"
    },
    {
      "time": "00:32:33",
      "text": "对，然后其里面可能也有一部分的手段，就来自于这次被爆出来的hiking team所所开发的技术。",
      "speaker": "发言人1"
    },
    {
      "time": "00:32:41",
      "text": "对，这些都是综合性的工程，就是说他就是可能hockey team他掌握了一部分的这么一些漏洞，对吧？还有一些其他的更什么资深或藏的更好的，就这种组织或者个人，比如说NAC，对吧？他们自己有一套手上的所有的什么核武器，对这种东西，然后就是这些东西爆出来的危害在哪里呢？",
      "speaker": "发言人2"
    },
    {
      "time": "00:33:04",
      "text": "就好像怎么说呢？突然有些人告诉你说，大家过去都不知道这个原子弹怎么造，对吧？现在我告诉你原子弹是这么造，而且造这个原子弹不怎么麻烦，不怎么费钱，行吗？你只有有了图纸就可以上了。不像说你真的造一个原子弹，你有图纸你可能不一定有那个什么离心机，你看还提炼不出来那么纯高纯度的什么放射性物质，对吧？像这种软件的原子弹和核武器拿就可以用了，没错，所以反正大家最后这段时间就只好自求多福了。因为报出来之后，龚公开了这些东西之后，好人坏人都会用它的。然后你也不知道谁会对你有利，谁会对你不利，对不对？没错，其实我觉得这次出来的最我最关心的一些问题就是比如说我用苹果这个系统对吧？我就关心apple他会不会专门派一个什么，专门搞一个小组的人去研究这里面爆出来这些公开的漏洞，马上把它跟它相关的先修好。",
      "speaker": "发言人2"
    },
    {
      "time": "00:34:09",
      "text": "这也是一个lip face你永远不知道。",
      "speaker": "发言人1"
    },
    {
      "time": "00:34:12",
      "text": "不就是我觉得作为一家正经的，请相信不是他应该做的，就是把这个事情作为他的一个叫什么核心药物。提上一次马上去。",
      "speaker": "发言人2"
    },
    {
      "time": "00:34:24",
      "text": "你的意思是他们会重视起来，那肯定对。",
      "speaker": "发言人1"
    },
    {
      "time": "00:34:27",
      "text": "但不确定。你现在他不知道他没有，他没有吱声。",
      "speaker": "发言人2"
    },
    {
      "time": "00:34:29",
      "text": "对吧？这是我的灵活face。",
      "speaker": "发言人1"
    },
    {
      "time": "00:34:31",
      "text": "对，我我我是i hope you do that。但是不一定，所以就看看最近这个你而且他们修那个就他们去分析一个漏洞，然后去修打补丁，还要测试再放给大众。中间还有这么一长，至少可能有这么一两周或者一两个月的那个过程，对吧？所以在这段时间内，大家还是都处于在裸奔的状态。对对对，所以真的是安全是很难的。就从某种意义上来说，以后的这个所谓的真正意义上的安全，就只能是少部分特权阶级或者特别有钱的人能够享受的服务了。因为你看有这么多人花钱来搞你，对吧？那你怎么办？",
      "speaker": "发言人2"
    },
    {
      "time": "00:35:14",
      "text": "你怎么花钱？有钱得起私人兵才私人雇佣军才可以。",
      "speaker": "发言人1"
    },
    {
      "time": "00:35:19",
      "text": "对对对，不是上次那个谁，是希拉里克林顿他们在竞选美国总统吗？然后他后来就有就很多报道去去去把他的那过去，说他在当那个他当国务卿还是什么来着，反正是security state应该是国务卿国务卿。对。然后期间他竟然在自己家里地下室搞了一个没有server邮件服务器，去跑他自己的私人邮件。然后他的目的也比较简单，就是避开。因为如果他用公那个政府就是白宫的邮件服务器，对，他是他是不是那个base杂志肯定的就会被阿凯会被存档。然后以后可能会被翻出来做出一些对他不利的东西。所以他就搞了个自己的私服。",
      "speaker": "发言人2"
    },
    {
      "time": "00:36:04",
      "text": "然后自己的一些商品套传奇。",
      "speaker": "发言人1"
    },
    {
      "time": "00:36:07",
      "text": "自己在邮件上面玩一些东西。后来就说我操那还得了，你想白宫的那些邮件服务器得通过NSC，得专门派一一小队人在那里帮他盯着，对吧？好歹还好一点，他放自己家里谁给他盯着。所以我还是蛮震惊的，竟然还有这种玩法。不过他一般通过邮件交流的，也不是什么特别要紧的国家机密那种不用专门专线所谓的对吧？还凑合。但是这种知道这种消息还是挺挺不容易的这就回到了那个什么，刚才我们开场我提到那个问题，到底相信谁是吧？其实正确答案是trust no one，但是做不到。",
      "speaker": "发言人2"
    },
    {
      "time": "00:36:52",
      "text": "这是X档案里面那个主角叫什么cat fox fox他叫什么来着？Murder, 它的开机密码就是trust no one。",
      "speaker": "发言人1"
    },
    {
      "time": "00:37:06",
      "text": "那你现在也知道了，就是你正确的方法是trust no one，但是其实做不到。我觉得我相信这个信息上99.99999999%的人都做不到。因为你要trust stone的话，就像刚才我说的，从硬件底层开始，每一个步骤都要经过你自己的验证，对吧？对，其实不现不不现实的，所以只能选择相信一帮人了。然后对至于说你想选择相信他之后会发生什么，那就只能天知道了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:37:40",
      "text": "对，当然也我觉得也不用特别过分的去怀疑怀疑这些人，或者怀疑音频公司，或者说怀疑whatever那个人。因为你你活在现代社会里面，完全不相信任何人，其实只是一个美好的愿景和假象。",
      "speaker": "发言人1"
    },
    {
      "time": "00:37:57",
      "text": "你是做不到的。我觉得这我觉得这是是这样子的，就是现在这些系统已经太复杂了，你没有可能从一个比较高的可信度的情况下，确保这个体系不出任何问题，这就是不现实的。就好像你说指望我要这个软件没有bug，不太现实。这个时候怎么办呢？你只能说就选择相信了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:38:26",
      "text": "对我觉得复杂度是固然是一方面，另一方面是你在生活中已经你在现代社会里面已经选择相信很多人了，对吧？或者说无条件的去吸引很多人，甚至很多人你根本就不认识，根本就不知道他叫什么。比如说你上公车，你搭乘飞机的时候，你就把生命交给了机长的手里，不是吗？然后你在银行存钱的时候。",
      "speaker": "发言人1"
    },
    {
      "time": "00:38:47",
      "text": "不光是机长，还有什么各种航空公司对飞机制造厂，然后雷达天气，还有什么上帝不会砸个鸟过来撞死你是不是对，就这类的对。",
      "speaker": "发言人2"
    },
    {
      "time": "00:38:59",
      "text": "所以活着就要有时候就是被迫要盲目相信一些人。",
      "speaker": "发言人1"
    },
    {
      "time": "00:39:03",
      "text": "Life is risky, 为什么？",
      "speaker": "发言人2"
    },
    {
      "time": "00:39:09",
      "text": "忽然觉得好沉重。",
      "speaker": "发言人1"
    },
    {
      "time": "00:39:11",
      "text": "没有，大家都知道，这个人生就是有风险，你坐家里还指不定天上掉个东西，什么把你房子砸垮了，顺便把你砸死，对吧？",
      "speaker": "发言人2"
    },
    {
      "time": "00:39:19",
      "text": "就好像今天刚刚我今天中午吃饭的时候，apple watch突然震了一下。然后他就手手往里一看说我住的这个地方叫Frankie，说Frank地区有一个腔发生了枪击案。我说我然后赶紧进去看看细则，就在离我50公里的地方，有一个人他开着一辆银色的methods的cabral敞篷跑车。对，在路边停下问路边一个老太太，82岁老太太一些事。问完之后老太太往回走的过程中，她掏出枪来把老太太打死了。",
      "speaker": "发言人1"
    },
    {
      "time": "00:40:01",
      "text": "神经病。",
      "speaker": "发言人2"
    },
    {
      "time": "00:40:01",
      "text": "这是我不知道。然后他开了大概10公里左右，又杀死了一个在路边骑自行车的人。",
      "speaker": "发言人1"
    },
    {
      "time": "00:40:09",
      "text": "所以他是什么反社会人格是吧？",
      "speaker": "发言人2"
    },
    {
      "time": "00:40:11",
      "text": "我我我不知道这是今天才发生的事情了，所以我可能一会儿看一下新闻才知道具体发生了什么。但怎么说呢？就是飞来横祸不是吗？而且离离你这么近就离我这么近50公里之外。我对，石油每天是不是每天在以前往返于某地和某地之间每天会好。为什么总是说每天经常会经过的那个地方，就是你看着高速公路上的牌子，记着这个名字，然后忽然今天那儿发生了一次强奸。",
      "speaker": "发言人1"
    },
    {
      "time": "00:40:39",
      "text": "所以就是什么就是你可能什么出门被车撞死，然后遇到一个疯子把你给崩了，然后什么喝水可能被淹死就呛死之类的。反正你只要做任何事情，就不管你做还是不做任何事情，你总是会有机会遇到这种小概率事件的对。",
      "speaker": "发言人2"
    },
    {
      "time": "00:40:57",
      "text": "所以其实信息方面的信息安全方面的风险还是必须要承担一点。",
      "speaker": "发言人1"
    },
    {
      "time": "00:41:01",
      "text": "对，没有一样的。你想你这么想一下，你可能觉得你就安心释然一点。对，没错，OK. 那我们。",
      "speaker": "发言人2"
    },
    {
      "time": "00:41:08",
      "text": "过渡到下一条新闻，这条新闻比较振奋。",
      "speaker": "发言人1"
    },
    {
      "time": "00:41:14",
      "text": "就是老文了，就已经上两周前的了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:41:19",
      "text": "对，开发了，满打满算其实有七年。但是去年2月26日才public beta的这个来自于github的ATM编辑器。今什么今天6月25日终于发布了1.0版。",
      "speaker": "发言人1"
    },
    {
      "time": "00:41:38",
      "text": "这也是个什么？1.0就是一个里程碑了。对。",
      "speaker": "发言人2"
    },
    {
      "time": "00:41:42",
      "text": "当然这是give up这种比较负责任的公司，会把1.0版这么及时的试出来。你像当初google mail贝塔了多久？",
      "speaker": "发言人1"
    },
    {
      "time": "00:41:55",
      "text": "好多年。",
      "speaker": "发言人2"
    },
    {
      "time": "00:41:56",
      "text": "对，十年都没有。",
      "speaker": "发言人1"
    },
    {
      "time": "00:41:58",
      "text": "差不多。",
      "speaker": "发言人2"
    },
    {
      "time": "00:42:00",
      "text": "难以相信。",
      "speaker": "发言人1"
    },
    {
      "time": "00:42:01",
      "text": "对，所以1.0版有什么特别的？",
      "speaker": "发言人2"
    },
    {
      "time": "00:42:04",
      "text": "其实也没有什么特别。我仔细看了一下，就是他们从public release一直到现在历经155次release。就是过去的这一年多一点里面有155次release，每一次都有change list。然后现在就是他们整个编辑器的核心可以扩展的那一部分，就是API那一部分已经被正式确定下来了，这也是他发布1.0版本的主要原因。",
      "speaker": "发言人1"
    },
    {
      "time": "00:42:33",
      "text": "然后其实我想说的是，就是他有一个视频很有意思，他用一台用那种60年的手法，如果你看过一个视频叫做prediction of home computers之类的这么一个60年代做的未来关于未来家用电脑的展望视频的话，这个视频跟那个视频是不是相呼应的那种感觉？对那个60年代的视频里面说，已经假想了将来的人们回家，一回家就会开电脑，然后可以在多个显示器上处理表格，然后可以通过一个巨大的电视屏幕一样的东西和一个滚轮滚球应该说之类的会以旋钮之类的东西来在线购物。那个时候已经全都想到了这些。然后这个HHM1.0的宣传视频，就是perot也不算，就是用那种风格拍了一个一家人围绕着这么一个专用的icon控制台上面写代码过程还蛮值得一看的对。",
      "speaker": "发言人1"
    },
    {
      "time": "00:43:39",
      "text": "这个什么程序员的二区位置没错。",
      "speaker": "发言人2"
    },
    {
      "time": "00:43:43",
      "text": "可是提一下就是那个visual studio code也发布了0.5版。",
      "speaker": "发言人1"
    },
    {
      "time": "00:43:49",
      "text": "其实这几个我一直搞不清楚，facebook最近之前不是也搞了一个叫new close对吧？",
      "speaker": "发言人2"
    },
    {
      "time": "00:43:58",
      "text": "New close是基于也是基于electron的吗？不是吗？",
      "speaker": "发言人1"
    },
    {
      "time": "00:44:03",
      "text": "对对对，就是基于那个和那个什么电子对对对。",
      "speaker": "发言人2"
    },
    {
      "time": "00:44:08",
      "text": "就是对一套东西。",
      "speaker": "发言人1"
    },
    {
      "time": "00:44:10",
      "text": "反正就是基于web技术做了3款浏览器了。Atoms是一个什么？算是第一个正统。对，还有那个nucleus，然后有那个visual studio code对吧？最近也是今年出的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:44:23",
      "text": "还有什么slack，slack那个什么协同软件吗？",
      "speaker": "发言人1"
    },
    {
      "time": "00:44:32",
      "text": "他是是一个基于和谐的吗？",
      "speaker": "发言人2"
    },
    {
      "time": "00:44:35",
      "text": "对，一个也是。怎么说，他自己好像叫自己messaging，messaging APP就是一个团队协作软件。但实际上他也是从那个electron改。我记得老师还给给咱俩发过invitation.",
      "speaker": "发言人1"
    },
    {
      "time": "00:44:48",
      "text": "相当于我我有装我我有装备我没装。对我用了一下，其实你一看就知道，这其实是一个review封装起来的壳子，对比那个过去review可能做的要稍微原生一点，但是毕竟还是不改它那个本质。对，那当然这些本质是什么呢？所以说我先问一下，从1.0能打开一个20兆的文件吗？",
      "speaker": "发言人2"
    },
    {
      "time": "00:45:13",
      "text": "不知道，我还没装，其实那似乎。",
      "speaker": "发言人1"
    },
    {
      "time": "00:45:15",
      "text": "还是不行是吧？OK虽然也不太可能有20兆的一个程序的代码，但是毕竟还是有这么一个限制的。然后这些东西都有一个问题，就是比较臃肿。",
      "speaker": "发言人2"
    },
    {
      "time": "00:45:33",
      "text": "对，其中比较占资源吧。",
      "speaker": "发言人1"
    },
    {
      "time": "00:45:34",
      "text": "应该说对，虽然说现在什么硬件资源比较丰富，但是我总觉得就这么浪费好像也不是一个特别好的事儿。对，做一个编辑器竟然要500兆的内存才能跑起来，觉得就有点过了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:45:53",
      "text": "是对，这就是为什么一些古老的用C写的编辑可以一直活到今天。",
      "speaker": "发言人1"
    },
    {
      "time": "00:46:02",
      "text": "然后什么VI、ME max都还挺好的。所以其实你看好这一类的东西，就是把那种web的技术跑在客户端，跑跑在那个原生的皮里面，然后假装自己是原生应用。",
      "speaker": "发言人2"
    },
    {
      "time": "00:46:19",
      "text": "其实在前两上一期节目里面说什么web up is for animals的时候，我就想把这个wifi封装成一个原生APP。这种东西又又又应该怎么讲？",
      "speaker": "发言人1"
    },
    {
      "time": "00:46:32",
      "text": "不，这个我觉得跟外卖可能还就我们传统意义认为的外部可能还不太一样。就是传统一张wifi可能还是在浏览器里面。然后它的其实我觉得这个界限主要在哪里呢？就是它它的这个在离线状态下的行为，就起码这些几个应用都是说它的本初是为单机或者离线状态自己运行的这种情况设计的。它不牵涉到说很多web APP，他没有做这个叫做APP cash和这个off limo的情况下，那我们完全没法用的那种情况。这个我觉得还是有很大区别的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:47:08",
      "text": "好吧。我觉得最大的区别还是在于那个chrome，就是在于那个外的那个那个框架什么。你在用外卖的时候，你会有一个明确的心里预期，说我正在浏览器里面使用一个东西，这个东西不是native。因为我觉得至少我会有这样一种默默的心理暗示。但是我觉得这也就是为什么google要把cro max单独拎出来，放成一个独立于浏览器之外的窗口，放在一个独立于浏览器之外的窗口里面，让用户来用，我觉得他就是试图打破这种pro但是。",
      "speaker": "发言人1"
    },
    {
      "time": "00:47:50",
      "text": "脱枷锁对吧？",
      "speaker": "发言人2"
    },
    {
      "time": "00:47:51",
      "text": "对效果还是不是很好。",
      "speaker": "发言人1"
    },
    {
      "time": "00:47:53",
      "text": "但所以你看到像atom这种编辑器的时候，你用的时候你会觉得它是一个非原生的东西。",
      "speaker": "发言人2"
    },
    {
      "time": "00:48:00",
      "text": "我觉得这种感觉已经非常淡化。就因为我为了准备这一期的节目，是又打开创办最新版的那个studio code，然后用一下。就感觉还是就。",
      "speaker": "发言人1"
    },
    {
      "time": "00:48:11",
      "text": "你感觉不到它除了在那个JUI风格上，跟你的系统格格不入之外你感觉不到它是一个网页应用，对不对？",
      "speaker": "发言人2"
    },
    {
      "time": "00:48:23",
      "text": "也跟格格不入也没有。我必须说，但他风格。",
      "speaker": "发言人1"
    },
    {
      "time": "00:48:27",
      "text": "很不一样。",
      "speaker": "发言人2"
    },
    {
      "time": "00:48:31",
      "text": "或者说我在用viral的时候，心里面就带着这样一个预期，我就说这是微软做的东西，它它风格本来就不一样是吧？对它不可能一样OK。但当然你说的也有道理，但话说回来，风格跟原生的不一样的，原生APP风格跟默认的苹果风格不一样的。Recipe其实也很多。",
      "speaker": "发言人1"
    },
    {
      "time": "00:48:54",
      "text": "对，所以其实说到底就是说web叫什么来着？Web APP本身并不代表一个比较糟糕的体验，是这个意思吗？就是他用的一些技术是这么觉得，是可以实现出一个比较原生的体验的。当然说我们资源占用上这个事情先不讲，就是说在交互上，还有包括这个给人的感觉上是可以做到比较好的。之前就说这个外卖不好用，纯粹是因为他们做的不够好吧。",
      "speaker": "发言人2"
    },
    {
      "time": "00:49:24",
      "text": "OK我们可以暂时把这个浏览器的新闻放在一边，将来如果围绕student code也出1.0的话，我们就来后续OK。好吧，那下一条新闻就是你你写的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:49:43",
      "text": "对，这个事情还挺有意思的。就是之前我们讲在阿里功能里面经常讲的那个叫oculus rift那个3D的虚拟现实眼镜。然后他那个开发者叫做john craic都应该比较熟悉了。他在应该是上周还是前周，也也是差不多也是3月20几号的时候，在google那个讨论组里面发了这么一条信息。就是他在琢磨着用rocky rocket。",
      "speaker": "发言人2"
    },
    {
      "time": "00:50:16",
      "text": "是一个scheme语言的一个实现。然后scheme是一种list，它是list one。对，然后他决定用这个racket或者是scheme这个语言给这个VR环境里面做一个，怎么说呢？就是叫做教学语言。可以这么讲，教学环境应该是它叫做scripting environment，就是脚本环境。",
      "speaker": "发言人2"
    },
    {
      "time": "00:50:41",
      "text": "什么意思呢？就是你可以在通过写这个scheme代码，在那个虚拟世界里面构建出一些组件出来。比如说可以看到什么大。就像搭积木一样，做一些事情。",
      "speaker": "发言人2"
    },
    {
      "time": "00:50:52",
      "text": "然后他发了一篇非常长的文章去讲，他就真的想为什么会选择这个skin？还有一些其他关于搭建这个环境的一些事情。我把那个链接放到那个junot里面。但我觉得这个事情大家还挺好，挺有意思的，大家可以去看一下，具体内容我现在不剧透了。对对，我不知道你你你怎么想这件事。",
      "speaker": "发言人2"
    },
    {
      "time": "00:51:16",
      "text": "我其实我脑子里面第一想到的是当初我在那个电视上面用apple two和logo语言操纵那个海龟的时候，那个那个场景。",
      "speaker": "发言人1"
    },
    {
      "time": "00:51:29",
      "text": "就是对，差不多。他想的应该是类似的应用，只不过是做到那个VR就是虚拟现实的环境里面去了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:51:36",
      "text": "对然后我想就是因为logo本身也是一个比较有意思的functional program language。然后也许将来的孩子们可以带着VR眼镜，然后用一种这样类似于logo的教学式的script language，在一个3D的世界里面操纵三弟的海归，或者说一个海龟这个metaphor这么一个东西。然后去画一些比如说3D的分形图形，或者是啊对画what's是模型感觉很exciting。",
      "speaker": "发言人1"
    },
    {
      "time": "00:52:12",
      "text": "所以你在scheme用scheme在虚拟环境里面画这种物件，你觉得会怎么样？",
      "speaker": "发言人2"
    },
    {
      "time": "00:52:21",
      "text": "应该蛮酸爽的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:52:23",
      "text": "你记不记得上次我给你发过一个，应该有两个链接吧，是youtube的视频。就是有人在那个VR眼镜里面，就VR那个虚拟世界里面，实时的通过编辑应该是javascript代码来去操作里面的物件的那些虚拟的物件的变。",
      "speaker": "发言人2"
    },
    {
      "time": "00:52:42",
      "text": "改变周遭环境。",
      "speaker": "发言人1"
    },
    {
      "time": "00:52:44",
      "text": "对对对，你还记得那个视频吗？而且记得应该这个过程还是蛮蛮有意思的。他那个不太好的一方一点就是他要如果他要改变这个款，他的reload他就得刷新那个脚本，然后这个只能重绘一遍。整个环境。然后我们知道用scheme的话，他可不可以做到一个增量的一个修改。因为大家之前你知道list他刚才说的那个最牛逼的功能，就是可以在它运行中动态修改代码，然后再部分的执行，对吧？",
      "speaker": "发言人2"
    },
    {
      "time": "00:53:13",
      "text": "对数据和代码部分。",
      "speaker": "发言人1"
    },
    {
      "time": "00:53:16",
      "text": "在没错，所以这个还是蛮值得期待。",
      "speaker": "发言人2"
    },
    {
      "time": "00:53:19",
      "text": "的。对，其实这里可以顺便说一下，就是我今天在the verge还是什么上面的不对，technique上面看到了一个微软最新的关于holds的视频，然后里面就有一个怎么说类似于低人生视角的。告诉你说你带上holds之后能看到的这么一个区域。对，然后我就感受到了lois的带了holds之后那种失落感就真的差挺多的。之前我不知道你，但。",
      "speaker": "发言人1"
    },
    {
      "time": "00:54:00",
      "text": "你是我的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:54:01",
      "text": "对我我脑补的这个hollands是戴上之后你可以全市场看到的。然后当人们对当人们告诉我说这个市场其实很窄的时候，我没有一个主观意向它到底有多窄。但只有直到看了那个视频之后，我才意识到，我靠原来这么窄。这个差别就是我之前想象的是一个留一个显示器，大到我把你包起来，你坐在一个属于你自己的微型天文球里面这种感觉。但实际上他只不过是把一台显示器摆到你面前，就是在你眼镜前面就大概那么大的地方，这实在是差别太大了。",
      "speaker": "发言人1"
    },
    {
      "time": "00:54:40",
      "text": "是再也不能说什么取消显示器，然后整屏都是这个编辑器窗口的这么一个愉快的想法了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:54:48",
      "text": "对，那我所以我必须收回自己说lars什么期待太高了，这这个实际的实验效果连我都受不了好。",
      "speaker": "发言人1"
    },
    {
      "time": "00:55:00",
      "text": "所以他有说是因为什么原因实现不了，是因为这个光学元件的物理限制，还是说只是因为为了降低。因为他那个是戴在头上是整一体机，没有一个单独插线的外接的设备，所以他要考虑什么供电，续航的问题。",
      "speaker": "发言人2"
    },
    {
      "time": "00:55:18",
      "text": "对我觉得其实就是技术还不成熟。但是那个视频主要是宣传这个holds在一个医院里面的一些用力的。比如说医生可以直接看骨头断裂的情况就可以。你可以看到那个屋子中间有一个心脏，然后你心脏在跳，然后你可以转着看这个心脏跳动的状况之类的。所以他没有解释说市场为什么这么窄，它只是怎么说呢？可能觉得自己之前吹的有点懵了，所以就用这个视频让大家明白一下，其实看到的效果只不过是这样，你们不要期待太高那种感觉。有一点点expectation control management的一个感觉。",
      "speaker": "发言人1"
    },
    {
      "time": "00:56:02",
      "text": "微软现在来做这个又有什么用呢？他他之前自己把那个东西吹得那么好，当时第一次出那个视频的时候，就是他发了发布了两次，其实就是说感觉这个比喻又要吹破了，这个比喻画太大对吧？现在看果然画太大了，不过还是好，总比没有强。这个毕竟是第一代产品，所以让他们迭代两年再说。",
      "speaker": "发言人2"
    },
    {
      "time": "00:56:28",
      "text": "黑黑黑微软的话，你们留到IT公司。",
      "speaker": "发言人1"
    },
    {
      "time": "00:56:31",
      "text": "里面说没有我没黑，经常有人说我黑，经常有人说我黑软。其实我给他们还是蛮蛮高兴的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:56:37",
      "text": "我觉得你刚才的话，你刚才的话在软狗耳朵听起来就已经是对。",
      "speaker": "发言人1"
    },
    {
      "time": "00:56:42",
      "text": "就是黑他们是吧？对，好吧，那那你倒是拿出一个让我们惊艳的东西来看。",
      "speaker": "发言人2"
    },
    {
      "time": "00:56:48",
      "text": "他们会说布拉黑科技，布拉微软做的事怎能叫布拉操。",
      "speaker": "发言人1"
    },
    {
      "time": "00:56:56",
      "text": "你耐心停留在什么microsoft research里面，不会拿出来的有什么用呢？不过其实从那个完成从那个完成度来讲，我觉得其实这个已经蛮高的了，就是holo等一代对吧？所以其实我我还是挺挺乐观的，就是让他们在就希望他们能够保持这个速度往前去迭代。",
      "speaker": "发言人2"
    },
    {
      "time": "00:57:20",
      "text": "OK我们接下来可以进入正题了，今天的话题是第一版，用中文说就是除错与调试。我不知道real你你你经常低bug吗？或者说你觉得低bug，你觉得你写代码的时间后，里面是堤坝的时间多，还是真正写代码的时间多？",
      "speaker": "发言人1"
    },
    {
      "time": "00:57:46",
      "text": "我第八个时间不算多，对，可能是两三层的样子。但是主要是因为我写的东西也不是特别复杂，就还凑合。",
      "speaker": "发言人2"
    },
    {
      "time": "00:57:59",
      "text": "你太谦虚了，你可以直接说你写的东西是bug free。这是什么？前两天我在一个网站叫什么讲什么呢？就讲白板编程，讲面试。应该是他讲说应该怎样去做白板面试。我们回头会把这个链接放在show note里面。",
      "speaker": "发言人1"
    },
    {
      "time": "00:58:22",
      "text": "但是我印象里面比较我印象比较深的一句话就是它里面说程序员可以分为两种。一种是会先确认前条件、终止条件、边界条件以及不变的那一部分，然后写入正确的代码。另外一种是先编写代码，然后通过各种用例调试测试对程序进行调整，最后得到似乎正确的代码。就是可以分开，不是TDD吗？TDD是哪一种？第一种还是第二种。",
      "speaker": "发言人1"
    },
    {
      "time": "00:58:55",
      "text": "就是后者。",
      "speaker": "发言人2"
    },
    {
      "time": "00:58:57",
      "text": "对，第二种他说先编写代码，然后通过用例，TD应该是第一种。对，TD应该是一个一个确立。Anyway然后他里面说他个人估计保守估计前者的开发效率至少是后者的十倍，因为前者不需要浪费大量时间的编码调试编码这个极其耗时的循环上面，我觉得说的有用。",
      "speaker": "发言人1"
    },
    {
      "time": "00:59:24",
      "text": "写代码之前敲键盘之前先动脑子想是不是对。",
      "speaker": "发言人2"
    },
    {
      "time": "00:59:29",
      "text": "就包括在一些刚需卫生的人身上也会发现一个问题，就是发现一种现象，就是他认为写代码的速度跟敲键盘的速度相关，其实并不是这样。我可以举两个例子，一个是我前上家公司里面一个六十多岁的程序员，他可能是从cobo时代就写写程序，然后到六十多岁还在做那个高级顾问。众所周知，德国的退休年龄是67岁，所以你60岁的高龄还在写程序。然后他和很多德国人一样，只会用两个指头跷跷板。你很难想象，一个写了30年程序的人只会用两个指头算，对吧？但他的效率你不比任何人慢。或者说他写出来的编码的，他写出来的程序的可靠性和效率并不比任何人差。然后反过来有另外一个例子，就是我上一家公司里面。",
      "speaker": "发言人1"
    },
    {
      "time": "01:00:33",
      "text": "有一个那就不透露。",
      "speaker": "发言人2"
    },
    {
      "time": "01:00:35",
      "text": "他的肤色了。他就有这么一个朋友，他经常会说每天开会的时候他就会说，我还有一点点完了，我80%已经写完了，只剩下20%。只是一些细节需要调整一下。但是如果你仔细看着它这个细节的调整到底是在干嘛的时候，它其实在大量的改变自己的代码，因为它里面有很多东西虽然写的很，但根本就是写错了好吧。所以这所谓的20 20%，其实占用了他整个开发了80%的时间。他总觉得自己可能明天就会写完，但其实明天会发现，我靠还是要后天和大后天。对，所以我觉得real，其实你刚才暗示了你是第一种。",
      "speaker": "发言人1"
    },
    {
      "time": "01:01:21",
      "text": "好吧，我我我我觉得我是最起码我希望是第一种，不知道这是不是真实，但是尽量呗就有这么一个，刚才我说那个写代码之前先动脑子，但这个不是说来玩玩，我看到有很多人写代码的时候，先反正先敲几行再说，再来想怎么弄？怎么改。其实我看到很多那种所谓什么大神级程序员，其实他是要先写代码。他在想好久好久在脑子里面构建一个大框架，步骤怎么样，有些什么样至少要注意的点，他会想的比较清楚，然后才会动笔在动，不是动笔动用键盘慢慢的去敲。",
      "speaker": "发言人2"
    },
    {
      "time": "01:02:02",
      "text": "对，其实这跟写作文差不写文章差不多。并不是说你要写东西，就是你要一定要坐在书桌前面，然后打开稿纸。就像你要写程序，并不是一定要先赶紧打开你的ID，然后新建一个项目，然后写个妹函数出来，然后盯着他发呆，你要想写什么东西，在各种各样的时候去想你要写什么东西。就是洗澡的时候、刷牙的时候、走路的时候，跟女朋友聊天的时候，当然最后这种是非常不推荐的，我吃过苦好吧。在这个时候你就你已经可以在构想你要写什么，然后等到你真正有一定把握的时候再再出来写，这样要比你直接上来就噼里啪敲键盘，其实效率要高。",
      "speaker": "发言人1"
    },
    {
      "time": "01:02:46",
      "text": "我觉得哼没错。所以以后也就是如果比如说咱我我去开一家软件公司，要在什么除了标配那些什么办公桌，什么椅子之外，还得做一个理想是像那个。",
      "speaker": "发言人2"
    },
    {
      "time": "01:03:01",
      "text": "4C城曾经晒过他们公司有那个power net椅子。你可以躺下去睡觉的时候，你可以小程序吗？",
      "speaker": "发言人1"
    },
    {
      "time": "01:03:13",
      "text": "不能，睡着了得冥想在那打坐。",
      "speaker": "发言人2"
    },
    {
      "time": "01:03:17",
      "text": "那个中文OK我我我相信，但我是觉得至少我写成我写构思程序的时候，基本上都是在动的时候，就是身体一定要在做什么事情。比如说开车或者是骑自行车，或者是啊走路之类的，就躺着在一个地方静静的呆着，我是想不好事情。",
      "speaker": "发言人1"
    },
    {
      "time": "01:03:39",
      "text": "但所以其实从这个角度来讲，我觉得那个叫什么literate programming，这是我们讲的文化编程又来了，挺好的。就是他可以强迫你在写第一行代码之前，先把这个什么前因后果思路写出来。背景对对对，先把这个整体思路讲写出来，然后你再顺着一个思路写一行代码。",
      "speaker": "发言人2"
    },
    {
      "time": "01:04:01",
      "text": "这样对但是不管怎么说，不就会不或者说不管多强悍的程序员，他写出来的程序终究是没有办法避免会有bug，所以这个时候就需要D版。我们不妨先来解释一下低版这个词是怎么来的。即使有一个美丽的都市传说，我相信可能大部分听众此时也都会说出来说低。是曾经有这么一位女程序员，她的名字叫做Grace hopper格里斯霍普，这么一位美国海军准将。准将程序员他曾经在1950年代的时候开发应该是哈佛的一个大型计算机项目的时候，去检测一个计算机的故障。然后他发现故障的原因是一个蛾子一只蛾子卡在一个继电器上面，然后这个继电器没有办法正确的被放下来，就是对对对接触不良了，因此导致了整个计算机不工作。然后他把这个蛾子取出来，然后把这个蛾子粘在了那一天的这个故障记录上，然后写说这只帽子导致了整个机器故障，然后我litter里面的第一版的对，这是这个堤坝的一个词的由来。",
      "speaker": "发言人1"
    },
    {
      "time": "01:05:29",
      "text": "但是真的真正的除虫。",
      "speaker": "发言人2"
    },
    {
      "time": "01:05:32",
      "text": "对，但实际上虽然Grace hopper使用了堤坝这个词，堤坝这个词作为排除故障的纸袋，早在1940年代左右就已经在其他领域，尤其是电子和机械领域就已经其实已经被人使用过。所以迪拜这个词其实并不是Grace harper的发明。然后堤坝这个词真正成作为一个排除错误的一个同义词，也是一直要到1960年代左右才真正的在计算机界推广开来。我记得好像是那个文章说，一直到65年还是哪年才有一篇论文的第一页直接使用了第一版这个词，而且没有注释说这个没有加引号，也没有注释这个词到底是什么意思。所以直到这个时候，迪拜才真正的进入了计算机界的主流。",
      "speaker": "发言人1"
    },
    {
      "time": "01:06:29",
      "text": "OK我们又考了一下股。对。",
      "speaker": "发言人2"
    },
    {
      "time": "01:06:33",
      "text": "不如说一说你遇到过的比较有意思的bug，或者说你你又你遇到过什么比较困扰你或者比较有意思吧。",
      "speaker": "发言人1"
    },
    {
      "time": "01:06:46",
      "text": "就上次我们那个串台。",
      "speaker": "发言人2"
    },
    {
      "time": "01:06:50",
      "text": "对对对，IPN串台bug也是一个比较意思。对，我记得很多人猜测过，为什么我们要换很多换了很多次podcast solar。然后为什么要折腾来折腾去，有时候支持这个podcast客户端，有时候不支持那个pocket高端。其实都是我们在试图解决这个bug，不明白为什么会串台。",
      "speaker": "发言人1"
    },
    {
      "time": "01:07:15",
      "text": "对。然后为什么不能解决这个bug，主要是因为我们没有办法重现它。这个是一个很很重要的事情。就是说你要去除一只虫，首先你得看到这只虫，对吧？你得找到这个虫在哪，是怎么发生的，一个生成的机制是怎么样子，什么条件下会触发它，然后凡是那些你想找找不着，不知道怎么触发，不知道什么时候出现，也没办法重现的东西，我们基本上叫做fatton bug。",
      "speaker": "发言人2"
    },
    {
      "time": "01:07:43",
      "text": "就是影崇上次那个那个串台的bug之所以那么久都没有找到原因，一个最主要的问题就是我们两个都没有办法重，不应该是我们仨都没办法重现它。因为这个东西是要在特定的运营商的网络里面，就是长城宽带才会出现。然后偶尔在某些什么移动，连电信的运营商里面偶尔也会出现。但是好像这个就是跟电信或者他们的网络的结构有点关系的。因为它不似乎不是一个全国统一的一个结构，所以就比较麻烦了。",
      "speaker": "发言人2"
    },
    {
      "time": "01:08:27",
      "text": "没错，就有人定义过说迪拜的过程其实就是is a process of confirming the many things that you believe are true，until you find one which is not true. 我们首先有两个障碍，第一个是我们我们believe true的东西他实在是太多了。另外第二个就是我们没有办法通过一次事例就决定说这个东西肯定是出。我自己都下载过了无数次podcast，但是没有一次是可以重现这个bug。因为对我而且对而且即便你是用长城宽带，你也不是每次都会遇到这个bug，这也是最让人头疼的一个问题。",
      "speaker": "发言人1"
    },
    {
      "time": "01:09:15",
      "text": "没错。",
      "speaker": "发言人2"
    },
    {
      "time": "01:09:16",
      "text": "yes. 要不我来说一个，我遇到过一个比较痛苦的bug，而且很遗憾的是这个bug直到今天我都没有解决它，我就离职了。",
      "speaker": "发言人1"
    },
    {
      "time": "01:09:31",
      "text": "来说一下。",
      "speaker": "发言人2"
    },
    {
      "time": "01:09:32",
      "text": "这是我心头心心里的一个痛。我的上一家公司是做博彩的。",
      "speaker": "发言人1"
    },
    {
      "time": "01:09:43",
      "text": "不用说这么高雅，就是赌球。",
      "speaker": "发言人2"
    },
    {
      "time": "01:09:46",
      "text": "对，是赌球的。然后赌球的公司比较重视你的一件事情就是客户的。怎么说呢？就是客户会把钱存在我们公司的网站上，可以理解。但是有时候有一些使用IOS设备的chrome用户。就是如果一个用户使用IOS上面的chrome访问我们公司网站，然后登录我们公司的服务器，大概有万分之1到101‱的概率，他会看到另外一个人的账户，这是非常恐怖的一件事情不是吗？就你登录了你自己的账号，结果看到另外一个人账号，此时你就会难道你心里不会产生一丝恐慌，就是我靠，那我的账户不是也被别人用了吗？然后对。",
      "speaker": "发言人1"
    },
    {
      "time": "01:10:40",
      "text": "好像里面有钱。",
      "speaker": "发言人2"
    },
    {
      "time": "01:10:42",
      "text": "对，而且里面有钱。而且感觉突然。",
      "speaker": "发言人1"
    },
    {
      "time": "01:10:44",
      "text": "你登录哪天都换了人家银行，这个好像银行也经常出现，说什么去那个ATM机取钱，一看操插进去一看存款后面有八个0。",
      "speaker": "发言人2"
    },
    {
      "time": "01:10:55",
      "text": "对，赶紧全都存出来吧？赶紧全都取出来对吧？但这是非常恐怖这个bug。但是我其实遇到了跟IP串台问题一样的人，一样的困境，就是我们我自己没有办法重现这个，只是有大概4到5个比较有良知的用户，遇到这种情况立刻截了图，然后退出那个账户，然后把截图发给我们。",
      "speaker": "发言人1"
    },
    {
      "time": "01:11:20",
      "text": "说有这么一个有这么一个accent在然后第一件事情出现的时候，基本上就已经鸡飞狗跳了。然后后面又出现了三次，大概有那么四五个人连续不断的去尝试重现这个bug，没有做到。然后又开始尝试着分析这些人的账户，他们的登录过程有什么异常之处也找不到。而且OK而且比较悲惨的是，这些人一旦把这个报bug报进来，我们就必须立刻先把他的公司，先把他的账户给封了。因为生怕他又对又生怕他又再一次动作同一账户。",
      "speaker": "发言人1"
    },
    {
      "time": "01:12:01",
      "text": "然后一个可能的猜测是这个bug是由我们的session replication server引起的。因为服务器是一个集群，你要在这个服务器上登录，然后你的session信息需要被复制到另外一个服务器上的话，需要一个专门的decade session replication of service。然后这个service使用了一个比较老旧的，那个库叫什么一时想不起来了，是一个java的several vacation，一个java的in memory database的库。然后我们怀疑是这个库有问题，然后专门请了这个库的德德国的这个库的公司德国分部的人来排查，也没弄出来。然后又把又然后又在一个用户报这个bug的时候，把整个server的那个hip down弄下来，然后开始分析，也没分析出来。",
      "speaker": "发言人1"
    },
    {
      "time": "01:12:55",
      "text": "最后实在没有办法，我出了一个馊主意，就是嗅探那个用户的浏览器agent。如果发现他是在IOS上使用chrome，就不让用户的网站说请你使用safari。因为safari没有这个问题。",
      "speaker": "发言人1"
    },
    {
      "time": "01:13:13",
      "text": "所以safe用户没有出现过的问题，只有I就是chrome IOS有这么一个问题。",
      "speaker": "发言人2"
    },
    {
      "time": "01:13:20",
      "text": "对，chrome上的IIOS上chrome这么有这么一个问题，所以问题也有可能出现在chrome上面对吧？",
      "speaker": "发言人1"
    },
    {
      "time": "01:13:28",
      "text": "但你不知道，你没法我没有办法解释。",
      "speaker": "发言人2"
    },
    {
      "time": "01:13:31",
      "text": "对，这是一直困扰到我今天的一个bug。",
      "speaker": "发言人1"
    },
    {
      "time": "01:13:36",
      "text": "这不是连接层的问题吗？",
      "speaker": "发言人2"
    },
    {
      "time": "01:13:38",
      "text": "我不知道。",
      "speaker": "发言人1"
    },
    {
      "time": "01:13:40",
      "text": "你对这个是没有办法去确切的回答的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:13:44",
      "text": "我不知道。对，而且怎么说呢？其实大部分bug都是你搜一搜就可以搜到的对吧？那再怎么隐秘的bug，你很少有可能你是第一个碰到他的人。但是我搜一下，从没有看到过任和一个人有类似的这么一个问题。这实在是太非常非常伤感的一种感觉。",
      "speaker": "发言人1"
    },
    {
      "time": "01:14:07",
      "text": "所以到现在为止你也没有解决，他也不知道为什么没有解决。",
      "speaker": "发言人2"
    },
    {
      "time": "01:14:11",
      "text": "没有不知道为什么。然后到现在为止，这个网站，这公司的网站还是不允许使用chrome都IOS group登录。我觉得时间一久，可能过上三五年。如果没有人去看文档的话，没有人会意，没有人会知道为什么要这样做，为什么要单单要玩ISA chrome blocked now.",
      "speaker": "发言人1"
    },
    {
      "time": "01:14:35",
      "text": "好吧，wow, the greatest mysteries.",
      "speaker": "发言人2"
    },
    {
      "time": "01:14:40",
      "text": "这是我人生最悲伤的一个。",
      "speaker": "发言人1"
    },
    {
      "time": "01:14:44",
      "text": "然后这个什么链条太长了，你确实很难去，而且这个样本又不？只有3粒是吧？",
      "speaker": "发言人2"
    },
    {
      "time": "01:14:51",
      "text": "对，就3到4个用户受到影响吗？",
      "speaker": "发言人1"
    },
    {
      "time": "01:14:55",
      "text": "对。",
      "speaker": "发言人2"
    },
    {
      "time": "01:14:55",
      "text": "你这个或者说我们知道的只有四个。",
      "speaker": "发言人1"
    },
    {
      "time": "01:14:58",
      "text": "也很有可能什么一个宇宙射线打到你们那个服务器上，然后翻转了一个内存里面的一个比特位，然后导致这个session复制的过程中出现了错误。你也很难说。",
      "speaker": "发言人2"
    },
    {
      "time": "01:15:10",
      "text": "的是，也许对最后发现bug出在太阳黑子上面，我能把。",
      "speaker": "发言人1"
    },
    {
      "time": "01:15:16",
      "text": "他怎么样。",
      "speaker": "发言人2"
    },
    {
      "time": "01:15:19",
      "text": "好吧？然后我在准备这期节目的时候，专门去搜一下有哪些最奇怪或者最有趣的bug。酷上面有这样一个问题，就是what's the hardest bug you have ever debugged？然后排名第一的答案是一个在一个给索尼第一代索尼开发游戏的一个人，他遇到了这么一个bug。就是这个游戏在你储存的时候，有非常小的几率会让你那个PS的存储卡上面的数据被被损坏。就是你存这个游戏的盘的时候，有非常小的概率会导致你那个mary cut mary stick上面所有的存档资料都消失掉。对对对，这没什么。对，那个年纪比较小的听众们可能不知道我在说什么，就是早期的playstation上面是有这么一个小小的像USB插盘的，USB盘的这么一个东西，叫做member stick。你把它。",
      "speaker": "发言人1"
    },
    {
      "time": "01:16:25",
      "text": "插进索尼S索尼自家的U盘接口，不是U盘，是那个SD卡的型号的接口。",
      "speaker": "发言人2"
    },
    {
      "time": "01:16:32",
      "text": "对，然后你把它插到你的play station上面，才可以把你的游戏存盘。然后这个存盘文件是你是你可以自己带在身上。然后这个游戏有可能把这个存盘整个盘给毁掉。也就意味着你不管玩什么游戏，你所有存盘软件都不见，这是很恐怖的一件事。",
      "speaker": "发言人1"
    },
    {
      "time": "01:16:49",
      "text": "然后他们的随着这个deadline逐步逼近，他们的程序员非常恐慌。因为那个时候的playstation是没有playstation network这种东西的。就是你最终压了盘，然后这个盘出去所有人玩。如果有bug，那是没有办法通过在线升级来解决这个bug。然后他们恐慌非常恐慌，然后就开始一点点排除错误，最后他们把游戏精简到了几乎什么都不干，唯一的功能就是登录游戏，然后存盘。即便在这种情况之下，还是有一定几率会有会可能损坏掉的这个记忆卡，然后他们就疯了。",
      "speaker": "发言人1"
    },
    {
      "time": "01:17:36",
      "text": "直到有一天他发现一个人，就是他们的一个美工在他当时比较生气，然后他可能训斥了那个美工。然后那个美工比较nervous的去摆动手柄的时候，游戏正在存盘，此时记忆卡被crap掉了。然后他说什么你对，然后就是他们发现如果你在存盘的时候，下意识的或者说无意识的摆动的那个手柄，你的季卡就会被抹除掉。最后他们发现这个故障是来自于，怎么说呢？就是他们的游戏在打对，他们的游戏在运行的时候，会把PS主机上面的一个精神，就是一个硬件的精振射程比较高的一个频率。然后在这个特定频率之下，有可能这个惊震会干扰到主机上面的另外一个和手柄传输波导率相关的一个芯片，然后使得这个芯片产生了一个特定的bug，然后这个bug会导致记忆卡损毁。这是对这是看起来非常曲折，然后让人捏了一把汗的一个故事，推荐大家去读一读。",
      "speaker": "发言人1"
    },
    {
      "time": "01:19:00",
      "text": "你说你要遇到这，你说我们现在程序员要遇到这种级别的bug怎么办？",
      "speaker": "发言人2"
    },
    {
      "time": "01:19:06",
      "text": "那我觉得真的就一头。",
      "speaker": "发言人1"
    },
    {
      "time": "01:19:08",
      "text": "撞死算了。",
      "speaker": "发言人2"
    },
    {
      "time": "01:19:09",
      "text": "我就好像类似的bug，其实在游戏论坛里面有游戏开发者论坛里面也经常可以看到。比如说曾经有过一个bug，是在第一个场景里面，如果你把如果你用手柄把相机视角转到角色的深厚，整个游戏就会crush。然后他们顶着这个deadline的压力测试了一个月都没有测出来到底是为什么。最后他们的解决方法就是在第一个场景里面编程强制说相机只能保持在侧面的角度，然后一直到跑到安全的地方，才让用户可以把那个视角转到背后。对你像这种bug你没有办法解决的时候，你就真的只能绕开他。",
      "speaker": "发言人1"
    },
    {
      "time": "01:20:01",
      "text": "如果你有压力的话，你之前也干了吗？你直接进了那个chrome for IOS1样的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:20:08",
      "text": "对，这是一些比较专门的。但大部分时候我们遇到的bug其实没有那么复杂。",
      "speaker": "发言人1"
    },
    {
      "time": "01:20:16",
      "text": "真的是因为自己蠢了，不能怪别人。",
      "speaker": "发言人2"
    },
    {
      "time": "01:20:19",
      "text": "不能怪社会。没错。对，其实大部分bug都可以通过一些比较基本的手段被发现。其实最基本的一个就是read code，就是把你刚刚写的东西仔细读一遍，很多时候就已经可以发现这个板到底何在。其实不一定。",
      "speaker": "发言人1"
    },
    {
      "time": "01:20:40",
      "text": "因为它会形成那个思维定式，让你反而一直你反复读也看不出问题在哪里。比较经典，就是那个叫什么来着？因为就像CC加加这种，它不是叫做缩进，是无影无影响的。对，然后你写了一个if忘了打花括号，让你觉得你缩进了后面一排一个block代码，就应该说应该说这个衣服在里面，结果一看没画括号，只有地方被执行。",
      "speaker": "发言人2"
    },
    {
      "time": "01:21:07",
      "text": "没错。我其实在研究生当个助教的时候，遇到过一我遇到过这样一个案例。就是我当时在写那个写就反正写我项目，然后我写节目的地方是学校的一个计算机实验室，然后有两个德国小孩在那儿。不是小孩，就咱两个德国本科生在那边写程序，别人都走了，他们两个还坐在那儿搞。最后他们终于忍不住了，问我说你能过来看一看我们程序到底有什么问题吗？然后看了一下，看了大概三分钟，就说这里缺一个问号。然后他们两个疯了，说我们在这儿坐了4个小时，就是因为这个花括号。",
      "speaker": "发言人1"
    },
    {
      "time": "01:21:54",
      "text": "所以就遇到这种情况，就是说有先不说这个缩进敏感是不是一件好事，至少你像那个go语言，它不是有个自带工具的go for，那个工具可以帮你说表示就是把代码重排成一个标准样式，这样可以一眼看出这种比较愚蠢低级的错误。其实上次你知道那个heart heart bleed，就是那个open s那个大bug出现，其实也是因为类似的原因。还有一个什么，好像是一个double return好像是，然后没有看到，就发现那个检查都根本就没有。从来这么多年过去了，从来没有执行过那个安全性的检查，白搞了。其实也是可以，其实如果你自己自自己看那个代码的原始的形状，你不仔细去想，就我不告诉你这里有个明显的问题的话，怎么也想不到哪里会有这么一个状况，对不对？你看这个代码在公开，就是它是开源的，光天化日存在了那么多年都没有人发现。所以我觉得red code是最低效率的储存的手段。",
      "speaker": "发言人2"
    },
    {
      "time": "01:23:00",
      "text": "但我觉得这个点可能是说如果你有一个比较好的写一小段就回去review一下的习惯的话，其实是对于杜绝这样的bug出现是比较有意义的。当然不是每个人都有这个习惯，但可能这也就是为什么一些比较好的ID会动用静态分析器或者static analyzed的这种东西来。就是说在某种意义上是他帮你读你刚刚写下的代码。",
      "speaker": "发言人1"
    },
    {
      "time": "01:23:31",
      "text": "哼就判断一些模式或者行为之类的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:23:36",
      "text": "没错。",
      "speaker": "发言人1"
    },
    {
      "time": "01:23:37",
      "text": "鱼把你基本的问题解决。",
      "speaker": "发言人2"
    },
    {
      "time": "01:23:40",
      "text": "对，大家喜欢IDE的原因之一就是他会除了语法高亮之外，会告诉你说这个地方看起来好像是不对的。就比如说那个x code的playground，其实就是在不停的静态分析你的代码，然后甚至动态的运行，然后可以帮你及时发现自己写的代码在哪里。",
      "speaker": "发言人1"
    },
    {
      "time": "01:24:04",
      "text": "然后我们说这个什么最其实蛮常用的一个除虫的手段就是打印。",
      "speaker": "发言人2"
    },
    {
      "time": "01:24:12",
      "text": "除虫法对。The good old Price.",
      "speaker": "发言人1"
    },
    {
      "time": "01:24:17",
      "text": "Print f是一个C这个系统标准函数，C里面标准函数打一个字符串对吧？然后一般的做法怎么样子？这就是你在你觉得可能会出问题的那个那个区间，打印一个你认为它应该是某一个数值或者是的一个变量。然后看看是不是在那个时候确实是如你所料的那个数字，然后你可以当一次差多个打印点，或者是打印多个变量，或者是什么结构体之类的，然后看是否如你预期。其实刚才忘了说了，整个过程就是说你形成一个假设，就假设代码在这里出了问题，然后你去验证这个假设是否成立，然后逐一排查的过程。然后这个打印储存法就是做了一个最最原始的方法，就是这么一个过程。",
      "speaker": "发言人2"
    },
    {
      "time": "01:25:09",
      "text": "对，打印出书法第一步是测试这个打印出书法，我是一个打印出来的大师。单元输入法的第一层境界是检测这个代码的分支会不会被运行到。比如说我经常会在javascript里面写council log 1，然后下面一个分支写council log 2，然后再下面一个council 23然后运行。然后去康测里面看，说一二三是不是都打出来了。如果没打出来的话，这段代码根本就没有被运行。",
      "speaker": "发言人1"
    },
    {
      "time": "01:25:39",
      "text": "就是最基本的叫做什么control floor，控制流的检验对。",
      "speaker": "发言人2"
    },
    {
      "time": "01:25:45",
      "text": "然后第二层进阶才是打印一个代码的值，打不是打印一个变量的值。写PHP的人或者。",
      "speaker": "发言人1"
    },
    {
      "time": "01:25:53",
      "text": "什么玩dump数值储存法的，打印数值储存法。",
      "speaker": "发言人2"
    },
    {
      "time": "01:25:58",
      "text": "对，没错。然后这第三层境界可能就是在process的时候，第三层境界就是带低bug的print f就是在代码里面定一个红低版if d版的print，然后这个是print就此生成为了最终代码的一部分。",
      "speaker": "发言人1"
    },
    {
      "time": "01:26:20",
      "text": "你知道打印储存法的抓狂状态是什么样的吗？就是print f括号开，那个引号开。What a fuck. Why did this run here? 然后问号五个感叹号，然后关关关引号，关括号，还忘了个分号就打上去了。",
      "speaker": "发言人2"
    },
    {
      "time": "01:26:40",
      "text": "早就是说早期windows的windows NT还是95的源代码报出来之后，发现里面有很多的print f的段落，都是在诅咒编译器，说傻逼编译器这里又弄错了。希望手工来做什么。",
      "speaker": "发言人1"
    },
    {
      "time": "01:26:53",
      "text": "什么什么。但其实打印输入法的最麻烦的一点就是它需要你专心。如果是静态语言，它需要你重新编译一遍，编译重新就是叫什么，你插入一个打印一句之后，你得保存，然后编译，然后再执行，就每次再重新跑一遍，就比较这个过。如果你什么我的工程项目比较大，然后那个毕业时间比较长的话，你就哭死。",
      "speaker": "发言人2"
    },
    {
      "time": "01:27:22",
      "text": "没错，其实刚才说的三层境界都是非常不推荐的，尤其是第三层境界。就是你如果你真的需要检测print f或者说检测一个程序的输出来验证它是否正确的话。比较mythology logy的方法是用一个比如说log for j这样的库来输出比较正统的记录资料。然后你可以哼使用一些比较相对来说比较高端的功能。比如说区分这个log的等级是warning，是info还是vivo还是error。然后可以记录一下时间，然后可以记有选择性的记录。比如说当时的这个站的情况，或者是堆的情况，或者是乃至于一个变量的值。千万不要简单那种if debug，然后print f这种比较愚蠢的方式。",
      "speaker": "发言人1"
    },
    {
      "time": "01:28:29",
      "text": "所以比较高级的方式是什么？",
      "speaker": "发言人2"
    },
    {
      "time": "01:28:34",
      "text": "我们可以一项一项来来来总结了。最简单的就是我最最具有早期黑客精神的除手工除错工具，其实叫低B低版本低B这么一个小工具，有点类似于dos时代的那个debug dot com还是d bug到第一bug dot点com还是第一bug dot EXE程序。就早期dos下面有一个可以让你直接输入汇编来写程序，乃至于调试其他程序的小小程序的D版dot com。我不知道有没有你有没有印象，有没有用过？没什么。",
      "speaker": "发言人1"
    },
    {
      "time": "01:29:20",
      "text": "dos上面真的没有什么编程的经历。对。",
      "speaker": "发言人2"
    },
    {
      "time": "01:29:23",
      "text": "OK就比这个低bug。Dot com的鼻祖其实就是早期unix下面的一个工具，工具叫做DV也就是低bug的缩机。后来GNU出了一个GNUDB，也就是现在最广为使用的GDB。GDB简单来说就是这么一个程序，它可以你可以让这个程序替你运行你的程序，然后在这个程序在运行的时候，一上来会暂停，或者说根据你调用它的方式不同。因为它你可以让他一上来就暂停，然后告诉他说这个程序运行到某一个特定行的时候，请你停下来，然后我要看一看这个程序现在的状况是什么样。",
      "speaker": "发言人1"
    },
    {
      "time": "01:30:07",
      "text": "然后GDB也是在命令行下运行。运行的方法就是你用你先写GDB，然后后面跟你比如说你刚刚编译好的一个C程序，然后C程序的源码和C程序的那个中间的调试信息也全都在存在当前目录之下。然后你用GDB运调用，你写好程序，然后告诉GDB你要在哪断点，然后在哪调试。所有的指令都是通过键盘输入的。然后你比如说你停你要设置断点，设置点，你要说break at line 31，比如说然后为了简化，你可以把整个没有意义的，没有歧义的指令简化为一个字母。比如说B31就是说在31这个地方放一个端点，然后他运行到31的时候会告诉你说31有了什么。三我已经运行到31了，接下来要干什么？比如说你可以说打印出某一个计算器的纸之类，整个过程有点像玩，我或者应该反过来说，玩玩麻将的过程就有点像这个呃使用一个命令行的这种编辑器，就是你输入一个指令可以看到你周围有什么，然后你再输入一个指令可以决定说你要做什么。",
      "speaker": "发言人1"
    },
    {
      "time": "01:31:22",
      "text": "其实我觉得用这个方法比什么打印储存法最大的优点就在于它不用每次去重新编译。对你的这个程序去加一个打印语句，然后又重新编译跑一段进到那个出错的那个那个环节section。然后再来判断就是它这个是可以在等于是在程序运行过程中动态的去查看它运行的环境，然后是否符合你的假设，对吧？",
      "speaker": "发言人2"
    },
    {
      "time": "01:31:47",
      "text": "没错，所以有了这样的工具，我们就实现了一个非常重要的软件开发的原则。Separation of concern就是你写下来的代码应该只是用于实现你真正想要实现的那些东西，而不是其中有一部分的功能是用来让你检测这个程序是不是在正确运行。这就是一个调试工具的意义。然后对GDP其实直到今天都还有人用。而且在其他所有的语言里面，几乎所有的这样有用的语言里面，都有这么一个命令行下面调试的工具。比如说python DB叫做PDB，然后还有i python也有这么一个专门让的人用来做交互式的命令行下的第八工作的一个库，叫做IPDB，这些都是相当好的东西。",
      "speaker": "发言人1"
    },
    {
      "time": "01:32:45",
      "text": "Reo你用过吗？就你你你写拍子用会会用debugger，偶尔用。那其中20%的时间里面。",
      "speaker": "发言人1"
    },
    {
      "time": "01:32:54",
      "text": "对，偶尔会用PDP.",
      "speaker": "发言人2"
    },
    {
      "time": "01:32:55",
      "text": "但你觉得。",
      "speaker": "发言人1"
    },
    {
      "time": "01:32:57",
      "text": "它好用吗？看情况，它有些情况是用不了的。我印象中就是它得插入一个PDP，它在启动的时候，它会在某一个地方插入一个断点，引入PDB，然后执行你进入那个PDP那个环境那个点，完了之后你就回到那个正常运行了。然后就是你要如果就不能比较灵活的换到其他的那个断点里面去检测另外一堆的状态。",
      "speaker": "发言人2"
    },
    {
      "time": "01:33:26",
      "text": "我觉得其实对我来说运行调试工具，包括不管是PDP也好，GDP也好，最大的问题是都太难记了。因为太什么太难记，就是所有的指令都太难记住了。而且每次用的时候都要打开一个menu在那边查，说接下来我要干嘛。",
      "speaker": "发言人1"
    },
    {
      "time": "01:33:48",
      "text": "显那显然是因为你用的还不够多。",
      "speaker": "发言人2"
    },
    {
      "time": "01:33:51",
      "text": "对我我可能跟你差不多，就是有百分之最多有20%的时间在堤坝。然后在堤坝的时候我就可能大学的时候好稍微好一点，大学的时候还能记住一部分指令，但是到现在真是尤其是在用一门已经很长时间没有用过语言的时候，然后要用要去用一个命令。航向的地板真的是哼要我亲命。",
      "speaker": "发言人1"
    },
    {
      "time": "01:34:14",
      "text": "所以这个时候你知道你需要什么吗？这个时候你。",
      "speaker": "发言人2"
    },
    {
      "time": "01:34:20",
      "text": "需要cheat OK.",
      "speaker": "发言人1"
    },
    {
      "time": "01:34:23",
      "text": "做壁纸，你再打印一张常用快捷键的东西贴墙上，不是是不是贴墙贴那个屏幕周围，他能够一眼看得见什么时候该哪个指令。",
      "speaker": "发言人2"
    },
    {
      "time": "01:34:35",
      "text": "我以前其实桌子上专门有一个文件盒，是专门拿来放各种cheat shit。对，什么CCL cheat shirt，regular expressions, cheat v然后还有对各种各样ID的这些。现在这所有这些纸应该都已经发黄了，效果并不是非常的对。",
      "speaker": "发言人1"
    },
    {
      "time": "01:34:57",
      "text": "我我我是有一个在桌面上有个快捷方式，一个文件夹叫cheat sheet，然后里面各种各样的常用的一些工具的一些具体包括什么编辑器的快捷键，AGPP什么的code.",
      "speaker": "发言人2"
    },
    {
      "time": "01:35:13",
      "text": "这个文件夹我一直都有，而且这个文件夹被我命名为flight manual。飞行手册。对。",
      "speaker": "发言人1"
    },
    {
      "time": "01:35:28",
      "text": "对。",
      "speaker": "发言人2"
    },
    {
      "time": "01:35:29",
      "text": "这个不错。对，但是怎么说呢？并没有什么卵用。最终我还是转向了，至少在第一把这件事情上，我还是转向了图形界面的第8个OK。",
      "speaker": "发言人1"
    },
    {
      "time": "01:35:45",
      "text": "然后对有些什么高级的介绍一下，也不算高级。",
      "speaker": "发言人2"
    },
    {
      "time": "01:35:50",
      "text": "至少比如说我们刚才介绍的这个鼻祖级的GTV，其实它有一个图形化界面叫做滴滴滴滴滴滴。对，是一个x window的x windows的GDB的前端。哼然后我上次用滴滴滴滴滴滴可能也是在上读研究生的时候，因为研究生毕业就再也没有写过C程序了。",
      "speaker": "发言人1"
    },
    {
      "time": "01:36:18",
      "text": "当时觉得滴滴最大的一个卖点就是它可以把一些比较常用的数据结构，用图形化的方式表现出来。比如说你写了一个单向链表，他分析了之后可以把你的链表用一个一个的方框画出来。然后告诉你说这个链表的指针指向了这个链表上的节点的指针指向了另外一个节点，然后诸如此类。当然大部分时候他还是被拿来用做那个低低bug，就是至少在滴滴上面你可以用鼠标点了。你说我想在这一行设一个点断点，你点那行，然后点一下设置，设置点就可以了。终于可以不愿意去记那些单个指令的这些第一版的命令了。对，这是你最大的一个麦。",
      "speaker": "发言人1"
    },
    {
      "time": "01:37:07",
      "text": "所以其实你看到这些情况下，就怎么说，就用的没有像编辑器那么勤快的功能。有一个图形的方式去让你不用记住快捷键还是挺好的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:37:19",
      "text": "对我觉得其实一个独立的有图形界面的d bug，配合一个专一的用来写程序的编辑器是一个挺好的组合。Union x unix的哲学之一不就是做一件事情，而且对把这件事情做好。那我用一个编辑器专门来写程序，然后用另外一个低bug专门来低bug其实也挺好。",
      "speaker": "发言人1"
    },
    {
      "time": "01:37:49",
      "text": "包括很多人会说我想要把我的vim打造成一个ID1。但这其实在某种程度上就背离了vim当初被开发出来的一个应用场景。你不如就好好的把它当做编辑器来用。然后等你真正需要去调试的时候，你跳到另外一个程序里面去调试就好了。因为在vim里面，你跟命令行的距离其实就只有一个control加Z而已。不是，对。",
      "speaker": "发言人1"
    },
    {
      "time": "01:38:21",
      "text": "说到这个wave，我最近做了一个比较疯狂的事情。",
      "speaker": "发言人2"
    },
    {
      "time": "01:38:25",
      "text": "说来听听，我已经系好安全带了，说来听听。",
      "speaker": "发言人1"
    },
    {
      "time": "01:38:29",
      "text": "我把那个之前不是很多，这也他们代码颜色高亮，我把它调到最基本的模式了，就只会标出注释用了斜体，然后那个叫字符串用的是一个另外的颜色。对，然后其他的那些高亮的颜色都关掉了。",
      "speaker": "发言人2"
    },
    {
      "time": "01:38:55",
      "text": "还是name里面是不是有一个默认的theme叫做Green还是叫什么？就是它对它用不同灰度的绿色来显示关键字。对我想问一个win默认的主题叫什么？就叫default。",
      "speaker": "发言人1"
    },
    {
      "time": "01:39:16",
      "text": "对，就叫default。",
      "speaker": "发言人2"
    },
    {
      "time": "01:39:18",
      "text": "OK我记得早期学到的比较重要的一个trick就是在某些情况下，你可能SSH到另外一台主机上面的时候，发现那台主机和你的终端模拟器的配色不匹配。然后你终端模拟器里面可能紫色特别的暗，或者是蓝色特别暗。根本看不清楚那个远端服务器上这个代码到底是什么的时候，就在vim里面打set，color sim f lord就是精灵领主。这个是然后在99%的情况之下，它会使得你能够看清楚，在defauts的性质下看不清楚的代码。这是一个。",
      "speaker": "发言人1"
    },
    {
      "time": "01:40:09",
      "text": "这是什么原因？",
      "speaker": "发言人2"
    },
    {
      "time": "01:40:11",
      "text": "没有什么原因，就是不是就是f law的这个sim的所有的颜色都比较鲜艳，可能是这个OK对，明白。然后没有那些dark blue之类的这种颜色，会使得你的终端模拟器如果那个色彩模式没有调对的话，会把那个远程服务器上的蓝色显示的特别暗。",
      "speaker": "发言人1"
    },
    {
      "time": "01:40:37",
      "text": "我到现在为止还没找到那个单色的。不过反正我现在就是基于一个叫做e ink的这个色叫color scheme改的就是OK，这个代码注释会是一个灰色的，就是浅一点的颜色会浅灰色，然后是协体的，然后那个字符串会是斜体的，然后其他都是一个默认的黑色的字，没有其他颜色。因为他叫e ink，你还是有原因的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:41:09",
      "text": "就有电子墨水的效果。",
      "speaker": "发言人1"
    },
    {
      "time": "01:41:12",
      "text": "说到这里，你用的什么。",
      "speaker": "发言人2"
    },
    {
      "time": "01:41:14",
      "text": "配色我的配色是一个经过改动的mono卡。",
      "speaker": "发言人1"
    },
    {
      "time": "01:41:22",
      "text": "看是不是很仙。那个版本。",
      "speaker": "发言人2"
    },
    {
      "time": "01:41:28",
      "text": "我其实不是很清楚这个编辑配色的鲜艳的标准是什么？我反正现在用的是一个自己改过的model OK.",
      "speaker": "发言人1"
    },
    {
      "time": "01:41:36",
      "text": "然后moon卡是一个暗暗的暗色背景的吧？",
      "speaker": "发言人2"
    },
    {
      "time": "01:41:41",
      "text": "上次我以前一直在用solar ze就是那号称科学配色法科学配色的sales。但是怎么说呢？就用过一段时间之后，我发现在强在那个侧面是我的光线比较强情况之下，会很容易看清楚。",
      "speaker": "发言人1"
    },
    {
      "time": "01:42:03",
      "text": "对，它的那个contrast就是对比度是不高的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:42:06",
      "text": "对比度比较它对比度比较低的，我觉得这太注重美感了，因为漂亮是漂亮，但是用多了是感觉不是很好。然后solarz还有一个问题，就是它在256色的情况之下，表现不是非常好啊。我试过很多很多方法，试图让vim在terminal模式之下使用比较正确的或者比较养眼的solar它的配色，然后发现要改很多很多东西。首先你的terminal的那个term这个字符要改，这个长环境变量要改，然后vim里面的4秒改color 4秒改，然后有可能你还要在bash一上来的时候，运行一个脚本，来设定某些我不是非常清楚他到底干了什么的一些tricks，才可以把颜色设定的比较正确，这也挺痛苦的。Moon看就没这个问题。",
      "speaker": "发言人1"
    },
    {
      "time": "01:43:09",
      "text": "SOS它那个的主要问题是它它默认的那个就是terminal那个council的色盘会跟其他的非常不一样。",
      "speaker": "发言人2"
    },
    {
      "time": "01:43:18",
      "text": "对他会逼着你去改那个色环，你会把前十六色改成完全另外一种。",
      "speaker": "发言人1"
    },
    {
      "time": "01:43:24",
      "text": "对场景的。然后改了之后会有一个问题，就是兼容别的那种非service的色盘的话就会有点问题，经常能看那个字儿。",
      "speaker": "发言人2"
    },
    {
      "time": "01:43:34",
      "text": "就看不见了。没错，就比如说你装，如果你用SOS的官方解决方案，把你的那个item 2的调色盘改了。此时你在用比如说blue，blue有时候会用不同颜色来告诉你说这个package是下载完了，还是出错之类的。此时候你会发现所有这些颜色都变了，就可能本来是一个绿色的对勾，现在变成了白色。对，非常注意。",
      "speaker": "发言人1"
    },
    {
      "time": "01:44:04",
      "text": "所以其实说到这里，要刚才问那个你用暗色背景的话，你在那个文档和这边之间切换的时候，眼睛不会觉得那个突然一一明一暗的很。",
      "speaker": "发言人2"
    },
    {
      "time": "01:44:14",
      "text": "只有在夜里会有这个问题，就是在深夜里面写代码的时候会有这个问题。",
      "speaker": "发言人1"
    },
    {
      "time": "01:44:20",
      "text": "不对，白天其实这个问题更更严重，因为其实你看白天都环境都是亮的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:44:27",
      "text": "我觉得夜里比较夜，夜里这种切换的场景的时候，你眼睛会疼，但是白天就还好。如果你的背景足够亮的话，白天这个问题就没有那么的突出。我觉得对。",
      "speaker": "发言人1"
    },
    {
      "time": "01:44:39",
      "text": "但是你如果背景比较亮的话，你那个叫什么？你看那个黑色代码区就很成问题了。因为你这个时候是要放大你的瞳孔去focus到那个，因为黑暗色底的话，它字是是白的，字是亮色的，它的光线是比较少的。这个时候你要放大瞳孔才能够接收到足够的光去辨识它。但与此同时，你的这个环境的光照是很高的，这个是有很多这种周围的环境，你刚受到你的瞳孔里面去，其实对这个是挺对眼睛是挺伤的对。",
      "speaker": "发言人2"
    },
    {
      "time": "01:45:15",
      "text": "会引发眼部疲劳。我同意你的观点，不过我可能另外一个原因就是我对这个事情不是特别敏感的。就是我有两个显示器，然后那个文档放在一个显示器上，编辑器的另外一显示器编辑器永远是黑的OK就所以。",
      "speaker": "发言人1"
    },
    {
      "time": "01:45:32",
      "text": "其实这一点那个solar的一个好处就是它是有暗色和亮色两个版本的那我的当时的方案就是说你会这样说的，我的方言里面就是我当时想的就是说如果我环境很暗，我就用那个暗色版本的环境很亮，亮色版本后来发现基本上都是很亮的环境，所以就一直是用那个亮色版本，就light那个那个版本。",
      "speaker": "发言人2"
    },
    {
      "time": "01:45:57",
      "text": "对我也我也在vim里面绑定过快捷键，就是按一下快按个FF9，我记得还是什么的。可以在亮色模式和暗色模式之间切换，但后来觉得还是觉得蛋疼，算了吧。",
      "speaker": "发言人1"
    },
    {
      "time": "01:46:13",
      "text": "OK, 所以还有刚才吐槽那个那个颜色的问题，也不其实你不觉得现在这种terminal，或者说看for这种东西，它处理这个色彩那些都是方式都非常ancient，非常原始。",
      "speaker": "发言人2"
    },
    {
      "time": "01:46:32",
      "text": "都是历史遗留问题。我觉得就我们今天还在使用terminal simulation这件事情，其实仔细想想就很不可思议了。每个人都对每个人都知道common line非常重要，或者至少在目前common line的还是没有被人扔到历史的垃圾堆里，但从来没有一个人能够成功的重新发明一遍轮子，然后把把CLI做的好一点。",
      "speaker": "发言人1"
    },
    {
      "time": "01:47:01",
      "text": "那个命令行本身我觉得是问题不大，但是我们现在那个实现方式真是太古老了。比如说像刚才说要实现那个文字，要通过输出字符来各种转译。然后甚至连最底层的你在在linux上面去做一个council接口，像有什么虚拟的什么TTY设备。真是对我其实我。",
      "speaker": "发言人2"
    },
    {
      "time": "01:47:22",
      "text": "指的就是这件事情，就是我们知居然还在使用这么古老的，可以追溯到1970年代的terminal simulate。这我这可能这个地方还是可以对这个对历史不是特别大我也不是属于的。听众们介绍一下，就是我们现在使用的那个黑黑的，我可以敲文字进去的。",
      "speaker": "发言人1"
    },
    {
      "time": "01:47:46",
      "text": "学学编程莫名其妙一定都要用到这个terminal。其实是在模拟70年代的电传打字机。如果你一定要追溯到源，就是源头，在就是说在显示器这个东西出现之前，计算机是通过打印机就直接连在一个打印机上，往纸上输出东西。然后这个东西的最基本的运作机理，比如说SK码之类的这种东西一直都原封不动的被继承到了今天。",
      "speaker": "发言人1"
    },
    {
      "time": "01:48:20",
      "text": "然后我们当显示器出现了之后，一开始也是只能像电传打字机一样，一次编辑一行的内容。然后这一行的内容编辑完了，你按一下回车，才会把这一行的内容出现输出在显示器上。直到我们现在习惯了这种vim你打开wam之后，光标从会在三个光标还是在左上。对，光标从你当前行跳到左上，并且你可以跳到任意一行。这样你多按几次回车，你就可以跳到任意一行，然后再跳回来。这种特性都已经是非常高端的特性了。",
      "speaker": "发言人1"
    },
    {
      "time": "01:48:55",
      "text": "在在这个单色显示器的时代，你可以想象说早期单色显示器的时代，那些电脑键盘上是没有方向键的，为什么呢？因为你爱情发际线没有什么卵用，你根本不可能把光标跳到上面一行或者下面一行。因为你你的电脑就只理解当前行业内容。而我们现在使用的这样一个小的terminal simulate，这么一个APP，其实是在原封不动的模拟这些70年代的技术。而我们这对此也都是司空见惯的，就从来没有人想过要把它当然好我必须承认说plan nine其实是已经解决了这个问题了。但是就像我们知道的plan 9，因为它太好了，所以它不可能流行起来。",
      "speaker": "发言人1"
    },
    {
      "time": "01:49:42",
      "text": "我们就这是一个悲伤的歌。",
      "speaker": "发言人2"
    },
    {
      "time": "01:49:45",
      "text": "doomed to live in the ancient world ah. 吐了好多。",
      "speaker": "发言人1"
    },
    {
      "time": "01:49:54",
      "text": "这个绕的有点远。",
      "speaker": "发言人2"
    },
    {
      "time": "01:49:55",
      "text": "对还可以把圈子兜回来。",
      "speaker": "发言人1"
    },
    {
      "time": "01:49:58",
      "text": "接着讲第八个的事情，我们之后有时间再再来探讨这个问题，我觉得还有挺多有意思的事情可以去讨论。",
      "speaker": "发言人2"
    },
    {
      "time": "01:50:08",
      "text": "可能从另一个方侧面讲说，为什么terminal simulator这么多年以来一直没有进展。一个原因也就是windows或者说图形化界面实在是发展的太快了。人们没有时间会停下来回过头去把好好好好的把这个命令行界面的承载的容器改变一下。因为如果你要去问这个世界上到底是使用IDE的写程序的人多，还是使用命令行写程序的人多？我觉得一个比较合理的推断是肯定是用IDE的写程序的人多。",
      "speaker": "发言人1"
    },
    {
      "time": "01:50:46",
      "text": "就是使用一个压倒性多数。",
      "speaker": "发言人2"
    },
    {
      "time": "01:50:48",
      "text": "对，压倒性99%以上的人是在用IDE写上去的。想反驳这件事情的人，首先要想到有很多人他不是专业的程序员，但他仍旧必须通过某种工具来编程序。你让他们去使用命令行是非常不人道的好吗？比如说刚才节目一开始提到那个研究脑科学的赵赵晨博士，他是他他你为什么要逼他去用命令行写进去的对吧？或者是一些乃至广义上的写这个office里面的VA basic baby script的人都可以在一种对使用比较他所使用工具都可以用，都可以当做一种广义上的IDE来看待。",
      "speaker": "发言人1"
    },
    {
      "time": "01:51:33",
      "text": "对，没错。",
      "speaker": "发言人2"
    },
    {
      "time": "01:51:35",
      "text": "那什么是A一呢？有一个解法就是integrated debug environment，也就是IDE这个工具最重要的功能之一，就是帮助你地板ID.",
      "speaker": "发言人1"
    },
    {
      "time": "01:51:48",
      "text": "E板做环境。是对他。",
      "speaker": "发言人2"
    },
    {
      "time": "01:51:50",
      "text": "把他把你的editor和项目管理工具和版本控制工具，以及最重要的一个低bug接低bug工具集成在一起，才孕育出了这么一个非常好用的IDE环节。所以real你是即便现在也是会不会在公司里面不用IDE了吗？问题有点绕，就是你现在仍旧哪怕是在工作的时候也不用爱你吗？",
      "speaker": "发言人1"
    },
    {
      "time": "01:52:24",
      "text": "我自己是不用ID的，但我看有些其他的人他们会用一些东西去写。当然你知道现在因为现在没写APP是显学，对吧？就是各种应用显学，这个时候你就不得不用这个什么，比如说x code吧？你逃不掉。对。",
      "speaker": "发言人2"
    },
    {
      "time": "01:52:42",
      "text": "然后x code当然是一个比较极端的例子，他逼迫你用这个。",
      "speaker": "发言人1"
    },
    {
      "time": "01:52:48",
      "text": "对，那其他你也没得太多选。比如说你写这个java应用，你跑不掉eclipse者jet brain之类的对吧？",
      "speaker": "发言人2"
    },
    {
      "time": "01:52:56",
      "text": "那我觉得java的可选的ID还是蛮多的，就net但是。",
      "speaker": "发言人1"
    },
    {
      "time": "01:53:00",
      "text": "可选的ID是很多。但是他们都是用IDE写的，很少见用vim写java的人。",
      "speaker": "发言人2"
    },
    {
      "time": "01:53:07",
      "text": "OK有问题。SO的人因为是比较对。",
      "speaker": "发言人1"
    },
    {
      "time": "01:53:14",
      "text": "然后还有就是那个visual studio这个系列的，基本上也是比较少用这个唇编辑器。",
      "speaker": "发言人2"
    },
    {
      "time": "01:53:22",
      "text": "写的对，我在知乎上看到过一个说法，就是说c shop和java之类的都是叫什么，面向IDE的编程语言。他们从设计之初就是考虑到这个语言一定要在IDE里面被写才比较没错，才比较正常。所以他们才不会去考虑什么那个方法的名称太长，或者是关键字太长之类的问题。",
      "speaker": "发言人1"
    },
    {
      "time": "01:53:50",
      "text": "对，反正有自动补齐。",
      "speaker": "发言人2"
    },
    {
      "time": "01:53:52",
      "text": "没错。比如说intel gal一定要写成intel gal不像不像C里面写个int或者是比如说一开始说到那个print f就刚学编程的时候，你想过F代表什么？就是你你刚才说的时候，你说这个函数是系统的一个函数，它可以输出一个字符串。当时其实我想纠正你说不对，输出字符串是put s那个S才代表string，而print f的F代表的其实是format，就是print f这个函数最大的功能是让你输出一些内容，然后这个内容是有一个特定的format，所以它叫print f但是如果是一个面向编IDE的编程语言的话，它此处一定会不吝字符数的，把这个方法命名命名为output service with mats。对也。与此类似的，比如说还有什么s print f第一个S代表什么呢？代表string，就是把把formats的内容输出到另外一个字符串。",
      "speaker": "发言人1"
    },
    {
      "time": "01:55:08",
      "text": "其实这些早期的黑客们为了节省时间，以及没有IDE的种了的状况，导致于导致他们开发了这么一套非常简略的语言，也对早期学编程的人造成了很一定的障碍。就是有些人他他可能不是不习惯那种一上来说，我给你个例子，你先别管三七二十一，你把它敲出来，然后做别的，一步一步学下去再说。他可能一上来就会说就会想要明白说这个main到底是干什么，这个int到底是干什么的，然后这个print f的F代表到底代表什么。然后如果他在一上来学的时候，这些在他看来非常基本的细节都找不到答案的话，他很快就没有兴趣了。我觉得我早期就是这样。",
      "speaker": "发言人1"
    },
    {
      "time": "01:56:01",
      "text": "有点看起来有点cropt那个那个代码。对，密文刚刚有点漏说了，就是那些命名这么短，除了有没有ID的这个自动补齐的功能以外，还有一个更很重要的点，应该跟刚才我们讲的扯了那堆的一个terminal有关系。就是早期的那些council宽度比较有限，那就80个字符或者是60个字符这样。它如果那个方法名特别长的话，看了一行就悲剧了。一行可能就写一个函数，还写不调用，还写不完。对，只有这么一个考虑在里面。后来有了ID都是在这个故意的话，就是图形界面的情况下，那个宽度就可以比较有限，就有这个富余了。而且像现在那个什么用的那个开发用的屏幕动辄什么1920宽甚至更多，对吧？所以这个完全不是问题。",
      "speaker": "发言人2"
    },
    {
      "time": "01:56:51",
      "text": "没错。另外一个原因就是早期的电传打的那个不是电传，早期的终端是一个就是等于是一只有一个键盘和一个显示器。然后你按一个键，这个键用这个键按下去的电视信号要需要先传到服务器上，然后再传回来，才会在你的中央显示器上显示一个字符出来。这个过程是比较慢的。如果你把一个函数设计的太长的话，你可能敲到一半发现自己敲错了一个字符。然后要按竖着自己按回车的那个次数，然后算自己按到了一个自己应该删掉哪个字符停下来，这个过程是非常缓慢。",
      "speaker": "发言人1"
    },
    {
      "time": "01:57:33",
      "text": "所以这个其实在现代我也能体会到，就这个过程。",
      "speaker": "发言人2"
    },
    {
      "time": "01:57:37",
      "text": "对，有时候你在使用终端。",
      "speaker": "发言人1"
    },
    {
      "time": "01:57:40",
      "text": "写你就那个SSH的时候，你就说连一个比如说你现在在德国，你连一个假设新西兰的服务器。",
      "speaker": "发言人2"
    },
    {
      "time": "01:57:49",
      "text": "我有一段时间那个服务器在日本，就这个状况非常。",
      "speaker": "发言人1"
    },
    {
      "time": "01:57:56",
      "text": "你会发现打一个字儿等一秒才出现。对，再打一个字又等一秒才出现。也是因为这个SSH这种工具，还是就刚刚讲的是来自于历史这种交互方式。就是你想就按我们正常一个想法，你在本地打一个字，为什么会要等到服务器传过来确你才会会把它显示出来，对不对？就是很奇怪。但是这就是来自那些legacy的东西。",
      "speaker": "发言人2"
    },
    {
      "time": "01:58:21",
      "text": "对早期的一些智能终端也就有了这么一个所谓的local echo的这么一个功能。就是你按了一个键，它现在本地帮你把它显示在服显示器上，然后等到那个服务端传回来确认字符的时候，你这边已经看到结果了。是的，这已经是早期的一个终端模拟器的卖点。",
      "speaker": "发言人1"
    },
    {
      "time": "01:58:45",
      "text": "对，说到这里，就这里安利一个挺好用的工具，叫做mosh .",
      "speaker": "发言人2"
    },
    {
      "time": "01:58:49",
      "text": "MO.",
      "speaker": "发言人1"
    },
    {
      "time": "01:58:49",
      "text": "SH mobile SSH。就是它能够解决刚才说的一些问题。对，是他是通过一个叫什么来着？",
      "speaker": "发言人2"
    },
    {
      "time": "01:58:57",
      "text": "MIT做的。",
      "speaker": "发言人1"
    },
    {
      "time": "01:58:58",
      "text": "对，MMIT的一个学生做的。然后他这个工具就比较好去搞，就解决那种在高延迟连接情况下，你用SS去刚才打一个字，等半天才会出现的那个问题。还要通过一些叫做本地的the predictive的算法，就是预测性的算法，先把那些字给打出来，然后等服务器的响应。然后服务器如果响应对没错，他就按那个就不用改了，对吧？那如果没想出来有问题，那可能再再更新成服务器那个东西。所以有时候你会遇到会跳，但是说你至少能够保证你在输入这个命令的过程中是比较流畅的一个体验。",
      "speaker": "发言人2"
    },
    {
      "time": "01:59:34",
      "text": "对，而且它还很屌的一点就是你用laptop办公，然后你打到一半把laptop的盖子合上了，然后再打开。比如说你在咖啡馆你要挪个座位，然后如果你用普通的SSH的话，此时你就已经断掉了，对吧？",
      "speaker": "发言人1"
    },
    {
      "time": "01:59:50",
      "text": "但如果你用STCP连接已经没有了吗？",
      "speaker": "发言人2"
    },
    {
      "time": "01:59:53",
      "text": "对，如果你用mosh的话，它会自动帮帮你重新连起来，是非常爽的一件。",
      "speaker": "发言人1"
    },
    {
      "time": "01:59:59",
      "text": "对，因为它底层是用那个UDP来实现，它是一个无连接的通讯协议。这样的话就可以让你就是roaming，就所谓的漫游可以换埃批，换那些都可以实现的。然后就整个特别是在现在什么有些人人在外面用4G办公，就可能会遇到这种状况。就在四季和wifi之间切换的时候，会遇到这种情况比较久。",
      "speaker": "发言人2"
    },
    {
      "time": "02:00:22",
      "text": "对，所以in case you haven't，一定要拥有它。",
      "speaker": "发言人1"
    },
    {
      "time": "02:00:27",
      "text": "一定要去跟大家强烈安利。",
      "speaker": "发言人2"
    },
    {
      "time": "02:00:34",
      "text": "所以你的同事们有在用IDE的吗？除了SOY等等，你现在写什么python吗？",
      "speaker": "发言人1"
    },
    {
      "time": "02:00:44",
      "text": "我现在写歌，写够的话一般还是用编辑器的。多少头用那个ID的还是比较少。",
      "speaker": "发言人2"
    },
    {
      "time": "02:00:52",
      "text": "所以购物语言现在是没有一个签订的，官方签订的。",
      "speaker": "发言人1"
    },
    {
      "time": "02:00:59",
      "text": "没有有有那个那个叫那个roll pack，自己那个编辑器叫acco.",
      "speaker": "发言人2"
    },
    {
      "time": "02:01:05",
      "text": "action就我们介绍过的，也是planner的一部分。",
      "speaker": "发言人1"
    },
    {
      "time": "02:01:08",
      "text": "对对对，这个算是就什么呢？就是算亲儿子。但是其实除了他和以前planner贝尔实验室那几个人在用这个资料，好像外面的人用的比较少，因为他那个确实比较诡异。",
      "speaker": "发言人2"
    },
    {
      "time": "02:01:23",
      "text": "比较含口。",
      "speaker": "发言人1"
    },
    {
      "time": "02:01:24",
      "text": "对对对，就刚才我讲它是首先没有这个语法高亮，然后它是一个proportional fund，就是等就是非等宽字体的一个环境。上次也讨论过这个问题，是比较奇怪的。",
      "speaker": "发言人2"
    },
    {
      "time": "02:01:37",
      "text": "然后还要记住左键、右键、中键点起来是什么感觉。",
      "speaker": "发言人1"
    },
    {
      "time": "02:01:42",
      "text": "对对对，没错。之前我在知乎的时候，因为知乎之前很多是用那个python写的，今天我发现有有几个同事是用那个叫做python。",
      "speaker": "发言人2"
    },
    {
      "time": "02:01:53",
      "text": "对。",
      "speaker": "发言人1"
    },
    {
      "time": "02:01:54",
      "text": "这算是一个python的提升开发环境，就是I第一了，它是是吧。",
      "speaker": "发言人2"
    },
    {
      "time": "02:01:59",
      "text": "对他就。",
      "speaker": "发言人1"
    },
    {
      "time": "02:02:00",
      "text": "对那些什么debug ing的时候好像做的还可以。",
      "speaker": "发言人2"
    },
    {
      "time": "02:02:06",
      "text": "没错，pym最好用的地方就是第八个。应该说在拍M出现之前，python的官方和python的defector的最好来的是什么呢？有吗？",
      "speaker": "发言人1"
    },
    {
      "time": "02:02:23",
      "text": "是啊有吗？没有吧。",
      "speaker": "发言人2"
    },
    {
      "time": "02:02:26",
      "text": "PCP也只是一个编辑器而已。",
      "speaker": "发言人1"
    },
    {
      "time": "02:02:31",
      "text": "对，他们不算ID没有I没有就动态语言基本上用ID的会比较少。",
      "speaker": "发言人2"
    },
    {
      "time": "02:02:38",
      "text": "对，感觉那个时候人都只是在用某种能够组织一系列文件的。比如说像那个一时想不起来名字，就是在那个sub line出现之前，大家都喜欢用text mate。",
      "speaker": "发言人1"
    },
    {
      "time": "02:02:56",
      "text": "对，还有一个麦克风，很老的那个BBB.",
      "speaker": "发言人2"
    },
    {
      "time": "02:03:00",
      "text": "B edit OK你说。",
      "speaker": "发言人1"
    },
    {
      "time": "02:03:03",
      "text": "那个那个我从来没有用过OK。",
      "speaker": "发言人2"
    },
    {
      "time": "02:03:06",
      "text": "我其实刚学我刚学python的时候用的是I6 plus。就是曾经跟你说过一个小红记事本的一个icon的windows上的编辑器，不知道现在。",
      "speaker": "发言人1"
    },
    {
      "time": "02:03:19",
      "text": "还在不在OK这样。然后其实你看，像比如说现在你用企业javascript的话，好像没有什么I.",
      "speaker": "发言人2"
    },
    {
      "time": "02:03:30",
      "text": "D可以用jasp。Visual code其实就是一个很少的很很好的jaso BIT。",
      "speaker": "发言人1"
    },
    {
      "time": "02:03:38",
      "text": "不他他那个算IDE吗？还是算一个编辑器好吧？",
      "speaker": "发言人2"
    },
    {
      "time": "02:03:44",
      "text": "X code我觉得其实visual student code是一个介于IDE和编辑器之间的东西。因为ID能做的事情它基本上都能做。比如组织一堆文件，然后设定一个项目被执行时候的各种参数以及地板。",
      "speaker": "发言人1"
    },
    {
      "time": "02:04:06",
      "text": "对，其实现在我你你现在他出的一些很多比较新型的编辑器，其实都有或多或少带有一定的这个ID的属性了吗？",
      "speaker": "发言人2"
    },
    {
      "time": "02:04:15",
      "text": "没错，就是这种强化的编辑器，它是某种介于纯粹的文本编辑器和ID之间的状态，我觉得这挺好，就轻量级的工具挺好。",
      "speaker": "发言人1"
    },
    {
      "time": "02:04:26",
      "text": "哼你说对，怎么我们又扯到ID上去了。",
      "speaker": "发言人2"
    },
    {
      "time": "02:04:33",
      "text": "因为IDE是一个很重要的DY工具。OK对，然后刚才说到java script，其实大部分时候给javascript debug的最好的工具。",
      "speaker": "发言人1"
    },
    {
      "time": "02:04:48",
      "text": "就是浏览器本身那个开发者工具栏。",
      "speaker": "发言人2"
    },
    {
      "time": "02:04:52",
      "text": "没错。",
      "speaker": "发言人1"
    },
    {
      "time": "02:04:52",
      "text": "就在我的IE里面按F12是吧？",
      "speaker": "发言人2"
    },
    {
      "time": "02:04:56",
      "text": "没错，在IE，IE是从九代才有F12的，在哼在九代出现之前，我们都指认F5。",
      "speaker": "发言人1"
    },
    {
      "time": "02:05:09",
      "text": "算了，等一下那个F5算是网页版的打印除虫方法。",
      "speaker": "发言人2"
    },
    {
      "time": "02:05:16",
      "text": "没错，F5其实就是一个叫什么刷新机构。对。",
      "speaker": "发言人1"
    },
    {
      "time": "02:05:22",
      "text": "reload.",
      "speaker": "发言人2"
    },
    {
      "time": "02:05:24",
      "text": "对。",
      "speaker": "发言人1"
    },
    {
      "time": "02:05:25",
      "text": "就跟什么加入打印语句之后，重新reload一下，看那个地方到底会不会出现那个东西吗？",
      "speaker": "发言人2"
    },
    {
      "time": "02:05:31",
      "text": "没错。",
      "speaker": "发言人1"
    },
    {
      "time": "02:05:32",
      "text": "然后这个网页里面就是把那个java cripe或者是CSS起码改一下，看一下，是不是在那个章如如意料之内长出现一个位置，然后打了一个东西出来。",
      "speaker": "发言人2"
    },
    {
      "time": "02:05:44",
      "text": "对，乃至于像什么live guard这种，帮你按F5的工具，就是你只要存了盘，它就帮你按下F5。",
      "speaker": "发言人1"
    },
    {
      "time": "02:05:53",
      "text": "对，这个还叫什么？这个还挺高级的一个工具，叫什么auto refresh是吧？",
      "speaker": "发言人2"
    },
    {
      "time": "02:05:58",
      "text": "对，其实这个就是命的一种形式。",
      "speaker": "发言人1"
    },
    {
      "time": "02:06:02",
      "text": "对我上次忘了是什么，是angular还是react还是什么，一个发现一个前端工具的框架，它竟然还就是现在流行说自带一个叫做auto reload的server，就是一个node jessy的一个一个一个一个server。然后它会插往你那个网页里面代码插一些一个一段特别的java和代码。然后它会维持一个叫什么来着，web socket或者是HGP的，让长长连接。然后探测到你那边保存了那个东西之后，它会通过那个传连接通知服务器手动通知你的浏览器自动刷新那个代码。我这个方法我看了一眼，我也是醉了。",
      "speaker": "发言人2"
    },
    {
      "time": "02:06:44",
      "text": "Bracket，就是你说的是bracket，就是那个写。",
      "speaker": "发言人1"
    },
    {
      "time": "02:06:48",
      "text": "前端就很很多有有好几个都是这种，都是这框架的一些帮助的工具，都是通过这种方式来实现的。",
      "speaker": "发言人2"
    },
    {
      "time": "02:06:57",
      "text": "Expresso也是这样的，我记得。",
      "speaker": "发言人1"
    },
    {
      "time": "02:07:01",
      "text": "对，没错。",
      "speaker": "发言人2"
    },
    {
      "time": "02:07:03",
      "text": "我好像还装了一个叫什么cold case，我已经好久没有打开过了。",
      "speaker": "发言人1"
    },
    {
      "time": "02:07:08",
      "text": "然后后来是什么？那个chrome还是横空出世，带了一个叫做council。对，这个工具。",
      "speaker": "发言人2"
    },
    {
      "time": "02:07:15",
      "text": "对，这其实是他的一个工具。",
      "speaker": "发言人1"
    },
    {
      "time": "02:07:18",
      "text": "对，叫做inspector，最早的那个东西。对，然后就可以什么就像那个debug那样，可以动态修改网页中的某个结构。",
      "speaker": "发言人2"
    },
    {
      "time": "02:07:28",
      "text": "而是可以让你停在某一行代码上的。",
      "speaker": "发言人1"
    },
    {
      "time": "02:07:31",
      "text": "没错。",
      "speaker": "发言人2"
    },
    {
      "time": "02:07:32",
      "text": "而且不用论点，实在是太人性化。没错，对我觉得我记得当初切换到chrome，可能也就是因为这个inspector的功能实在是要比firework强太多了。",
      "speaker": "发言人1"
    },
    {
      "time": "02:07:49",
      "text": "然后其实现在，现在那个chrome的那个开发者工具就是inspector，应该是在目前为止是在像sfa，还有firefox你们之间最强大的一个。",
      "speaker": "发言人2"
    },
    {
      "time": "02:08:02",
      "text": "我觉得是这样，但是肯定有听众觉得不是这样的。但我反正最近也没有怎么用过。",
      "speaker": "发言人1"
    },
    {
      "time": "02:08:08",
      "text": "肯定是这个firefox那个firebug.",
      "speaker": "发言人2"
    },
    {
      "time": "02:08:13",
      "text": "的死忠不。现在firefoot其实自带一个低bug工具了，就不再一他就是。",
      "speaker": "发言人1"
    },
    {
      "time": "02:08:19",
      "text": "把那个发bug整合进去了。",
      "speaker": "发言人2"
    },
    {
      "time": "02:08:23",
      "text": "OK，是这么来的，我记得。",
      "speaker": "发言人1"
    },
    {
      "time": "02:08:25",
      "text": "对，是这样的，我没记错。因为当时开发者都不愿意用那个far fox，就是因为那个chrome的开发者，那个inspector工具实在太好用了。看不到什么模这样就感觉到危机了，赶快把这个，因为之前发尔鲍以前以以前都是一个非官方第三方的插件，对吧？对他毕竟不是亲儿子，做起来还是没有那么顺手。然后后来不行，看不下去了，还是整合进来。没错，然并卵。",
      "speaker": "发言人2"
    },
    {
      "time": "02:08:56",
      "text": "对，为时已晚。现在应该是并列以VC为基本的为基础的brothers市占率强过该口。",
      "speaker": "发言人1"
    },
    {
      "time": "02:09:08",
      "text": "对对对，现在不是还有那个，你看那个叫做上次我们前期讨论的那个react native这种逆天的玩意儿，它竟然能够在chrome的那个inspector里面去实时修改跑在IOS上面的一个应用，你敢信吗？",
      "speaker": "发言人2"
    },
    {
      "time": "02:09:25",
      "text": "对，实在是太awesome，说的awesome。",
      "speaker": "发言人1"
    },
    {
      "time": "02:09:30",
      "text": "因为以前那个那个IOS还要重新reload，还要再传一下，传到真机里面才可以重试，对吧？它就可以通过远程的方法直接修改chrome的语言的一个状态，然后能够通瞬间同步到，不叫瞬间同步，它就是直接是那个怎么理解呢？就是IO上面那个应用渲染的结构是来自于chrome里面这个inspector的结构。",
      "speaker": "发言人2"
    },
    {
      "time": "02:09:56",
      "text": "对。",
      "speaker": "发言人1"
    },
    {
      "time": "02:09:57",
      "text": "反正挺黑科技的。",
      "speaker": "发言人2"
    },
    {
      "time": "02:09:59",
      "text": "没错，总之前端开发者实在是太幸福了。小米之家你看这些做服务端的人，就低bug的是实在是没有什么趁手的低bug的工具。当然也跟问题的领域有关。因为前端的东西是比较容易所见即所得的，而后端的东西很多时候是没有什么东西是可以直观可见的，不是吧？就你你做了一个对你做了一个高并发，可以及时适应用户暴涨的这么一个服务，你怎么把它所见即所得？就是整个测试过程是没有办法，整个堤坝排查的过程是没有办法用一个只需要按一个键就可以完成的工具来来来实现。",
      "speaker": "发言人1"
    },
    {
      "time": "02:10:50",
      "text": "对，而且现在很多这种大的这种应用，它都是跨系统的，它不是一个单一进程的东西。叫叫什么来着？Google那个APP engine你知道吗？那个跑的云服务那个平台。对，当时不是，最好是今年出了一个什么叫做好像是叫做cloud debugging，叫做云除虫。意思就是说你的当你的应用程序跑在不止一台机器，甚至不止一个数据中心的情况下，你怎么去统筹多个进程，多台机器协作产生才能产生的一个bug，是吧？其实想想还是挺蛋疼的。",
      "speaker": "发言人2"
    },
    {
      "time": "02:11:27",
      "text": "非常尴尬。而且有时候一个程序崩溃了，前端只需要简单的把程序再跑一遍就可以了。可是后端你可能唯一能拿到的东西就是一个大的，也就是这个程序它它挂掉的时候，那个车祸现场，然后你要像一个法警一样。",
      "speaker": "发言人1"
    },
    {
      "time": "02:11:51",
      "text": "法益还原真相是。",
      "speaker": "发言人2"
    },
    {
      "time": "02:11:53",
      "text": "就试图通过现场的一点点蛛丝马迹还原出这个案情是怎么发生的。然后只能做一个术语叫什么post mode。就是死后的这样一个尸检，你没有办法让整个车或再发生一遍，这是一这也是非常痛苦的而且耗时的一件事情。因为core dump，不管是core dump还是heat dump还是什么整个环境memory dump都是非常巨大。而且需要非常敏锐的观察力和精力才能搞定的事情。",
      "speaker": "发言人1"
    },
    {
      "time": "02:12:28",
      "text": "没错，而且你遇到那种就是你还不能用的什么打印出重法。因为第一个你没法打印到某一个具体的地方去，你可能就什么c slog要汇总，对，你的顺序都是错的。然后各个阶段的时间它也不一定是完全同步的对吧？对。",
      "speaker": "发言人2"
    },
    {
      "time": "02:12:45",
      "text": "根本就没有什么卵可以打。",
      "speaker": "发言人1"
    },
    {
      "time": "02:12:49",
      "text": "再然后就是如果你重启一个服务，可能它那个如果你是一个小就是micros有微服务的价格可能还行，重启一个服务问题不是很大。你看现在很多什么写那个游戏的那种server，就是游戏的服务器，他好像光预热这个数据集可能就要好几分钟。",
      "speaker": "发言人2"
    },
    {
      "time": "02:13:09",
      "text": "重启一次。对。",
      "speaker": "发言人1"
    },
    {
      "time": "02:13:12",
      "text": "那你就哭。",
      "speaker": "发言人2"
    },
    {
      "time": "02:13:13",
      "text": "没错。或者那些搞大数据分析的人，你说他们怎么才能测试自己显示这个东西，对不对？这个算法可能有一些非常难以解决的问题，他们可能要等上几个小时甚至几天的时间把整个数据再跑一遍，这是唯一的方法，就没有别的可以动态去调试的方法。",
      "speaker": "发言人1"
    },
    {
      "time": "02:13:35",
      "text": "对，所以其实最最理想的那个状态是什么r line的那那套东西，就2 line里面它那些每个它的小的紫线，紫禁城是可以独立重启的。然后可以它可以动态登录到那个程序运行态里面去，动态修改局部代码。然后局部重启就是不用重启整个程序，你局部可能更新一个函数，更新一个紫禁城，那紫禁城然后再跑起来非常方便，非常牛逼的。",
      "speaker": "发言人2"
    },
    {
      "time": "02:14:08",
      "text": "听起来不错，所以你我是对爱尔兰没有任何了解，好像而且不知道为什么也没有任何兴趣。",
      "speaker": "发言人1"
    },
    {
      "time": "02:14:17",
      "text": "因为他那个其实运那个是就所谓的这个运营商级别的一个环境。就是他运营商比如说你不可能说我这个电话交这个交换系统坏了，我会把整个停机，然后来检修，然后重启，尝试看有没有出充错。不可能因为你你电话停机了，那就是什么就会造成重大社会危机的，没错。",
      "speaker": "发言人2"
    },
    {
      "time": "02:14:41",
      "text": "对吧？Eric是谁？搞出来爱立信。",
      "speaker": "发言人1"
    },
    {
      "time": "02:14:44",
      "text": "还是爱立信？对，eric language.",
      "speaker": "发言人2"
    },
    {
      "time": "02:14:47",
      "text": "这个也是。",
      "speaker": "发言人1"
    },
    {
      "time": "02:14:49",
      "text": "应该是最好的一个出可以出重的环境。这其实像大部分的其他的语言写的代码都是不可以除那种局部除重的。所以在同一进程里面我也都不可以的。",
      "speaker": "发言人2"
    },
    {
      "time": "02:15:08",
      "text": "List好像有部分是可以，至少最早的那个list不是可以登录进去，可以改动态修改，就这个时候要求它是一个动态语言。对，就是必须静态。就编译型语言就基本没戏了，就已经被排除在门槛，就不用再想了。原理上就不支持这一点是吧？动态语言其实也就比较少，主要是一些函数式的语言有望支持这一点。",
      "speaker": "发言人2"
    },
    {
      "time": "02:15:32",
      "text": "对，是然后后端的做后端的人或者是做独立APP的人，做或者是做一个比较需要在一段时间里面查看这个程序跑起来有没有问题的人，可能还会用到一个低bug的一个变种，就叫做profile或者profile to。就这个东西可以把一个程序包括在一个受到监控的运行环境里面。然后看这个程序的运行过程中，会不会有一些比如说响应太慢，或者是内存泄露之类的问题。这些东西也可以视为一个广义上的低版本图。",
      "speaker": "发言人1"
    },
    {
      "time": "02:16:18",
      "text": "比如说命令行下面有叫V是一个其实是虚拟机。就是它它会把一个C程序在这个虚拟机里面运行，然后每运行一步就告诉我说这个程序运行的运行到这儿有没有，是不是已经扔出了一个。比如说这已经被已经没有办法被找到了一个区内存区域。又比如说s code里面也有专门的profile tube，然后你可以让你一个APP在一段时间内运行，然后它会甚至是这种图形化的话方式会告诉你说这里漏了一个KB数据，这里漏了几KB的数据。然后一些可能你跑上一两分钟没问题的，跑上1个小时之后就会crush你，不知道为什么。然后你用profile一看，他原来一直在泄露程序，泄露内存，然后泄露了1个小时之后，你的i ipad终于没有内存了，所以它也就坏了。",
      "speaker": "发言人1"
    },
    {
      "time": "02:17:17",
      "text": "对，没错。",
      "speaker": "发言人2"
    },
    {
      "time": "02:17:19",
      "text": "然后有时候就是你如果你写ISF的时候，有时候你在调试过程中，它会有哐当给你跳了一大堆汇编代码里面，你说你这个时候应该怎么办。",
      "speaker": "发言人1"
    },
    {
      "time": "02:17:31",
      "text": "是吗？",
      "speaker": "发言人2"
    },
    {
      "time": "02:17:32",
      "text": "是啊，对。",
      "speaker": "发言人1"
    },
    {
      "time": "02:17:33",
      "text": "就是太难死了，所以我我是不会我是不会汇编。",
      "speaker": "发言人2"
    },
    {
      "time": "02:17:40",
      "text": "的这我也不能说会汇编。但是在这种情况下想想，基本上你都知道，你其实只要一步一步跳下去，或者说你只要把断点设在一个比较正常的地方，然后一步一步跳。你找到自己要跳进汇编之前的那一步，就知道问题出在哪儿。倒不是特别的严重，其实我只是想说有些离bug会把你引领到这个地方。就是刚才还是高等语言，突然一下子跳到了这个会班里会编，你应该怎么办？",
      "speaker": "发言人1"
    },
    {
      "time": "02:18:14",
      "text": "对，这种情况下，其实我觉得还是有必要稍微学一点会变的。就是至少你不用知道，你不用把所有的指令背下来，你也不用能有有能力去呃逆向工程，或者是纯用汇编来写一个3D加速程序之类的。这些功能的技巧你至少要了解一些。比如说calling convention是什么，就costa是什么，然后这些东西你可以了解一些最基本的汇编的概念。对于低bug其实也有帮助。",
      "speaker": "发言人1"
    },
    {
      "time": "02:18:53",
      "text": "所以今天大概把调试这一块总结一下，纵览了一下，我觉得调试技术不管再怎么重要，还是没有办法抵过养成一个良好的编程习惯来的。更重要一点。就比如说我们前面也提到了，可以程序可以分为两种，一种是先确定编辑条件，然后写代码。另外一种是先写代码，然后去找让这个代码能够正确工作的边界条件是什么？是两种截然不同的态度。也许后一种态度会让你对于所有的低bug工具都了如指掌，但从严格意义上来说，还是有前一种习惯对你的帮助更大一点。",
      "speaker": "发言人1"
    },
    {
      "time": "02:19:40",
      "text": "行，这一期录了也有两个多小时，可能最终剪出来没有这么多。因为我们中途也遇到了若干技术故障，但这一期总算也是达到了长度。我上一期发现你们的IT攻略也在也在跟也在拼长度，这样对吗？",
      "speaker": "发言人1"
    },
    {
      "time": "02:20:01",
      "text": "根本停不下来。",
      "speaker": "发言人2"
    },
    {
      "time": "02:20:04",
      "text": "到底发生了什么？我在听的时候，我其实一开始的时候我就说我靠这一期怎么看起来这么长，结果听出听了之后发现真的这么长，而且你们好。",
      "speaker": "发言人1"
    },
    {
      "time": "02:20:13",
      "text": "很不习惯是不是？",
      "speaker": "发言人2"
    },
    {
      "time": "02:20:18",
      "text": "好的，那您刚刚收听到的是IPN podcast网络旗下的IT技术节目内核恐慌。IPN旗下的其他六档podcast包括soft call，技术主题节目IT公论，医疗主题节目太医来了，美食主题节目为指导，艺术主题节目流行通讯、无主题节目无次元，故事主题节目history以及影像主题节目影像。同样欢迎收听，欢迎你为我们的节目捐款，捐款地址是IPN dot IOS flash kero panic slash date。捐款金额随意，只要是能够被八整除的正整数就可以。上一次我们的上一次我嗓子毁了之后，恳求各位捐款，然后好像的确有几笔娟进来，但每一笔都是8美元。非常感谢各位。虽然捐款不会为你带来什么，不捐也不会你失去什么。我们的口号是no hot feelings，感谢你收听本期节目，下期再会。",
      "speaker": "发言人1"
    },
    {
      "time": "02:21:20",
      "text": "拜拜。",
      "speaker": "发言人2"
    }
  ],
  "lab_info": {
    "summary": "本期播客“内核恐慌”聚焦软件开发中的除错与调试问题，三位嘉宾分享了各自在知乎、Facebook和谷歌的工作经历中遇到的复杂bug案例。讨论覆盖了从游戏场景中的相机视角问题导致的崩溃，到用户账户信息错乱的疑难杂症，以及游戏存档数据丢失等具体问题。嘉宾们强调了在面对难以解决的bug时，通过社区论坛寻找相似案例解决方案的重要性，以及学会绕开问题、利用代码审查、测试用例编写和现代编程工具如静态代码分析和IDE来辅助解决问题。此外，还讨论了调试技巧，包括使用打印语句、断点和高级工具如GDB等，以及保持耐心和创造性思维的重要性。最后，强调了良好的编程习惯对于预防bug的重要性，并讨论了不同编程语言和框架对调试的影响，整体强调了除错在软件开发中的核心地位和面对挑战时的多种策略和工具的使用。",
    "qa_pairs": [
      {
        "question": "在没有源码的情况下，如何知道One Password不是一个密码专业盗窃器呢？对于听众提出的关于One Password可信度的问题，依据哪些因素认为其可信？",
        "answer": "如果无法查看源码，确实很难确信任何密码管理软件的安全性。但一般用户可以采取一些措施，如观察软件的输入输出行为，甚至尝试反编译其可执行文件来查看是否存在网络调用等。然而，对于大部分理智的人来说，如果对安全性要求极高，可以选择使用开源软件，并确保硬件也符合开放标准，这样能有一定的保障。不过，在现实情况下，完全确保每个步骤都被审计几乎是不现实的，因此很多时候只能选择相信某个厂商或公司，例如苹果。没有具体的源码可供验证，所以无法绝对证明One Password的安全性。但用户可以对其输入输出进行观察分析，并考虑厂商的信誉和公开承诺。对于高度怀疑的用户，可以采用更为极端的安全措施，如使用完全开源的软件和硬件，但这种方式相对麻烦且不适用于所有人。",
        "time": "00:04:58"
      },
      {
        "question": "为什么选择相信苹果而非One Password呢？",
        "answer": "选择相信苹果是因为苹果公开表示不销售用户隐私信息、不植入后门，并且一直以来坚持良好的道德观念。虽然不能完全排除所有风险，但基于对品牌的信任以及其可能面临的巨大商誉损失，从以往表现来看，苹果是值得信赖的。",
        "time": "00:07:23"
      },
      {
        "question": "是否所有重要的信息都会数字化存储，并且存储在One Password中？",
        "answer": "One Password不一定是存储所有重要信息的最佳选择，尤其是对于安全等级较高的财务相关信息，用户可能更倾向于在本地或通过其他加密方式存储。但如果选择One Password，那么应当相信其安全性，并且遵循其推荐的安全实践，例如使用两步验证、定期更换密码等。",
        "time": "00:13:31"
      },
      {
        "question": "如果一个网站使用了相同的密码注册多个账号，当这个服务数据库被爆破后，攻击者可以做什么？你如何防止这种情况发生并保护自己的账户安全？",
        "answer": "攻击者可以利用获得的信息逐一尝试同一套密码在其他同类服务中的使用情况，从而连带攻陷多个账户。我采取的方法是为每个网站创建不同的密码，并且不频繁更换密码。即使某个网站因被脱库而导致密码泄露，由于每个服务的密码不同，所以换不换密码在这个时候并无太大区别。此外，我会在重要服务上开启两步验证功能。",
        "time": "00:14:35"
      },
      {
        "question": "你使用的两步验证工具是什么？",
        "answer": "我在iOS上安装了一个名为Offer的应用，它可以与Google Authenticator或Apple's two-factor authentication配合使用。尽管最初设想通过蓝牙连接电脑上的OC插件以获取验证码，但实际操作中发现仍需手机配合。后来我发现利用iOS的通知中心功能，可以直接在手机上快捷访问并输入验证码，比较方便。",
        "time": "00:16:11"
      },
      {
        "question": "还有哪些硬件因素可以增强账户的安全性？",
        "answer": "硬件因素主要包括银行提供的U盾，它内置私钥用于签名验证，而非生成密码；另一种是ISC公司的USB密码器，它每15到30秒会显示一个随机数字序列，通过声音接口（如手机音频插口）输入这些数字来验证身份；还有一种屏幕闪烁二进制纹样，通过摄像头捕捉并识别生成密码。",
        "time": "00:19:17"
      },
      {
        "question": "SSH登录服务器时，你是选择密码还是私钥认证？",
        "answer": "对于服务器登录，我倾向于使用私钥认证，但对于某些临时情况，如通过iPad等设备必须SSH登录时，我会选择密码登录。私钥认证方法解决了身份认证和密码登录两个问题，但在推广上面临用户理解和接受程度的挑战。",
        "time": "00:23:43"
      },
      {
        "question": "这次曝光的漏洞主要是在哪个工具上发现的？",
        "answer": "这个严重的漏洞是在flash上发现的，是一个臭名昭著的flash zero day漏洞。",
        "time": "00:29:27"
      },
      {
        "question": "这个漏洞的危害性具体是什么？",
        "answer": "这个漏洞让任何网站在用户访问并运行其flash内容时，可以在用户机器上以管理员权限执行任意代码，这意味着用户的个人信息、短信、邮件等所有数据都将面临泄露风险。",
        "time": "00:29:40"
      },
      {
        "question": "这些安全漏洞是如何被私下买卖并用来黑进别人电脑的？对于这次漏洞泄露的情况，普通人能做些什么保护自己？",
        "answer": "安全漏洞确实可以私下交易，不法分子利用这些漏洞去黑进他人的电脑，而很多人因为侥幸心理或者缺乏意识并未及时安装补丁来防护。普通人应该尽快安装紧急发布的patch来修补漏洞，并且要意识到安全问题的严重性，不再轻视任何可能的安全威胁。",
        "time": "00:30:42"
      },
      {
        "question": "这次事件对普通用户意味着什么？",
        "answer": "意味着之前认为只会影响重要人物的数据安全问题，现在发现其实普通人也可能受到严重影响。而且，一旦漏洞被公开，好人和坏人都可能利用它，所以用户需要更加重视自身安全防护。",
        "time": "00:30:42"
      },
      {
        "question": "苹果公司是否会针对此次曝光的漏洞采取行动？",
        "answer": "苹果公司尚未明确表态会专门成立小组研究并修复这些公开的漏洞，但可以期待他们对此有所动作，不过具体时间未知，用户在此期间可能仍处于风险之中。",
        "time": "00:33:04"
      },
      {
        "question": "在信息安全方面，我们应该如何面对？",
        "answer": "面对复杂的信息安全风险，我们不得不选择相信某些人或某些机构，并承担相应风险。同时，社会生活中的许多方面也需要我们去信任他人，而无法完全避免风险。因此，在享受便利的同时，我们也必须接受信息安全上的挑战。",
        "time": "00:40:57"
      },
      {
        "question": "1.0版本能否打开一个20兆的文件？",
        "answer": "不知道，我还没装，但似乎无法做到。",
        "time": "00:45:13"
      },
      {
        "question": "这些程序存在哪些问题？",
        "answer": "它们都有一个问题，即比较臃肿，比较占资源。",
        "time": "00:45:15"
      },
      {
        "question": "对于用C写的古老编辑器为何能存活至今的原因是什么？",
        "answer": "主要是因为它们资源占用相对较少，且功能稳定。",
        "time": "00:45:53"
      },
      {
        "question": "web技术封装成原生APP的看法如何？",
        "answer": "支持这种做法，但要注意与传统浏览器内的web应用的区别，尤其是离线状态下运行的设计。",
        "time": "00:46:32"
      },
      {
        "question": "web app与native app的主要区别是什么？",
        "answer": "主要区别在于用户对应用类型的预期以及离线状态下的行为设计。",
        "time": "00:46:32"
      },
      {
        "question": "对于Chrome框架的看法是什么？",
        "answer": "Chrome框架试图打破用户对于在浏览器中使用非原生应用的心理预期。",
        "time": "00:47:08"
      },
      {
        "question": "对atom这类编辑器的感觉如何？",
        "answer": "感觉淡化了其网页应用的属性，使用时很难察觉其非原生性。",
        "time": "00:48:11"
      },
      {
        "question": "web app是否代表较差的体验？",
        "answer": "web app并不必然代表糟糕体验，使用某些技术可以实现类似原生应用的体验。",
        "time": "00:48:54"
      },
      {
        "question": "关于使用racket或scheme语言为VR环境构建教学语言的想法有何看法？",
        "answer": "认为这是一个很有趣的想法，类似于用logo语言在虚拟现实环境中搭建组件。",
        "time": "00:50:16"
      },
      {
        "question": "是否期待在VR环境中通过增量修改代码来操作物件？",
        "answer": "非常期待，因为 scheme 语言支持动态修改代码并部分执行。",
        "time": "00:52:44"
      },
      {
        "question": "对于微软Hololens视频的感受是什么？",
        "answer": "视频展示了实际效果与之前宣传的有很大差距，主要由于光学元件物理限制和续航等问题。",
        "time": "00:55:00"
      },
      {
        "question": "程序员在写代码过程中，调试时间与实际编码时间相比如何？",
        "answer": "根据个人经验，调试时间可能占到了编码时间的两三倍左右，尤其对于非复杂项目来说。",
        "time": "00:57:46"
      },
      {
        "question": "在软件开发过程中，你是否遇到过那种感觉自己快完成了，但实际上还需要很多时间去调整细节的情况？",
        "answer": "是的，我遇到过这样的情况。比如有个程序员朋友总觉得自己还有20%的工作要做，但实际上这20%的工作占据了整个开发过程中80%的时间。",
        "time": "01:00:35"
      },
      {
        "question": "程序员在写代码之前，你是提倡先思考再动手还是直接敲代码？",
        "answer": "我倾向于先思考再动手。真正的高效程序员会在写代码前，在脑海中构建整个大框架和步骤，确保思路清晰后再开始编写代码，而不是边敲键盘边思考。",
        "time": "01:01:21"
      },
      {
        "question": "是否有某种工具或状态有助于程序员更好地构思程序？",
        "answer": "类似literate programming（文化编程）的理念，提倡在写第一行代码前先写出整体思路，就像写作文一样，在不同时间和场合都可以思考内容，等把握住方向后再动手编程。",
        "time": "01:03:39"
      },
      {
        "question": "“低版”这个词是怎么来的？",
        "answer": "“低版”这个词来源于美国海军准将Grace hopper的故事，她在1950年代因一只蛾子导致计算机故障后，将蛾子粘在故障记录上并写下了“这只蛾子导致了整个机器故障”。而“堤坝”这个词在1940年代左右就已经在其他领域使用，后来在60年代左右才在计算机界推广开来。",
        "time": "01:04:01"
      },
      {
        "question": "你遇到过什么比较有意思或者困扰你的bug吗？",
        "answer": "曾经遇到过一个串台bug，它在特定运营商网络下才会出现，由于无法重现和定位故障条件，花费了很多时间和努力都没有解决。",
        "time": "01:07:43"
      },
      {
        "question": "是否有无法解决且影响严重的bug案例？",
        "answer": "曾经在一家博彩公司工作时，遇到一个bug，即IOS设备用户登录公司网站时，有万分之1到101‱的概率看到他人账户，这是一个非常严重的问题，但由于难以重现和定位，最终只能通过限制用户使用Chrome在IOS上登录来规避此bug。",
        "time": "01:09:46"
      },
      {
        "question": "在PlayStation早期没有网络升级功能时，程序员面临什么问题？",
        "answer": "由于PlayStation没有PlayStation Network，一旦游戏盘片发行后，如果出现bug，无法通过在线升级解决。程序员们非常恐慌，只能通过精简游戏功能来降低风险，确保在登录游戏和存盘时不会导致记忆卡损坏。",
        "time": "01:16:49"
      },
      {
        "question": "游戏bug是如何被发现并定位的？",
        "answer": "一个美工在受训斥后不小心在存盘时摆动了手柄，导致记忆卡损坏，从而发现了这个问题。进一步研究后，他们发现游戏运行时产生的高频震动干扰了主机上的一个芯片，该芯片与手柄传输波导率相关，最终导致记忆卡损坏。",
        "time": "01:17:36"
      },
      {
        "question": "遇到这种级别的bug时程序员该怎么办？",
        "answer": "这种情况会让程序员感到困惑和压力，有时只能绕开问题，采取临时解决措施，例如在游戏中设定相机视角等限制，以避免触发bug。",
        "time": "01:19:09"
      },
      {
        "question": "如何预防和发现这类低级错误？",
        "answer": "可以通过仔细阅读代码（read code）来发现错误，同时可以使用IDE工具如Go语言自带的代码格式化工具帮助识别缩进错误等低级问题。此外，良好的编程习惯，如编写完一小段代码后进行review，以及使用静态分析器，可以在一定程度上杜绝这类bug出现。",
        "time": "01:21:54"
      },
      {
        "question": "打印法是如何帮助定位bug的？",
        "answer": "打印法是在认为可能出错的代码段插入print()函数打印变量值或预期结果，通过观察实际输出是否符合预期来验证假设，逐步排查问题。然而，这种方法较为原始且低效，需要重新编译和运行程序多次。",
        "time": "01:24:17"
      },
      {
        "question": "除了打印法，还有哪些更高效的调试手段？",
        "answer": "更高效的调试手段包括使用像GDB这样的调试工具，它可以在程序运行过程中动态查看其状态和环境，无需每次重新编译和插入打印语句。通过命令行界面设置断点、查看变量状态等功能，大大提高了调试效率，并遵循了软件开发原则中的Separation of Concern（关注点分离），使代码更加专注于实现功能本身而非调试功能。",
        "time": "01:31:47"
      },
      {
        "question": "运行调试工具时，你遇到的最大问题是什么？",
        "answer": "我觉得运行调试工具时最大的问题是它们的指令太难记了，每次使用时都需要打开菜单查找接下来要执行的命令。",
        "time": "01:33:26"
      },
      {
        "question": "对于不常使用的编程语言，你是如何应对这种情况的？",
        "answer": "我会在桌面上创建一个名为“flight manual”的文件夹，里面包含各种编辑器的快捷键和工具的快捷方式，但这种方法并没有特别有效。",
        "time": "01:34:57"
      },
      {
        "question": "是否有使用图形界面的调试工具来帮助记忆和操作？",
        "answer": "是的，例如GDB有一个图形化界面叫DDD，它能以图形方式展示数据结构，如单向链表等，并且可以通过鼠标操作设置断点，无需记忆单个指令命令。",
        "time": "01:36:18"
      },
      {
        "question": "是否推荐使用独立的图形界面调试工具和专用编辑器？",
        "answer": "我认同这种组合方式，因为这样可以专注于各自领域并做好。比如用一个编辑器专门写程序，另一个图形界面的调试工具来调试。",
        "time": "01:37:19"
      },
      {
        "question": "你最近做了什么与vim配色相关的事情？",
        "answer": "我把vim的颜色高亮设置调整到了最基础模式，只保留注释和字符串的不同颜色，关闭了其他高亮颜色。同时，为了在不同主机间切换时看清代码，我使用了一个名为e ink的颜色方案。",
        "time": "01:38:29"
      },
      {
        "question": "你使用的vim配色方案是什么样的？",
        "answer": "我现在使用的是一经过改动的monokai卡，之前尝试过solarized，但发现其对比度问题以及对不同环境下的适应性不足，因此选择了更符合个人需求的颜色方案。",
        "time": "01:42:06"
      },
      {
        "question": "如何看待现在终端模拟器处理色彩的方式？",
        "answer": "认为现在处理终端色彩的方式非常原始且古老，尤其是考虑到计算机技术的发展，但仍必须使用这类模拟1970年代电传打字机的技术，这确实令人感到不可思议。",
        "time": "01:46:13"
      },
      {
        "question": "为什么terminal simulator这些年没有太多进展？",
        "answer": "一个主要原因是因为图形化界面（如Windows）发展得太快，人们没有时间去改变命令行界面的承载容器。此外，使用IDE写程序的人数远超过使用命令行的人数，大约是99%以上的比例。",
        "time": "01:50:08"
      },
      {
        "question": "那么IDE的重要性体现在哪些方面呢？",
        "answer": "IDE通过集成debug environment（IDE的重要功能之一），将editor、项目管理工具、版本控制工具以及bug追踪工具等整合在一起，为程序员提供了非常好用的开发环境。",
        "time": "01:51:35"
      },
      {
        "question": "现在工作中是否还会用到非IDE工具？",
        "answer": "虽然我自己不使用IDE，但在工作中有些人仍会选择用其他工具编写代码，例如用Xcode编写iOS应用，或者使用Eclipse或JetBrains等IDE来编写Java应用。",
        "time": "01:51:50"
      },
      {
        "question": "早期编程语言的设计是否考虑了IDE因素？",
        "answer": "是的，早期的一些编程语言如C和Java从设计之初就考虑到它们需要在IDE中编写，因此在命名和语法设计上都充分考虑了IDE的自动补全功能和屏幕宽度限制，以提高开发效率。",
        "time": "01:53:22"
      },
      {
        "question": "早期终端设备对编程体验有何影响？",
        "answer": "早期终端设备的交互方式较慢，导致编程体验不佳，比如输入一个字符后需要等待服务器确认才能看到显示结果。而现代图形界面下的IDE解决了这个问题，并提供了更流畅的编程体验。",
        "time": "01:56:51"
      },
      {
        "question": "是否推荐使用Mosh工具？",
        "answer": "强烈推荐使用Mosh，它能解决高延迟连接下SSH使用时出现的延迟问题，通过本地预测算法提前显示输入内容，即使在网络不稳定或设备切换时也能保证连接的稳定性。",
        "time": "01:58:58"
      },
      {
        "question": "在前端开发中，有哪些工具或框架具有自动刷新网页代码的功能，它是如何实现的？",
        "answer": "这种功能是通过一个叫做auto reload的server实现的，它实际上是一个Node.js服务器。这个服务器会向网页中插入特殊代码，利用Websocket或H2GCP协议维持长连接状态。当检测到用户保存了代码后，服务器会通过这个连接手动通知浏览器自动刷新代码。",
        "time": "02:06:02"
      },
      {
        "question": "你提到的auto reload功能是哪个框架或工具实现的？",
        "answer": "这个功能是由一个不确定的前端工具框架实现的，可能包括了像Bracket、Expresso和Cold Case等工具。",
        "time": "02:06:48"
      },
      {
        "question": "Chrome浏览器的开发者工具有什么特别之处吗？",
        "answer": "Chrome浏览器的开发者工具，尤其是其Inspector工具，功能非常强大，可以动态修改网页结构，并且支持停在某一行代码上，使用起来非常人性化。它比其他一些工具如Firebug更为强大。",
        "time": "02:07:18"
      },
      {
        "question": "现在业界中哪个开发者工具被认为是最强大的？",
        "answer": "根据讨论，目前Chrome的开发者工具（Inspector）被认为是在Firefox的Firebug和其他工具中最为强大的。",
        "time": "02:07:49"
      },
      {
        "question": "对于后端服务端开发者，他们使用的调试工具和前端开发者相比如何？",
        "answer": "后端开发者所使用的调试工具不如前端直观便捷，比如服务端高并发服务的测试过程无法轻易通过一键式工具完成，而遇到问题时往往需要进行长时间的数据分析、日志排查，甚至核心dump分析等，过程繁琐且耗时。",
        "time": "02:09:59"
      },
      {
        "question": "对于跨系统应用的调试，有什么挑战和困难？",
        "answer": "跨系统应用调试的挑战在于，由于前后端分离，前端出现问题可以轻松重载页面，而后端服务端调试则需要更复杂的方法，例如云调试（Cloud Debugging），因为程序可能在多个进程、机器甚至数据中心中运行，难以统筹和定位问题。",
        "time": "02:10:50"
      }
    ],
    "chapters": [
      {
        "time": "00:00:00",
        "title": "内核恐慌：IT技术与哲学思维的碰撞",
        "summary": "本期节目中，我们探讨了从技术话题到哲学问题的广泛内容。节目开场，主讲人分享了自己在康复过程中的经历，幽默地讨论了感冒带来的不便和现代社会对疾病传播的担忧。随后，对话转向了未来科技的可能，如数字化生命的存在形式，引发了对生存和意识定义的深入思考。节目中还提出了邀请脑科学专家探讨相关话题的建议，并对听众的反馈表示期待。"
      },
      {
        "time": "00:02:51",
        "title": "探讨密码管理器的信任与安全性",
        "summary": "讨论集中在如何在没有源代码的情况下信任密码管理器，例如One Password，以及个人如何存储高安全等级的信息。讨论者提到，无法通过审查源代码来确保密码管理器的安全性，但可以通过观察程序的输入输出行为或反编译可执行文件来尝试理解其操作。此外，也提到了对于极度担忧安全的个体，可能需要所有软件和硬件都是开源的，以确保透明度和安全性。然而，实现完全的可审计性和透明度在现实中几乎是不可能的。"
      },
      {
        "time": "00:06:59",
        "title": "选择信任：苹果与OnePassword的比较",
        "summary": "讨论集中在是否应该信任苹果及其产品相对于OnePassword等第三方密码管理器。主要观点认为，由于苹果公司在保护用户隐私、不销售用户数据以及不植入后门方面的公开承诺，选择信任苹果是一个较为合理的选择。苹果的商誉价值被强调为公司不会轻易冒险破坏用户信任的原因之一。此外，也提到了个人对于使用密码管理软件的态度，表示自己选择不使用任何密码管理软件，而是依赖于自己的密码存储和管理机制。"
      },
      {
        "time": "00:09:18",
        "title": "密码管理策略详解",
        "summary": "讨论了密码的三层管理策略，包括基本密码、重要网站密码及金融等敏感信息密码的差异化管理。强调了使用密码管理器和定期更换重要密码的重要性，同时提倡使用两步验证增加安全性。"
      },
      {
        "time": "00:13:14",
        "title": "探讨个人网络安全及账户管理策略",
        "summary": "对话中讨论了个人网络安全的重要性，特别是账户和密码管理方面。强调了为不同网站使用不同密码和注册邮箱的重要性，以避免因一个账号泄露而影响其他账户安全。同时，提到了使用两步验证增加账户安全性，以及利用特定应用来管理验证码的便利性。此外，还提到了不频繁更换密码的个人策略，因为主要担心是网站数据库泄露而非个人频繁更改密码。"
      },
      {
        "time": "00:17:45",
        "title": "U盾和其他硬件安全设备的多种应用及挑战",
        "summary": "对话中讨论了U盾等硬件安全设备的不同形式及其在银行等领域的应用。U盾最初由工行推出，内置私钥用于签名验证，不包含密码生成器，代表了硬件安全模块（HSM）的应用。此外，还提到了不需要USB接口的硬件设备和通过手机音频接口传输信息的解决方案，以及使用屏幕闪烁二进制纹样和密码生成器来生成密码的方法。这些设备在提升安全的同时，也面临着电池寿命、有效期等挑战。讨论还提到了安全领域面临的威胁，如某公司被黑客攻击导致的密码器需要更换事件，强调了信息安全的复杂性。"
      },
      {
        "time": "00:22:43",
        "title": "探讨SSH登录及公钥私钥认证方法",
        "summary": "对话集中在讨论使用SSH登录服务器时的不同方法，包括使用密码和公钥私钥认证。讨论者分享了个人的偏好，强调了使用私钥进行身份验证的安全性和便利性。此外，还探讨了公钥私钥认证在实际应用中的挑战，比如用户对这一技术的理解程度，以及未来技术普及的乐观预测。最后，触及了验证码的使用和用户对安全认证方式的认识问题。"
      },
      {
        "time": "00:26:43",
        "title": "黑客团队Hacking Team被黑事件概览",
        "summary": "一家名为Hacking Team的安全公司，专门从事破解技术而不向被破解对象通报漏洞，而是将这些漏洞出售给包括NSA、各国政府及商业间谍在内的客户。该公司积累了400GB的数据，其中包含大量电子邮件和其他机密信息。最终，Hacking Team本身遭到黑客攻击，其400GB的数据被公开到网络上，暴露出大量敏感信息。此事件中，也发现了一些严重的漏洞，如Flash中的漏洞。"
      },
      {
        "time": "00:29:39",
        "title": "Flash零日漏洞及其安全威胁",
        "summary": "讨论了一个严重的Flash零日漏洞，该漏洞允许恶意网站在用户访问时以管理员权限执行任意代码，从而暴露用户的重要数据。尽管紧急补丁已发布，但很多人仍未安装，强调了保持软件更新的重要性。此外，讨论也触及了安全漏洞的私下交易和利用，以及这些漏洞对个人隐私和数据安全的潜在威胁。"
      },
      {
        "time": "00:33:04",
        "title": "信息安全和信任危机",
        "summary": "讨论重点在于信息安全的脆弱性和对信任的依赖。首先，提到了一个比喻，即将制作原子弹的方法公开可能带来的后果，类比到软件安全漏洞的公开，指出了即便是有安全措施，也不代表能够完全防止被恶意利用。随后，讨论转向了对技术公司如何应对这些公开的漏洞，以及他们是否能够及时修补。此外，还提到了人们在现代社会中被迫要信任许多未知的人和系统，强调了生活的风险性和信息安全的重要性。最后，通过提到生活中不可避免的小概率风险事件，暗示了人们在信息安全方面也需要接受一定程度的风险。"
      },
      {
        "time": "00:41:08",
        "title": "Atom编辑器1.0版发布与其他技术动态",
        "summary": "对话中讨论了Atom编辑器在经过长时间的开发后，终于发布了1.0版本，标志着一个重要的里程碑。Atom从public beta到1.0版的发布，经历了155次迭代，其API核心部分得到正式确认。此外，提及了其他技术产品，如Visual Studio Code和Slack，以及它们基于Web技术的特性。特别指出，尽管基于Web技术的产品在资源占用上可能较大，但它们在提供原生应用体验方面具有潜力。"
      },
      {
        "time": "00:49:42",
        "title": "探讨VR中的编程教学环境与技术限制",
        "summary": "讨论集中在使用Scheme语言的Racket实现，创建一个VR环境中的教学语言（脚本环境）。这种环境下，用户可以通过编写Scheme代码，在虚拟世界中构建组件，类似搭积木，实现了教学和创造的结合。此外，还提到了在VR中通过JavaScript实时编辑操作虚拟物件的视频，以及对微软HoloLens的期待与现实差距，特别指出了视野限制和与预期的差距，同时对技术迭代持乐观态度。"
      },
      {
        "time": "00:57:20",
        "title": "探讨编程中的除错与调试方法",
        "summary": "对话中讨论了编程过程中的除错与调试方法，区分了两种程序员：一种是先确认各种条件后编写正确代码的程序员，另一种是先编写代码再通过测试调整的程序员。强调了在动手编码前进行充分思考的重要性，用实际例子说明了编码速度不完全取决于打字速度，而是与思考的质量和深度相关。同时，也提到了编写代码时的环境和状态对编程效率的影响，建议在开始编码之前，应该先进行充分的思考和规划。"
      },
      {
        "time": "01:03:38",
        "title": "文化编程与程序错误的趣事",
        "summary": "对话涉及了文化编程（literate programming）的概念，强调在编写代码之前先阐述思路的重要性。此外，讨论了程序错误（bug）和“堤坝”（debug）一词的起源，特别提到了Grace hopper与计算机虫子的故事。对话中还分享了个人遇到的有趣和困扰人的bug经历，强调了重现问题在解决问题过程中的重要性。"
      },
      {
        "time": "01:09:29",
        "title": "解决博彩网站账户显示错误的挑战",
        "summary": "在一个博彩公司，存在一个严重的技术问题：使用iOS设备上的Chrome浏览器登录时，极小概率下用户可能会看到另一个用户的账户信息。尽管只有几位用户报告了这一问题，但公司对此感到极度恐慌。尽管尝试了多种方法，包括分析受影响账户的登录过程、请外部专家协助和审查使用的技术库，问题依然未能解决。最终采取的临时措施是阻止iOS版Chrome用户访问网站，转而推荐使用Safari浏览器。此问题成为一个技术谜团，长时间内未能找到确切原因和解决方案。"
      },
      {
        "time": "01:15:18",
        "title": "揭秘游戏开发中遇到的奇特bug",
        "summary": "在准备节目时，发现了一个关于游戏开发中最奇怪bug的问题。一个开发索尼第一代PlayStation游戏的程序员遇到了一个罕见的bug，可能导致存储卡上的所有存档资料消失。随着deadline的逼近，程序员们极度恐慌，因为当时的PlayStation没有网络更新功能。经过简化游戏功能到仅存档仍无法解决后，最终发现bug与特定频率下的硬件振动干扰有关。此外，也讨论了其他开发中遇到的诡异bug和解决方法，以及如何通过代码审查和使用IDE等工具来预防这些bug。"
      },
      {
        "time": "01:24:03",
        "title": "使用打印进行程序调试的技巧与问题",
        "summary": "讨论了使用打印（print）作为程序调试手段的常见方法，包括在代码中加入打印语句来检查变量值、控制流和输出预期结果，以此来验证代码的正确性。此外，还探讨了打印调试的不同层次，从基本的控制流检测到高级的使用日志库进行更为系统和有组织的记录。同时指出了这种方法的局限性和推荐使用的更现代化的工具，如Log4j，强调了正确选择日志级别、记录时间和相关上下文的重要性，以及避免在生产代码中保留调试打印语句。"
      },
      {
        "time": "01:28:23",
        "title": "软件开发中的调试工具和技术",
        "summary": "讨论从早期的debug.com到现代的GDB等调试工具的演变，强调了调试工具在软件开发中的重要性。这些工具允许开发者在不重新编译的情况下动态查看程序运行状态，从而实现了代码关注点的分离。GDB作为广为使用的调试工具之一，通过命令行进行操作，可以设置断点、查看程序状态等。除了GDB，还提到了针对Python的PDB和iPython中的IPDB，这些工具虽然提高了调试效率，但存在记忆指令困难的问题。为解决这一问题，提出了使用cheat sheet的方法。此外，还讨论了图形界面的调试工具，如GDB的前端界面，提供了更直观的数据结构可视化方式。最后，强调了Unix哲学中专一工具的理念，建议使用专门的编辑器和调试工具来提高开发效率。"
      },
      {
        "time": "01:38:19",
        "title": "调整代码编辑器主题和应对SSH远程服务器配色问题的实践",
        "summary": "对话内容涉及了对代码编辑器颜色主题的个性化调整，具体做法是将编辑器的颜色高亮调至最基本模式，仅保留注释和字符串的特定颜色显示，而其他元素均以默认黑色显示，以模拟电子墨水的效果。此外，还提到了一个解决SSH远程连接时终端模拟器与远程服务器配色不匹配问题的技巧，即通过修改vim编辑器的配色方案来增强代码的可读性。"
      },
      {
        "time": "01:41:14",
        "title": "探讨终端配色方案及其对眼睛的影响",
        "summary": "讨论者分享了对几种终端配色方案的使用体验，包括自定义的Mono配色、Moon配色以及Solarized配色的优缺点。讨论重点放在了配色方案的对比度、在不同光照条件下的可读性、以及对眼睛的舒适度影响。Solarized配色在强光下使用时对比度不足，而Moon配色则存在色盘兼容性问题。此外，还提到了终端模拟技术的历史沿革及其对现代用户界面设计的影响。"
      },
      {
        "time": "01:50:06",
        "title": "探讨命令行界面的发展停滞与IDE的普及",
        "summary": "对话中提到，尽管图形化界面迅速发展，命令行界面（terminal simulator）的进展缓慢，原因在于绝大多数人更倾向于使用集成开发环境（IDE）进行编程，而较少使用命令行。讨论指出，非专业程序员也可能需要编写程序，直接使用命令行对他们来说不够人性化。IDE的普及在于其集成了编辑器、项目管理、版本控制和调试工具等功能，极大提升了编程效率。此外，特定编程语言如Java和C#，由于设计时考虑到IDE的使用，因此在IDE中编写更为常见。对话还触及了早期编程语言的简洁性，与现代IDE支持的语言相比，对于初学者可能更难以理解。"
      },
      {
        "time": "01:55:59",
        "title": "探讨编程工具及技术的发展与应用",
        "summary": "对话涉及了编程中关于代码命名规范、终端使用体验、以及开发工具（如IDE和编辑器）的演变。特别提到了在早期计算机科学中，由于显示终端宽度有限和通讯技术的延迟，导致编程时方法名和变量命名长度受限，以及开发工具如mosh对于改善远程工作体验的作用。此外，还讨论了现代编程环境如何适应大屏幕显示器和更高效率的工作流程，以及IDE和编辑器在不同编程语言（如Python、JavaScript）中的应用和偏好。"
      },
      {
        "time": "02:04:48",
        "title": "前端开发工具及技术演进",
        "summary": "讨论了前端开发工具和技术的演进，包括IE9引入F12开发者工具、F5刷新机制、自动刷新工具auto refresh、前端框架如Angular或React自带的服务器自动重载功能。此外，还探讨了编辑器如Bracket和前端开发者工具如Chrome的Inspector，以及Firefox整合Firebug的响应。最后，提及了React Native允许在Chrome Inspector中实时修改iOS应用，体现了前端开发的便利性和技术的先进性。"
      },
      {
        "time": "02:10:49",
        "title": "探讨云服务下的程序调试挑战",
        "summary": "对话内容涉及了在云服务环境下，如何对跨系统、多进程应用程序进行调试的问题。讨论了Google App Engine的云调试工具，以及在分布式环境下定位和解决程序错误的复杂性。此外，还讨论了程序崩溃时的诊断方法，如通过程序挂掉时的“车祸现场”来分析问题，以及使用内存转储进行错误定位的困难。探讨了在服务无法轻易重启（如游戏服务器和大数据分析环境）情况下的调试挑战，并提到了某些编程语言和环境（如Erlang）支持的动态调试和代码更新功能。最后，强调了养成良好编程习惯的重要性以及调试技术的局限性。"
      }
    ],
    "mindmap": {
      "children": [
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "children": [],
                      "content": "推荐使用podcast客户端订阅"
                    },
                    {
                      "children": [],
                      "content": "网址：IPN dot IOS flash kernel panic"
                    }
                  ],
                  "content": "内核恐慌"
                },
                {
                  "children": [
                    {
                      "children": [],
                      "content": "Hacking Team被黑，泄露400GB数据"
                    },
                    {
                      "children": [],
                      "content": "波及范围广，包括政府和商业间谍"
                    }
                  ],
                  "content": "1.2. 安全公司被黑事件"
                },
                {
                  "children": [
                    {
                      "children": [],
                      "content": "Atom编辑器发布1.0版本"
                    },
                    {
                      "children": [],
                      "content": "Visual Studio Code发布0.5版"
                    },
                    {
                      "children": [],
                      "content": "Web技术在客户端应用"
                    }
                  ],
                  "content": "1.3. 编程工具和方法"
                },
                {
                  "children": [
                    {
                      "children": [],
                      "content": "Oculus Rift"
                    },
                    {
                      "children": [],
                      "content": "VR环境下的编程和教育应用"
                    }
                  ],
                  "content": "1.4. 虚拟现实技术"
                }
              ],
              "content": "1.1. IT技术节目"
            }
          ],
          "content": "1. 技术主题"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "children": [],
                      "content": "代码审查的重要性"
                    }
                  ],
                  "content": "先确定边界条件再写代码 vs 先写代码后调整"
                },
                {
                  "children": [
                    {
                      "children": [],
                      "content": "使用GDB和PDB"
                    },
                    {
                      "children": [],
                      "content": "打印法和断点法"
                    },
                    {
                      "children": [],
                      "content": "编程错误的发现和修复"
                    }
                  ],
                  "content": "2.2. 调试技巧"
                },
                {
                  "children": [
                    {
                      "children": [],
                      "content": "Scheme和Lisp的应用"
                    },
                    {
                      "children": [],
                      "content": "JavaScript和前端开发工具"
                    }
                  ],
                  "content": "2.3. 编程语言和环境"
                },
                {
                  "children": [
                    {
                      "children": [],
                      "content": "密码管理策略"
                    },
                    {
                      "children": [],
                      "content": "防止账户信息泄露"
                    }
                  ],
                  "content": "2.4. 安全意识"
                }
              ],
              "content": "2.1. 编程习惯"
            }
          ],
          "content": "2. 个人经验分享"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "children": [],
                      "content": "捐款地址和要求"
                    }
                  ],
                  "content": "呼吁听众捐款"
                },
                {
                  "children": [
                    {
                      "children": [],
                      "content": "提供反馈渠道"
                    },
                    {
                      "children": [],
                      "content": "答疑解惑"
                    }
                  ],
                  "content": "3.2. 社区反馈"
                },
                {
                  "children": [
                    {
                      "children": [],
                      "content": "安全意识的重要性"
                    },
                    {
                      "children": [],
                      "content": "编程语言和工具的选择"
                    }
                  ],
                  "content": "3.3. 社区讨论"
                }
              ],
              "content": "3.1. 捐款支持"
            }
          ],
          "content": "3. 社区互动"
        }
      ],
      "content": "脑图摘要"
    }
  }
}