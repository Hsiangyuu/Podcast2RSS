{
  "pid": "5e284e0c418a84a0462693e4",
  "eid": "5e84c3ac418a84a0462df8df",
  "title": "48. Kerning Panic·字谈字串（五）规范化有四样形式，你知道么？",
  "task_id": "gpjbqkmda742nk2a",
  "transcription": [
    {
      "time": "00:00:19",
      "text": "大家好，今天是7月25号。现在您听的是自弹自唱的第52期.",
      "speaker": "发言人2"
    },
    {
      "time": "00:00:26",
      "text": "同时也是内核恐慌的第48期。",
      "speaker": "发言人1"
    },
    {
      "time": "00:00:29",
      "text": "这也是我们自弹自唱和内核恐慌串台的自弹自唱节目的第五期。我们自弹自唱是全国全球首家用华语制作的字体排印主题播客节目。我是主播问川西办东营区eric，我是主播黄埔嘉宾秦真宇、钱振宇。",
      "speaker": "发言人2"
    },
    {
      "time": "00:00:46",
      "text": "内核恐慌是IPM potass网络旗下的IT技术主题娱乐节目。我们号称core，但是也没有干货，想听就听，不想听你就别听我是主播吴涛。",
      "speaker": "发言人1"
    },
    {
      "time": "00:00:57",
      "text": "我是real。",
      "speaker": "发言人4"
    },
    {
      "time": "00:01:00",
      "text": "你说我们这个节目串台都已经串了第五期了，等到上次五月底才第一次四个人一起在同一个空间见面是吧？",
      "speaker": "发言人2"
    },
    {
      "time": "00:01:07",
      "text": "历史性的会晤。",
      "speaker": "发言人4"
    },
    {
      "time": "00:01:09",
      "text": "对，我们四个人没有合照。",
      "speaker": "发言人3"
    },
    {
      "time": "00:01:11",
      "text": "那天活动来了好多博客主播数。",
      "speaker": "发言人2"
    },
    {
      "time": "00:01:14",
      "text": "来应该有差不多小于十个。",
      "speaker": "发言人4"
    },
    {
      "time": "00:01:17",
      "text": "你们后来就背着我们就直接去喝酒了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:01:20",
      "text": "你们不是也去喝酒了吗？",
      "speaker": "发言人1"
    },
    {
      "time": "00:01:22",
      "text": "你们不是还要去打扫场地吗？那没有办法。",
      "speaker": "发言人4"
    },
    {
      "time": "00:01:27",
      "text": "对，虽然说是TIB10周年活动节目，那搞得好像是变成国内IPN和各各台电台主播的一个小聚会了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:01:36",
      "text": "小众播客网络。",
      "speaker": "发言人4"
    },
    {
      "time": "00:01:39",
      "text": "而且其实线下我跟艾瑞克在东京见过，然后我跟real见过很久了。Eric跟张宇之前也在上海见过很多次。",
      "speaker": "发言人1"
    },
    {
      "time": "00:01:51",
      "text": "对我跟real也见过一次，然后我跟real在深圳也见过12一两次两次OK对。",
      "speaker": "发言人2"
    },
    {
      "time": "00:01:59",
      "text": "但正所有人在一起见，这是第一次，还挺难得的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:02:04",
      "text": "我们可以在那个units发一下上次活动的剧本，就是什么四个人都在的照片，应该有吧？没有。",
      "speaker": "发言人4"
    },
    {
      "time": "00:02:12",
      "text": "好像咱们四个没有合影。对。",
      "speaker": "发言人1"
    },
    {
      "time": "00:02:15",
      "text": "oh my god.",
      "speaker": "发言人2"
    },
    {
      "time": "00:02:17",
      "text": "这么惨把吴涛P上去。",
      "speaker": "发言人3"
    },
    {
      "time": "00:02:20",
      "text": "不是，那个real也没有跟其他三个人合过影。Real有没有跟你们两个？",
      "speaker": "发言人1"
    },
    {
      "time": "00:02:28",
      "text": "有，肯定有照片，同时有我和艾瑞克和锐的。我记得有一张有各种主播在一起。",
      "speaker": "发言人3"
    },
    {
      "time": "00:02:36",
      "text": "有一张是你们两个在那个内奸。",
      "speaker": "发言人1"
    },
    {
      "time": "00:02:41",
      "text": "那个是一个节目。",
      "speaker": "发言人3"
    },
    {
      "time": "00:02:42",
      "text": "然后real站在外面的照片。",
      "speaker": "发言人1"
    },
    {
      "time": "00:02:44",
      "text": "对，对，这个也有。",
      "speaker": "发言人3"
    },
    {
      "time": "00:02:45",
      "text": "然后活动结束的时候，我跟二哥和何振宇都有合影。但是那个时候吴涛不知道去哪去了。",
      "speaker": "发言人4"
    },
    {
      "time": "00:02:52",
      "text": "我去喝酒。对，去泡妹子了，我要喝花酒。",
      "speaker": "发言人1"
    },
    {
      "time": "00:03:01",
      "text": "好，首先跟大家讲一讲，其实这也不算广告了，就我们自己的type school 7月份的课程已经结束了。七月份这个西文的字体设计课程，大家应该虽然很累，但很辛苦，但是估计大家收获也蛮大的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:03:18",
      "text": "一共有几天了。",
      "speaker": "发言人3"
    },
    {
      "time": "00:03:19",
      "text": "两个礼拜我也过去跟去去和大家就凑了一会儿热闹。看我们的格尔格老师给大家讲gives挺有意思的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:03:32",
      "text": "对了，我一直很好奇他是一个字体设计师吗？",
      "speaker": "发言人3"
    },
    {
      "time": "00:03:36",
      "text": "对他自己设计师，他自己设计字体，但是他有一些计算机开发的基础，然后他做出griff，几乎现在就几乎全职都在做griff这个软件掉了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:03:49",
      "text": "变成所以他应该是一个计算机科学出身的人，他是一个他是设计师出身，那他既然能写这么复杂的，我觉得glimpse已经是一个非常复杂的软件了。",
      "speaker": "发言人3"
    },
    {
      "time": "00:04:01",
      "text": "对。",
      "speaker": "发言人2"
    },
    {
      "time": "00:04:03",
      "text": "非常令人惊讶。",
      "speaker": "发言人3"
    },
    {
      "time": "00:04:05",
      "text": "对，好吧，设计界需要这样的人才，所以我也希望有更多的设计师来听我们的自弹自唱，好吧。然后就很有很多朋友问，就因为这次是讲新闻，那有没有学中文的字体设计课程？其实可能大家在微信上面也看到消息了，我们在八月4号到9号会有这样一个课程，叫type school的中文字体设计课。而且这次不是在上海，是在北京。然后我们请到了老师，就有方正字库的思维设计师，包括像蚯蚓蚯蚓先生这样经验非常丰富的字体，是设计过很多中文字体的设计师，可能大家都最知道他最著名的字体就是那个黝黑。对，然后type school就会教大家如何实现字库。",
      "speaker": "发言人2"
    },
    {
      "time": "00:04:54",
      "text": "然后因为是做中文，所以可能工程比较浩大，说从12个字扩展到50个字，到500、五千、5万对吧？平时大家设计中中文的话是没有头绪，不知道怎么用什么方法做，然后做要做多少字，一旦多的话这个怎么提高效率，尽早提，确实发现问题？比如说大小不一样，怎么处理，这些我们都会具体的在type school请老师给大家介绍。",
      "speaker": "发言人2"
    },
    {
      "time": "00:05:31",
      "text": "对，不过五天时间，其实做12个字也都差不多。我们这次有一个很好的机会，是优秀的学员可以和方正签约。只要你先做几做好几百个字，剩下的成千上万字方正会帮你做。",
      "speaker": "发言人2"
    },
    {
      "time": "00:05:49",
      "text": "对，这个其实就跟之前的这个字体竞赛很相似了。就是你提交一份样字的作品，然后如果自己公司觉得非常合适，有商业化的价值的话，会与你签约，然后帮你把它做成一个真正意义上的字库。",
      "speaker": "发言人3"
    },
    {
      "time": "00:06:04",
      "text": "当然在这样一个课程里面，大家也会可以接触到gripes这样一个什么字体神器。其实而且这次我们graves开发者奥格格来中国，给大他切身感到了做方块汉字的一些特殊的要求。我们有很多新的功能也会加到这个grips里面给大家可以试用一下。",
      "speaker": "发言人2"
    },
    {
      "time": "00:06:29",
      "text": "这次我们还邀请到了德国的meta design，made a design的德国的他们那边的设这个公司的他们的设计师也会参与到活动里面进来。对meta design感兴趣的朋友们也有机会，所以这也是蛮难得的一个机会。八月份的北京比较热，但是我觉得七月份的上海也够热的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:06:56",
      "text": "上海更热。我觉得这两天北京比上海凉快。",
      "speaker": "发言人3"
    },
    {
      "time": "00:07:01",
      "text": "没有北京北京还好，是干热。上海主要是湿度比较大，比较难受。",
      "speaker": "发言人2"
    },
    {
      "time": "00:07:05",
      "text": "但上海这周是爆热，已经超过40度了。",
      "speaker": "发言人3"
    },
    {
      "time": "00:07:09",
      "text": "对，那有这种夏令营的感觉哈那大家也欢迎大家来多多的进行报名，就有这样的机会是非常难得的。好了，难得我们这次第五次的串台，但是还要先讲一下反馈。上次就是我们的自弹自唱的第四期，峰回路转换行来，有一位朋友说吴涛重新发明打字机，吴涛重新发明打字机，带回车键的打字机感叹号。",
      "speaker": "发言人2"
    },
    {
      "time": "00:07:42",
      "text": "所以打字机是没有回车键的对吧？",
      "speaker": "发言人4"
    },
    {
      "time": "00:07:44",
      "text": "打字机没有一个键是你按下去之后它会跳到下一行。我也在这好像是有的。但这个键并不是回车键，也不是在每一个打字机上都有。然后换行的时候是你拨动那个左边的拨杆，把自车往右拨的过程之中，它会自动朝朝下滚一格。所以换行这个功能实际上是在自车上实现的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:08:10",
      "text": "郑宇还是把那位听众的反馈念一下。",
      "speaker": "发言人2"
    },
    {
      "time": "00:08:15",
      "text": "好吧，刚艾克念的是第一行，然后接下来念打字机，没有回车键。打字机滚筒左端的手柄兼具回车与换行功能。手柄从左向右平推，可以将滚轮向右推送就是回车。手柄从右向左从左向右扳动，同时带点轻微的顺时针扭转，可以滚动，滚动就是换行。搬的轻一点可以换半行或4分之1行。打字时当滚动行进行到滚动行进到接近行末位置时会有叮的一声铃音提示。平推手柄，将滚轮推到最右实现回撤，顺势继续用手，顺势继续用力，手柄会自然向右摆动，转动滚轮。我说好拗口。",
      "speaker": "发言人3"
    },
    {
      "time": "00:09:08",
      "text": "你怎么了？你上来了吗？陈忠义。",
      "speaker": "发言人1"
    },
    {
      "time": "00:09:11",
      "text": "这好拗口，实现换行OK大家听懂了吗？",
      "speaker": "发言人3"
    },
    {
      "time": "00:09:16",
      "text": "没有我我是没听懂。不，我知道他是什么意思，就是对你再你再敲一行，比如说这一行有80个字符，然后你敲了大概75个的时候，打字机会叮一声告诉你说没没地儿了，赶紧换行。然后这个时候你压左侧的那个换挡杆压稍微压一下，然后那个自车就会往上滚一格，然后你继续往下压，它就会把整个自车拉到纸的最左边，然后就这么一件事。对我还是很好奇，为什么你们小时候都没有用过打字机呢？试试。对，就没有用过西文，没有用。所以你用过中文的打字机，那更屌了。中文打字机是一个1米乘1米的大牌子。",
      "speaker": "发言人1"
    },
    {
      "time": "00:10:07",
      "text": "对，这个我我我用过。",
      "speaker": "发言人3"
    },
    {
      "time": "00:10:08",
      "text": "就我玩过一下。",
      "speaker": "发言人1"
    },
    {
      "time": "00:10:10",
      "text": "这真的存在吗？那么多个字是那么大，怎么怎么移动呢？",
      "speaker": "发言人4"
    },
    {
      "time": "00:10:17",
      "text": "是一个笛卡尔的，笛卡尔平面，你要XY真的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:10:22",
      "text": "天那那能有多少个字？",
      "speaker": "发言人4"
    },
    {
      "time": "00:10:27",
      "text": "上面字母将近1万个，总有很多很多没有吧？",
      "speaker": "发言人3"
    },
    {
      "time": "00:10:31",
      "text": "没有，不到一万多。这那一两千肯定是有的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:10:35",
      "text": "因为我的印象里面，我的印象里面我玩过的那台是有6000字的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:10:41",
      "text": "因为中文常文常用字也就3500。",
      "speaker": "发言人2"
    },
    {
      "time": "00:10:45",
      "text": "他把常用字放在上面，然后不够的是用空格，然后又在手写。",
      "speaker": "发言人4"
    },
    {
      "time": "00:10:49",
      "text": "他底下那个可以换的，可以替换。",
      "speaker": "发言人2"
    },
    {
      "time": "00:10:51",
      "text": "我印象里面是个100乘100的格子，你知道吧？",
      "speaker": "发言人1"
    },
    {
      "time": "00:10:55",
      "text": "我印象好像有那么多吗？没那么大。",
      "speaker": "发言人2"
    },
    {
      "time": "00:10:59",
      "text": "没有100乘100吗？",
      "speaker": "发言人1"
    },
    {
      "time": "00:11:01",
      "text": "记不大清楚了。",
      "speaker": "发言人3"
    },
    {
      "time": "00:11:03",
      "text": "挺大的对，反正是个相当大的东西。",
      "speaker": "发言人1"
    },
    {
      "time": "00:11:07",
      "text": "我刚给大家发了一个链接，那个也是一种汉字的打字机。这个是日本人做的，然后它是一个滚筒式的选择机构。",
      "speaker": "发言人3"
    },
    {
      "time": "00:11:20",
      "text": "OK这个比较牛逼。",
      "speaker": "发言人1"
    },
    {
      "time": "00:11:21",
      "text": "对，这个是在京都的汉字博物馆里面展示的一件展品。",
      "speaker": "发言人3"
    },
    {
      "time": "00:11:27",
      "text": "其实如果这么多，这怎么记？",
      "speaker": "发言人4"
    },
    {
      "time": "00:11:31",
      "text": "可能熟能生巧。另外他肯定牌子是有规则的，你看他有标了，不同的不可以。",
      "speaker": "发言人3"
    },
    {
      "time": "00:11:37",
      "text": "给我这样排吗？",
      "speaker": "发言人4"
    },
    {
      "time": "00:11:39",
      "text": "不，汉字应该不是这样排的。OK应该是按英式排的，它是有颜色划分，应该是按那个所谓的行和列，就是把这五十音的行和列的发音来标音之后再分开。",
      "speaker": "发言人3"
    },
    {
      "time": "00:11:54",
      "text": "我天怎么记得住。",
      "speaker": "发言人4"
    },
    {
      "time": "00:11:55",
      "text": "哪个字在哪个位置，还是要找的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:11:58",
      "text": "不。你想就说他假设只有3300千个常用字的那个滚筒的话，那这打字速度应该很慢。",
      "speaker": "发言人4"
    },
    {
      "time": "00:12:07",
      "text": "就得转转，然后找完以后才打出一个字，就是这样。他这个毕竟还是按拼音排列的，我觉得可能还是要比中文打字机那个按部首排列的要快一点。",
      "speaker": "发言人1"
    },
    {
      "time": "00:12:18",
      "text": "我觉得对，不过因为日语一个字有很多发音，所以你可能得记住这个字他用的是哪个。",
      "speaker": "发言人3"
    },
    {
      "time": "00:12:26",
      "text": "标一像我以前看到我就是我爸单位他们那个打字员用的那种打字机的话，他底下那个反刚刚充的那个刚字的盘是可以换的。所以他经常会把这比较常用的字这样的组合，它因为它可以随任意调配，然后把常用那个放在一起，比如中华人民共和国，它就全部放在嘎嘎嘎嘎嘎就顺下来，可以直接打出来就可以。",
      "speaker": "发言人2"
    },
    {
      "time": "00:12:53",
      "text": "而且我记得我见到那个中文打字机，好像它那个字盘不只是一层，它好像有两层的可以抽的对没错对，没错，上面有一层可能是常用的，下面还有一层次。",
      "speaker": "发言人3"
    },
    {
      "time": "00:13:04",
      "text": "常用用的这对对对，没错。对，是这样的。所以我印象中的中美达资金没那么大。",
      "speaker": "发言人2"
    },
    {
      "time": "00:13:12",
      "text": "有道理。对，100乘100好像移动起来也挺麻烦的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:13:18",
      "text": "打太极拳都可以。因为我我小时候其实就根本没有见过这些纯机械的打字机。因为我我记得我小时候第一次看人打字的时候，已经是有那个叫那个叫什么来着？就是字符那个dos dos环境下面有一个中文。",
      "speaker": "发言人4"
    },
    {
      "time": "00:13:35",
      "text": "的系统W.",
      "speaker": "发言人2"
    },
    {
      "time": "00:13:36",
      "text": "PSCCCCED。",
      "speaker": "发言人1"
    },
    {
      "time": "00:13:38",
      "text": "可能是CCED是更早的，后来WPS后出的。然后后出的时候，那个时候已经有那种在那个WPS的字符界面那个版本里面去彩印，然后用那种针式打印机再把那个打出来。所以这个时候其实已经没有见过真的那种传统意义上的打字机了。",
      "speaker": "发言人4"
    },
    {
      "time": "00:13:57",
      "text": "我高中办校报的时候就是用先进UC dos，然后再进那个WBS。他那那不是一个它是字符编辑界面，它不是所见即所得的，所以你得要一些装饰的东西都都用在那个符号写进去以后，它不停的预览，然后经常386的机器还会死机。",
      "speaker": "发言人2"
    },
    {
      "time": "00:14:18",
      "text": "对，那个时候对于所见即所得没什么概念。对，就是你要不停的预览的。但是后来基本上熟练一点的人会对于文章大概会看起来是什么样子有个概念，就跟现在手写HT也蛮有用。然后预览本质上也是。",
      "speaker": "发言人1"
    },
    {
      "time": "00:14:35",
      "text": "一种markup语言。",
      "speaker": "发言人4"
    },
    {
      "time": "00:14:37",
      "text": "那个是那完全就是markup，所以你脑子要想好你所要的是什么东西。",
      "speaker": "发言人2"
    },
    {
      "time": "00:14:43",
      "text": "对，那就现在我们又回markdown又回去了是吧？又回来了。对。",
      "speaker": "发言人4"
    },
    {
      "time": "00:14:48",
      "text": "实际上我觉得我这个所见即所得并不是一个强需求，说实话就要。",
      "speaker": "发言人1"
    },
    {
      "time": "00:14:54",
      "text": "看他那个门槛放低了以后，是可以让更多人进来。但是对于专业用户的话，可能需求不一样。",
      "speaker": "发言人2"
    },
    {
      "time": "00:15:03",
      "text": "对。",
      "speaker": "发言人1"
    },
    {
      "time": "00:15:04",
      "text": "我觉得首先系统所本身是没有问题的，主要问题在于现在最主要这个是像word那个实现，它的那个实现过程有问题，就是他把所有的效果都就直接锁定了，你没有办法用一个类似于像模板或者是一种格式的方式。现在是虽然有格式刷，但是那个格式刷就是极其不稳定。",
      "speaker": "发言人4"
    },
    {
      "time": "00:15:27",
      "text": "Word我觉得这个问题太太迁就用户了，就是用户说我这个小标题要四五万，15磅重加粗下一个小标题他就弄了一个16磅重，然后倾斜，然后握着就傻逼了，握着说我应该怎么办呢？我应该问用户说不对，你上一个小标题用的是这个，然后这个小标题你也得用那个。但是这样一来用户可能不爽，那我还是迁就用户再再多分出来一个小标题。然后等到整个整篇文章写完之后，我发现小标题的style可能有20种.",
      "speaker": "发言人1"
    },
    {
      "time": "00:16:03",
      "text": "35种。",
      "speaker": "发言人4"
    },
    {
      "time": "00:16:04",
      "text": "对，如果一上来你们从来没有学会过用word格式刷这个习惯的话，那基本上就最后只能手不动改。",
      "speaker": "发言人1"
    },
    {
      "time": "00:16:12",
      "text": "不关键是那个格式，它那个格式刷它也是一个事后加的东西。我觉得它的本质上，它的主体结构是以实际看的为准的。这点跟苹果那个pages就是跟word差不多的一个软件的逻辑是完全不一样的。",
      "speaker": "发言人4"
    },
    {
      "time": "00:16:28",
      "text": "Pages里面其实你是可以先定义那个文章的结构。比如说刚才讲说这个是标题，就是一级标题、二级标题，它是正文，这个是这个表格的内容。然后定好之后，你是可以直接通过改那个那个类型的文本。比如说我就把它改标题都改成一种同一样东西，它它可以直接更新，然后让所有的标题文本都是长那个样子的。但是在word里面这一点实现起来是非常不稳定的。",
      "speaker": "发言人4"
    },
    {
      "time": "00:16:53",
      "text": "Word也有这个功能，word的也有。对，就是用的也非常的少。",
      "speaker": "发言人3"
    },
    {
      "time": "00:16:58",
      "text": "不是，他的时间确实是有问题的，就是他不是那么强调那个结构和统一的这么一个概念。就刚才讲吴涛说的，就是用户觉得这里要改一点，那一点改他就不去enforce这个对咱们一致性的问题。",
      "speaker": "发言人4"
    },
    {
      "time": "00:17:12",
      "text": "这个其实是专业用户的一个需求不一样的。像我当年也曾经用word做40页的小册子的时候，我都是用那个样那个叫什么style样式，它它专门有个样式小窗口来做。你做长文档的时候就必须要用那样来做，要不然的话非常复杂。",
      "speaker": "发言人2"
    },
    {
      "time": "00:17:31",
      "text": "对，就是那个实际的使用的情况下，word就会出现刚才我才讲的那个问题。就是你的那个格式刷，它不是一个选一个列表有多少种格式吗？你可能一边稍微长10页的文档，可能会出现四五十种，哪个不同？",
      "speaker": "发言人4"
    },
    {
      "time": "00:17:42",
      "text": "就是word对于就是你想把word用好的话，你要有一个非常好的。怎么说呢？Deception就是你必须是一个非常自律。",
      "speaker": "发言人1"
    },
    {
      "time": "00:17:52",
      "text": "高度自律的人是。对。",
      "speaker": "发言人4"
    },
    {
      "time": "00:17:54",
      "text": "一定要忍住选中这一行字，然后字直接往上往改，改变在格式的改变它的样式的冲动，然后忍辱负重的去用格式刷来刷这样子。对，否则你就断了。",
      "speaker": "发言人1"
    },
    {
      "time": "00:18:10",
      "text": "对它很容易在一些小细节地方就变掉，就是你用格式刷也刷不回来。有些人我不知道有没有遇到过，有些比如说两个字之间出现一个东西，你无论用格式串点多少次，它都不会变的。就是它的内部应该是有一些实现的bug的。",
      "speaker": "发言人4"
    },
    {
      "time": "00:18:25",
      "text": "这个东西就是那你要自律的话，看有没有洁癖了吧？就千万不能用硬回车来撑行距，用空格来称字句？像这种东西的话，对对对，本来就是排档台湾的首先的这个做法是不一样的。对。",
      "speaker": "发言人2"
    },
    {
      "time": "00:18:44",
      "text": "OK, 补充一句，刚才说的那个中文打字机，我记得那个中文打字机它有一个最大的问题，就是它不像英文打字机。英文打字机也有这个问题，但是没那么严重。就是你在用应用打字机的时候，你可能按一个键，你的力度轻了，那个那个打在纸上的字就会不清楚。而中文打字机是如果你力度轻了，那字不清楚也就罢了。如果你用力比较重的话，那那个那个字那个笔画也比较复杂。比如繁体的什么国家的国字，这种字你一打上去，那个纸会被穿烂了一下。所以那个时候不仅打字是一个要寻址，你还要控制自己打字的力量，真的是很累。",
      "speaker": "发言人1"
    },
    {
      "time": "00:19:33",
      "text": "为什么会这样呢？所以他那个按键是不是均匀力度下去，是靠你的那个手的力量来决定的对。",
      "speaker": "发言人4"
    },
    {
      "time": "00:19:41",
      "text": "其实他是把一张纸卷在一个大滚筒上，那滚筒是在这个笛卡尔平面上面移动的。然后移动的时候你找到一个字，你要把那个压你要把那个手柄压下去。然后我理解是他把那个签字吸上来，然后在纸上戳一下，然后这个如果戳的比较狠的话，那个纸就会破。",
      "speaker": "发言人1"
    },
    {
      "time": "00:20:06",
      "text": "对。",
      "speaker": "发言人4"
    },
    {
      "time": "00:20:08",
      "text": "但我觉得像用键盘的这种打字机，它完全是可以用机械设计解决这个问题。",
      "speaker": "发言人3"
    },
    {
      "time": "00:20:13",
      "text": "对，在像IBM的那种就是用球形的那个打字头打字机，它就是他把输入跟那个打字的部分分开了。实际上你是去驱动一个发条，然后那个发条每次会以均匀的力度把那个字打在纸上，但这个都比较高端了。对，这个都比较高端了。你就加他用的那种就是便尤其是便携的袖珍的打字机，都是还是你按你的手按的力度多大，那个字就有多深。",
      "speaker": "发言人1"
    },
    {
      "time": "00:20:42",
      "text": "怪不得看有些那种那种以前那种打自己打的文档，它有些那个字符的粗细是不一样的。",
      "speaker": "发言人4"
    },
    {
      "time": "00:20:48",
      "text": "就是因为这个原因是吧？对，就是用于它有力度的问题。",
      "speaker": "发言人1"
    },
    {
      "time": "00:20:53",
      "text": "这也是这个真的是个手艺活。",
      "speaker": "发言人4"
    },
    {
      "time": "00:20:56",
      "text": "对你像那个耳朵那个IBM出打字机里面，korea的这个字体就是这么来的，就是专门为了他的一个滚筒式打字机的设计的一套字体。",
      "speaker": "发言人1"
    },
    {
      "time": "00:21:10",
      "text": "有什么讲究吗？",
      "speaker": "发言人4"
    },
    {
      "time": "00:21:12",
      "text": "就是等宽，那个时候的等宽，然后是就有点slap的感觉，就是带一点点衬衫那样。",
      "speaker": "发言人1"
    },
    {
      "time": "00:21:21",
      "text": "最近有个新闻可以和大家分享一下，因为我们前段时间说过那个AMOJ，就是表情符号，刚好7月17号就是今日7月17号是MG日，这个事情你们知道吗？",
      "speaker": "发言人2"
    },
    {
      "time": "00:21:32",
      "text": "我们体力过我们体，而不是还有自己的节日了。已经我没有我们讲MG那期提过这个事情。",
      "speaker": "发言人3"
    },
    {
      "time": "00:21:39",
      "text": "为什么是那天我忘了。",
      "speaker": "发言人4"
    },
    {
      "time": "00:21:40",
      "text": "就是因为MG的日历的图标上写的是7月17。",
      "speaker": "发言人3"
    },
    {
      "time": "00:21:45",
      "text": "对对对，对我想苹果。",
      "speaker": "发言人4"
    },
    {
      "time": "00:21:48",
      "text": "日历的沿用苹果的当时还叫IQ的日子。对，然后这次苹果居然在他们官方网站上面搞一个什么新闻出来了，是吧？预先把今年稍晚推出的那个表情符号跟大家展示了一下。",
      "speaker": "发言人2"
    },
    {
      "time": "00:22:05",
      "text": "哼这是IOS11里面.",
      "speaker": "发言人3"
    },
    {
      "time": "00:22:07",
      "text": "会搭载那一套新的。",
      "speaker": "发言人4"
    },
    {
      "time": "00:22:09",
      "text": "对，也就是六月份i uni第十版里面已经通过的这些，他已经准备好，已经画好了，就马上就要播，拿出来给大家用了。比如说有什么僵尸，谁有什么戴头巾的女人，长胡须的人。",
      "speaker": "发言人2"
    },
    {
      "time": "00:22:28",
      "text": "僵尸和穆斯林是同一个批次的时候。",
      "speaker": "发言人1"
    },
    {
      "time": "00:22:33",
      "text": "或者说应该还有什么饺子和筷子。不是我上次在节目，我在我们节目里面说过，到他画到底是画成包子还是化成馄饨。",
      "speaker": "发言人2"
    },
    {
      "time": "00:22:43",
      "text": "那就不知道了，到时候看时间吧。所以现在在那个IOS11的预览，就是什么beta版里面应该已经可以看得到了。",
      "speaker": "发言人4"
    },
    {
      "time": "00:22:53",
      "text": "你们装的吗？",
      "speaker": "发言人2"
    },
    {
      "time": "00:22:54",
      "text": "我在ipad上装了，但还没注意到看那个表情emerge的变化。",
      "speaker": "发言人4"
    },
    {
      "time": "00:23:01",
      "text": "好像还没，我还我没装我没装，好像还我也我也没装，但好像还没上。",
      "speaker": "发言人3"
    },
    {
      "time": "00:23:07",
      "text": "他上了一个叫做public的beta，上了两次了。",
      "speaker": "发言人4"
    },
    {
      "time": "00:23:12",
      "text": "我知道巨不稳定，我看好多人都说巨不稳定。",
      "speaker": "发言人1"
    },
    {
      "time": "00:23:16",
      "text": "我在那个ipad上装的反正还行，因为这次ipad改动比较大，我待会儿会去看一下，看那个ipad上有没有。",
      "speaker": "发言人4"
    },
    {
      "time": "00:23:26",
      "text": "那现在就可以念另外一封听众反馈了是吧？",
      "speaker": "发言人2"
    },
    {
      "time": "00:23:31",
      "text": "可以。",
      "speaker": "发言人1"
    },
    {
      "time": "00:23:32",
      "text": "好，我来念一下。有一位没有署名的听众，后来我问了他，我还专门写信去问了他应该怎么称呼，然后他说可以称呼他叫tiger老虎。然后这位自称叫老虎的听众来了一封邮件，说赞美主播并求解两个问题。两位主播好，他是写给自弹自唱的。两位主播好。我是一个通信工程毕业的码农，具体来说是做IOS开发。大概年前，偶然机会发现了你们的博客，一直听到现在很佩服你们的毅力，能够持续更新，超越了内核恐慌。我是码农，所以最开始听的是内核恐慌。",
      "speaker": "发言人3"
    },
    {
      "time": "00:24:12",
      "text": "听你们播感觉我们很容易超越。",
      "speaker": "发言人4"
    },
    {
      "time": "00:24:16",
      "text": "我受益匪浅。知道任何东西都不是简简单单的一个设计作品，或者具体到一个UI界面看起来很舒服，一定是有其背后的道理。我也看了你们推荐的一些书籍，做了一些笔记，这里就不说了。一直以来就想着就这样被你们润物细无声也挺好的。但是我最近遇到了一些问题，想得到你们的指教。因为有个问题是偏计算机方面，和字体没啥关系，不知道提出来是不是很合适。不过我觉得真鱼主播一定可以的，其实真鱼主播不可以。",
      "speaker": "发言人3"
    },
    {
      "time": "00:24:46",
      "text": "压力大不大？",
      "speaker": "发言人4"
    },
    {
      "time": "00:24:47",
      "text": "问题，关于中西文混排时的高度，在一个label上展示文字时，最终展示的高度如何确定？如果文字只有英文，字号选择是14号字在两倍视网膜屏幕上，那么最后文字的高度不会超过28 pixel。虽然他写的是pointing，我估计是个笔误，这个高度应该等于声部线到酱瓿线的高度。如果文字只有中文，那么类似最后文字的高度也不会超过28 pizzle，虽然中文不一定有声部线和酱瓿线，但是原理是类似的，如果是中英混排，最后文字的高度会是怎样呢？我问了我们的设计师，说是会比28X多出1到2个像素，这是什么原因呢？是因为中文和英文的期限没有对齐吗？希望可以得到主播的解答。问题2，关于多语言字符串。",
      "speaker": "发言人3"
    },
    {
      "time": "00:25:37",
      "text": "先回答一个再讲。",
      "speaker": "发言人4"
    },
    {
      "time": "00:25:39",
      "text": "这个我给他写了一个邮件，是说明了一下其中一些问题。但是我觉得他对他对他们的设计师，对整个渲染机制可能没有理解，所以说的完全不着调。我还简单来说一下。首先就是说嗯IOS它维护了一套所谓的逻辑逻尺寸，就是逻辑布局的空间。所以它的这个point寸换算成一个pixel的值，并不是一定1比1、1比2、1比3或者是一比几点几的。因为还有像iphone plus这样子奇葩的屏幕分辨率。另外就是用户也可以调这个屏幕分辨率。",
      "speaker": "发言人3"
    },
    {
      "time": "00:26:17",
      "text": "就一定要什么dynamic type是吧？",
      "speaker": "发言人4"
    },
    {
      "time": "00:26:20",
      "text": "就是它可以调这个缩放，就比如说你视力不好，对对对，所以你可以调整。所以这个具体几倍其实是由操作系统来维护的。那么你只能使用一个逻辑的这个point的值，这个值是IOS给开发者使用的。所以一个字符当它被设定成比如说14 point的时候，其实简单来说我们用一个typography unit的概念来说，我们就是将一个EM的尺寸设成了14个point。那么究竟一个EM的gliff它的显示的这个尺寸是多少个point，或者是具体到多少个pixel，其实完全是由字体来决定的。你可以将一个EM的gliff设计的只占一个像素那么大，你也可以设计的超过一个EM的方格的空间，这都是没有问题的。所以具体渲染成多少个像素或者多少个point，完全是由这个字体来决定的，就跟其他的没有任何关系好。",
      "speaker": "发言人3"
    },
    {
      "time": "00:27:20",
      "text": "你选扎尔菲O扎菲O你选一个14号的扎fino，最终渲染出来的一个单词可能会占100乘200这么大，这都是有可能的对。",
      "speaker": "发言人1"
    },
    {
      "time": "00:27:33",
      "text": "比如说它的F就会非常的高，有一个非常长的降度这样。",
      "speaker": "发言人3"
    },
    {
      "time": "00:27:39",
      "text": "然后他问那个问题，其实我我我理解是不是之前也遇到过，就是以前你们记不记得那个macos的那个text edit那个程序，他会他的那个他对他的那个中英文混排的时候，那个行高是有问题的。他他不一他不一致就不稳定，应该是这个问题。",
      "speaker": "发言人4"
    },
    {
      "time": "00:27:56",
      "text": "这个问题当时好像我们也讲过，好像对对对，他有个问题就是说当时的taxi好像是以整个文档的第一个字符的那个front来决定这个文档的行高是多少的。但是你在输入的这个flow fly的过程中，就是这个input fly的过程中，他好像又会动态的去调用当前这个gliff的front来计算当前这个光标所在位置的行高。所以如果说你是一个多语言，对对对就会有跳动。但现在好像这个问题被改善了。",
      "speaker": "发言人3"
    },
    {
      "time": "00:28:29",
      "text": "他会预设已经修复。我最近好像没有注意到这个问题了，就再没出现过了。",
      "speaker": "发言人1"
    },
    {
      "time": "00:28:35",
      "text": "对，已经修复了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:28:38",
      "text": "对，那他们中文和英文这个机械没有对齐这个事情是可能的发生的吗？还是说没有这个事儿。",
      "speaker": "发言人4"
    },
    {
      "time": "00:28:44",
      "text": "对，这是由盘面引擎来决定的。中文你可以是要它的基线来跟，不对，是用中文方字框的底线和英文的基线对齐，还是用中文线框的底线和英文线框的底线对齐，还是用中文线框的上框上顶端和英文的上升部的顶端对齐。",
      "speaker": "发言人1"
    },
    {
      "time": "00:29:11",
      "text": "这有很多。所以这几种有什么？就是我听出这个区别了，就是说我们日常采取的一般是哪种方式呢？",
      "speaker": "发言人4"
    },
    {
      "time": "00:29:17",
      "text": "一般是基线对，底线？",
      "speaker": "发言人1"
    },
    {
      "time": "00:29:19",
      "text": "我理解不是，一般是基线对。",
      "speaker": "发言人3"
    },
    {
      "time": "00:29:21",
      "text": "基线对，也就是说在正常的哪怕是中文或者就汉字的字体设计里面，现在真正的放在门也会画一个机卸。虽然说基线是给西文设计的，但是中文设计首先是有个字框，但是现在的现代字体都会在字框上面再补一个基线。因为不管怎么样，操作系统的话都是以机械来对齐的。现在无论是放是很多排版引擎，还有很多web都是这样。他只去调用这个一个缝里面的机械，所以他即就即使是中文字体，它也会设置一个机械。然后在很多的中文日文字体，比如说大家会默认中文的方框是那个字框是一千的一个正方形的话，一般来讲会把这个基线放在120左右，就是底下120，上面8 880，就是放在这样的一个位置。",
      "speaker": "发言人2"
    },
    {
      "time": "00:30:17",
      "text": "排版引擎的话，不管你是中文还是西文，它都会去调用你这个font里面的matrix里面的这个基线的位置。它是按基线对接的。无论你这个是阿拉伯文，还是印度的天橙文，还是中文的汉字，它们都有一个基线的值。",
      "speaker": "发言人2"
    },
    {
      "time": "00:30:36",
      "text": "所以印度天成就是天成文的那个基线在哪？是在靠下的位置。",
      "speaker": "发言人1"
    },
    {
      "time": "00:30:41",
      "text": "还是天成文它本身的基线，它是鼾音，它是挂在上面的对，但是他但是他为了混排的话，他也有他在他也在事先设自己设计是要设一个机卸，虽然他不用。",
      "speaker": "发言人2"
    },
    {
      "time": "00:30:55",
      "text": "这名字叫什么呢？是叫baseline还是。",
      "speaker": "发言人1"
    },
    {
      "time": "00:30:57",
      "text": "就是叫baseline？就是叫baseline。它本身那条。",
      "speaker": "发言人2"
    },
    {
      "time": "00:31:00",
      "text": "online叫什么？叫online吗？还是有天。",
      "speaker": "发言人1"
    },
    {
      "time": "00:31:03",
      "text": "成文他们自己的名字？",
      "speaker": "发言人2"
    },
    {
      "time": "00:31:05",
      "text": "对OK对，就是这个open type里面有一个table就叫base，就是base这个table就是描述的你这条baseline的位置在这个原始坐标00跟它相对的这个位置在哪里。其实它默认就在00这个位置上了。你在设一个中文字体的时候，你可以将你的这个起点，比如说设在零负多少，比如说-120，这个是adobe常用的一个数值。那么monotype可能会有什么-100百10之类。就每个字体厂商他们都会有一套自己的convention来做这个事情。",
      "speaker": "发言人3"
    },
    {
      "time": "00:31:39",
      "text": "所以，其实这个就是一个普通的字体文件里面，它matrix我们叫度量或者量度它的一个设置就自己设计是必须要设置的，然后再由排版引擎去。",
      "speaker": "发言人2"
    },
    {
      "time": "00:31:50",
      "text": "调用OK所以其实。",
      "speaker": "发言人1"
    },
    {
      "time": "00:31:52",
      "text": "不会出现这个中文他问的这个中文和英文机械没对齐的情况，对吧？",
      "speaker": "发言人4"
    },
    {
      "time": "00:31:59",
      "text": "这个好像还是可以改的。比如说像我说的，你可以强行说在这个排版的时候，或者说在这个label里面让所有字符底端对齐，这个还是可以做到的。可以的。如果你强行要这么设的话，还是可能的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:32:15",
      "text": "因为像那个CSS里面就是有一个基线对齐的概念。但是它它应该没有区分这个多元文本，它是整个和图片的对齐。那想来如果一个比较高级的排版引擎，应该也可也是可以允许做这种比较非标准的操作。",
      "speaker": "发言人4"
    },
    {
      "time": "00:32:33",
      "text": "如果是印刷方面的话，比如说in design的话，特别尤其是中西文混排的。比如在做复合字体的时候就可以做基线偏移。而且在在更广阔，在广的范围来讲，比如说把一个数字做成上标或者下标，这其实也是一种基线偏移，就是在不同的环境下，不同的这排版引擎都是有这样的功能的。那具体在CSS的话是另外的实现。",
      "speaker": "发言人2"
    },
    {
      "time": "00:33:00",
      "text": "对吧？对，CSS它是这样的，它的机制比较麻烦，它有一个所谓的line box和这个in line box的概念车。所以就是当他放大蒜的时候，对他会把一个行内的一小段字符串计算它一个很小的一个矩形，然后矩形的这个高度会有一个高度，然后基线会在这个矩形内部的一个相对位置里面。然后这个时候CSS的那个vertical align这个属性，这个property里面设了几种值，就会来决定这个基线之间相互对齐的关系。但这个vertical align的这个属性非常的不直观，这是我觉得这是CSS设计的一个缺陷。就是对于入门者来说，你很难去直观的感受到你做了哪些对齐。因为你有的时候选middle对齐的时候，你发现它其实并不是你预期的那种middle的方式。它是以它定义的那种middle的方式，然后baseline是任的一种对磁方式。对。",
      "speaker": "发言人3"
    },
    {
      "time": "00:33:59",
      "text": "这个还和字体有关系。",
      "speaker": "发言人2"
    },
    {
      "time": "00:34:02",
      "text": "CSS它会比较简单，它会对一段文字使用同一种字体的参数来计算这个line box的高度的这样一个属性。但是这个line box的高度他他算起来就不是很准，他也不是在所有地方都很准的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:34:21",
      "text": "而且它的首先它会调用，因为如果你是调用一个中文字字体的话，中文字体内部也有西文。首先它会调用一个字体设计师，他本身设定好的就是中西文的那个机卸。因为这个你调用的自己缝的本身是有这个信息的，然后他要拿到这个信息以后，在这个信息再继续调整。",
      "speaker": "发言人2"
    },
    {
      "time": "00:34:44",
      "text": "对，但CSS有个问题就是说他在计算一个line box的这个高度的时候，它默认是按CSS设定的那个line height的那个数值来计算的。对，但这个line height的值未必跟字体设计师定义的那个默认的line height是一样的。所以这个时候基线应该放在什么位置，其实是有一点问题的，有的时候是会出bug的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:35:08",
      "text": "High的话就是我们说中文就是行高。大家也知道这里面行高的话，它是要把行间距除以2，一半放上面，一半放下面那个盒子的对，所以这个盒子是怎么怎么算的？还是比较麻烦一件事情。",
      "speaker": "发言人2"
    },
    {
      "time": "00:35:28",
      "text": "对，特别是你多种字体混合组合的时候会有些问题。",
      "speaker": "发言人3"
    },
    {
      "time": "00:35:33",
      "text": "不同字体而且是不同字号的时候会非常麻烦。",
      "speaker": "发言人2"
    },
    {
      "time": "00:35:37",
      "text": "对。",
      "speaker": "发言人3"
    },
    {
      "time": "00:35:39",
      "text": "OK他他还问了第二个问题，是关于这个多语言字符串。",
      "speaker": "发言人4"
    },
    {
      "time": "00:35:44",
      "text": "关于多语言字符串的排序和索引，这个要讲吗？这个是我们今天我们要说的有点。",
      "speaker": "发言人3"
    },
    {
      "time": "00:35:52",
      "text": "关系或者说有关系。要不然我们等到后面专门一起来来讲的排序。",
      "speaker": "发言人2"
    },
    {
      "time": "00:35:58",
      "text": "因为对，要不我们就先念一下他这个邮件，就答不答再说了。如今是多元国际化的时代，多元字符串排序和索引的规则是什么呢？Iphone通讯录中姓名的排序规则是什么呢？对于整个问题，我自己也做我自己也做了一些研究，大致是unicode的给出了一套规则，根据这个规则来实现就好了。但是UNIQOD的文档卷卷纸浩反吗？真是件卷尺，我实在无能忘返了是吧？倦意这是卷纸是吧？",
      "speaker": "发言人3"
    },
    {
      "time": "00:36:29",
      "text": "就智智对。",
      "speaker": "发言人2"
    },
    {
      "time": "00:36:32",
      "text": "卷智好的豪华。",
      "speaker": "发言人1"
    },
    {
      "time": "00:36:36",
      "text": "我暴露了自己的文化修养。对。",
      "speaker": "发言人4"
    },
    {
      "time": "00:36:38",
      "text": "是要念错了，我实在无能为力，完全搞不懂。我自己总结了一点东西，写了三篇文章放在博客上，希望可以得到两位主播的指点。同时我自己也有一点问题没有搞明白，第一索引时指定的排序规则是什么呢？似乎是按照拼音，但是中文和英文交织，并不一定中文并不是中文一定在英文前面或者后面。怎样得到每一个汉字的读音呢？在指定汉字顺序的ZH dot XML，这是一个文件。汉字的读音在在井号之后似乎是被注释掉了。",
      "speaker": "发言人3"
    },
    {
      "time": "00:37:13",
      "text": "那么怎么知道汉字的读音呢？具体来说，左边的读音是左边，他写的是一个拼音的。左边是怎么被确定的呢？这个问题和字体排音没啥关系，和你们做的unit的串台节目有那么一点点关系，所以希望可以得到解答，这个问题已经困扰我好久好久了。他应该是拿了一个什么data base来做这个排序。",
      "speaker": "发言人3"
    },
    {
      "time": "00:37:36",
      "text": "不，这个事儿比较复杂。Iphone的那个通讯录，就IOS通讯录上面，它有一个这个机制，就可能很多iphone上我不知道有没有办法添加在mac上，是可以给联系人的名字叫加一个叫做phonetic那个注音。",
      "speaker": "发言人4"
    },
    {
      "time": "00:37:51",
      "text": "这是我想说的对，他说他有一个final，还有一个另外一个注音，就除了冯兰tic之外，还有另外一个注音，我忘了叫什么了。",
      "speaker": "发言人1"
    },
    {
      "time": "00:38:00",
      "text": "暂时然后这。",
      "speaker": "发言人4"
    },
    {
      "time": "00:38:02",
      "text": "两个可以拿来做排序的依据。但是排序的时候的那个比如说你用中文，就是你把系统设成中文的时候排序规则跟设成英文的时候排序规则是不一样的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:38:18",
      "text": "嗯哪哪怕你设成中文也可以用不同的排序。如果大家用mac的话，就放打开那个系统偏好设置的语言的语言地区那边就是专门有一个列表排列顺序的一个设置。然后中文默认是拼音顺序，但是中文你也可以用。比如说你用笔画顺序也可以用GB的那个那个内码的顺序也可以。",
      "speaker": "发言人2"
    },
    {
      "time": "00:38:42",
      "text": "对，但是在在手机上面有这个设置吗？",
      "speaker": "发言人1"
    },
    {
      "time": "00:38:46",
      "text": "跟你的语言环境有也有关系。",
      "speaker": "发言人4"
    },
    {
      "time": "00:38:48",
      "text": "我的理解是在用那个，你这就比如说你在麦克上面可以说我的系统语言是英语，但是我的第3 prefer language是中文。与此同时我要我可以把那个list sort orders设成中文的，比如说笔画排序或者是注音排序。但是在iphone上是没有这个设定的，就是你不能说系统语言是中文系统语言是英文的，同时你还可以指定中文的排序方式。",
      "speaker": "发言人1"
    },
    {
      "time": "00:39:19",
      "text": "就是我以前在推上跟好像是跟惊雷还是谁去去研究过一个问题。就是他想说手机的系统是英文的，同时还可以让通讯录按照中文的笔划出去排队，好像是。但后来发现这个其实是做不到的，就是当时我产生的一个状态是我先把手机设成中文，然后发现通讯录被用。中文IOS的默认通讯录排序是什么来着？是注音拼音，还是拼音OK然后当我切换回英文系统的时候，这个排序是得以保留的。但是只要我们往里面新加一个通讯录的，只要我们往里面新加一个联络人，整个排序就又变成了英文排序。然后所有的中文会被集中堆在后面，除非你设定了那个pontic span就principle，它才会在英文里面出现。",
      "speaker": "发言人1"
    },
    {
      "time": "00:40:21",
      "text": "我的情况，我的iphone是设置成日文状态的，所以我打开我的那个通讯录的时候，因为日文状态它会默认用。首先日文排序，首先右边那个index，右边不是有个快速的可以转播那个index。如果是这样的话，在日文状态的话，首先它会有日文的阿卡萨塔纳的顺序，然后后面还有26个字母的顺序。所以在这样的状态，日文和英文首先是分开的。因为我系统默认是日文，所以首先汉字是按照日文顺序排的。然后如果我当然我这里面有中国朋友，我的中国朋友如果我不加注音的话，它的中文汉字的是所有是堆在底下的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:41:06",
      "text": "但是我如果对井号的对。",
      "speaker": "发言人4"
    },
    {
      "time": "00:41:09",
      "text": "但是如果我因为这个注音这个字在日本是非常常见的。因为日本人的汉字如果你不加注音，根本都不知道他怎么念。所以一般来说对他如果是开成日文以后，他会默认首先把那个注音的那个field的打开，他会让你写中文的话，可能有时候他他默认不打开，很多人都不知道有这样一个field。在你日文的话，那个feel的默认是打开的，你可以往里面填这个词怎么念。我个人的做法是把中文这个名字，把它拼音写上去。这样的话在我的手机范围里面，日本人就在在贾明那一堆，然后中国人就按照拼音放在这个alphabet这一堆我个人是这样区分的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:41:51",
      "text": "这样好非常的好啊。",
      "speaker": "发言人3"
    },
    {
      "time": "00:41:53",
      "text": "但是很麻烦。",
      "speaker": "发言人4"
    },
    {
      "time": "00:41:54",
      "text": "你就你要没这是一个非常蛋疼的事情。",
      "speaker": "发言人1"
    },
    {
      "time": "00:41:57",
      "text": "对，所以在那个麦克上面，就是我们的朋友就是江江他之前写过一个小软件，就是自动给那个通讯录里面的中文名字的人标注他的那个phonetic names，就是丰田那个的姓和名。就这样他他就可以在应用环境下，还可以按照那个读音来排序。",
      "speaker": "发言人4"
    },
    {
      "time": "00:42:20",
      "text": "哼对这件事比较适合。",
      "speaker": "发言人3"
    },
    {
      "time": "00:42:22",
      "text": "脚本来做对对，但是iphone上好像就这个，我不知道有人有没有，应该也是可以的，就是把数据导一下。对，因为F那个通讯录是可以访问的，通过API然后你去改一下。在这里就会牵涉到他问的第二个问题，就怎样得到一个汉字的读音。因为这个比较简单的逻辑是有一个对照表的，就是汉字和他的那个拼音的对照表的。这个是很多系统里面都自带的，但这个比较tRicky的就是说有些字字是多音字。这个时候特别是在那个名字里面，它有些是很多是非标，没有就不具不太具备这个参考意义的。比如说有一些有些字的多音字，你是可以通过这个上下文的语义来看出他是念哪个的。但是在名字里面其实是一个非常arbitrary y的一个事情。比如说有一个朋友叫叫草字头，一个下面东南西北的西字，那个字他可以念汐。",
      "speaker": "发言人4"
    },
    {
      "time": "00:43:14",
      "text": "也可以念茜对吧？对。",
      "speaker": "发言人1"
    },
    {
      "time": "00:43:16",
      "text": "在在名字里面很多人都是把它念茜的对吧？但其实在他在选择的时候就把它念成念念西。这个时候你说你怎么办？他说你没有办法。",
      "speaker": "发言人4"
    },
    {
      "time": "00:43:27",
      "text": "对，这一点还好。另外有一个问题，就是有些人的这个信的同一个字的写法，它都是甚至都有不一样的念法。",
      "speaker": "发言人3"
    },
    {
      "time": "00:43:36",
      "text": "信的话一般做信的那个音会比较特殊的。",
      "speaker": "发言人4"
    },
    {
      "time": "00:43:41",
      "text": "就有一些会有白白毒。然后这个白毒又会被这个当成一种传统。比如说对我我印象最深的就是有一个姓叫盖，你们知道吗？就是盖子的盖盖叫天有一个经纪人员。对，但是这个姓其实他在念信的时候，一个比较规范的话应该念歌。对。",
      "speaker": "发言人3"
    },
    {
      "time": "00:44:04",
      "text": "朴素的最简单的不是朴树。",
      "speaker": "发言人1"
    },
    {
      "time": "00:44:06",
      "text": "朴树这个浦那个。",
      "speaker": "发言人2"
    },
    {
      "time": "00:44:08",
      "text": "浦上的对。",
      "speaker": "发言人1"
    },
    {
      "time": "00:44:10",
      "text": "不过他这个韩国人应该是小众。",
      "speaker": "发言人4"
    },
    {
      "time": "00:44:12",
      "text": "他应该是一个艺名之类的小众。但那个盖和格的问题就是很多人他都希望自己被念成叫盖，就是不要改成歌这个音。但是有一些人他可能祖上传下一直都念歌，所以他又希望这个字念阁，所以这个字念什么音其实也是不一样的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:44:30",
      "text": "所以就是说这刚才讲的那个问题，就姓名里面这个读音是没有一个规则可以参考。因为很多是靠他自己制定的一个选择来怎么念的，这个时候你就很非常尴尬。",
      "speaker": "发言人4"
    },
    {
      "time": "00:44:44",
      "text": "对而且这个问题其实并不仅仅是中文或者是在在在表意文字才有的。就在英文或者说在拉丁语拉丁字符世界，甚至是拼音字符世界也是有的。比如说前阵子被韩国被被朝鲜弄死的那个美国人，他的名字叫做warm beer。就是你如果你是一个美国人的话，你念他的名字你会念成one beer。然后有一天，但是warm和B这两个词其实就是地道的德语词，包括这个人的整个的名字，他的名字叫什么来着？",
      "speaker": "发言人1"
    },
    {
      "time": "00:45:19",
      "text": "Auto rubia这一听就是一个德国后裔，你知道吧？就是那种感觉就好像就好像这种感觉很奇怪，就好像你是一个华人，然后现在中国人已经是什么，刨去我们这一代，就是很多人都是双字名的。现在的中国小孩都起什么什么逸轩、子轩什么这种非常又农，说不出来奇怪在哪儿，但是有点奇怪的名字。",
      "speaker": "发言人1"
    },
    {
      "time": "00:45:50",
      "text": "然后忽然有一天你发现一个在美国出生的土生土长的华裔，名字叫曾国藩或者左宗棠那种感觉这就非常古典是吧？就对，就是auto，他的中名是什么来着？The fake对，奥托什么奥托弗雷德里克，拉比尔，对，这样一个名字。这个名字如果他是一个德国人的话，那么他的名字会编译成one b但如果他是一个美国人的话，包括德国人念他在广播里面念这个人的名字的时候，都会念成one beer，就是按美语的发音来来念。所以这就是为什么刚才说到的那个在iphone的联系人里面，你可以给他添加两个额外的项目。一个叫做pronunciation .",
      "speaker": "发言人1"
    },
    {
      "time": "00:46:47",
      "text": "spending .",
      "speaker": "发言人4"
    },
    {
      "time": "00:46:48",
      "text": "principle name，另外一个叫做for night。我记得这两个之中一个会被siri拿来当做发音的依据。",
      "speaker": "发言人1"
    },
    {
      "time": "00:47:01",
      "text": "对对。",
      "speaker": "发言人2"
    },
    {
      "time": "00:47:02",
      "text": "就比如说你比如说吴涛这两个字，你可以在在4 etic name里面写WUTAO，但是在pronation里面你可以写WOO dash TAU。比如说然后siri会试着用五套这个方法来念这个producing就。",
      "speaker": "发言人1"
    },
    {
      "time": "00:47:30",
      "text": "纯粹是给那个语音生成那个合成器用的是吧？",
      "speaker": "发言人4"
    },
    {
      "time": "00:47:35",
      "text": "对我我是这么理解的，但当然我从来没有用过，但我相信用过人他应该可以知道。比如说你可以你可以用这个功能来告诉siri说打电话给谁谁谁。这实现这样一个功能还有一个更直接的办法。",
      "speaker": "发言人1"
    },
    {
      "time": "00:47:49",
      "text": "就是siri的话你可以直接你直接语音。",
      "speaker": "发言人2"
    },
    {
      "time": "00:47:53",
      "text": "把这个字念教还是念成什么的。对。",
      "speaker": "发言人1"
    },
    {
      "time": "00:47:58",
      "text": "所以对所以就专门有这样的一个field，是给语音合成器来教他念读音的这样的一个field。",
      "speaker": "发言人2"
    },
    {
      "time": "00:48:07",
      "text": "对，这个fied好像只有这个IOS上才有，max上是没有这个field，我刚刚检查了一遍。对，因为mac上之前没有siri，所以估计没做。但现在也mac上也有CI现在有了怎么办？但是在那个contact就是通讯录的添加选那个叫什么来着？那个field的里面是没有那个字段的，没有pronation.",
      "speaker": "发言人4"
    },
    {
      "time": "00:48:30",
      "text": "只有finality。对，应该只有finality上面更新的那。",
      "speaker": "发言人1"
    },
    {
      "time": "00:48:34",
      "text": "未来anyway这个邮件里面其实还提了一个非常重要的事，就是说其实我我理解在这种多语言的时候怎么排序。比如刚才我们提到的这个日文环境和德语环境的时候，它都是有这个区别的。你没有想过这个问题。如果一个人他精通多国语言，比如说他会日语，然后韩语，然后会什么阿拉伯语的，然后他他还都有讲这种语种的，或者是这个名字的这个朋友他同学了怎么办？",
      "speaker": "发言人4"
    },
    {
      "time": "00:49:06",
      "text": "不过我们觉得应该把把这件事情说要分好多层次来说，别讲乱七八糟。首先是有一个代码层面的问题，对不对？有一个顺序。对，首先有操作系统层面的问题，然后还有APP层面的问题。对这几个层都都会影响到你最后看起来的最后的排序是怎么样的对。",
      "speaker": "发言人2"
    },
    {
      "time": "00:49:34",
      "text": "因为后来想一下，其实这种在多种语种，特别是多多语种混合环境下，还不是说一个系列的英语还相对来说可以兼容。像刚才讲的那种情况下，其实还跟你的这个叫做什么来着？政治策略有关系。正确。对对对，你说你说要把某种语言的虽然说unicode里面有一个顺序，但是如果你在某一种环境下，你把一种语言的名字排在前面，那种排在后面，其实多多少少会有一些的考量在里面。所以其实挺复杂的一个问题的那。",
      "speaker": "发言人4"
    },
    {
      "time": "00:50:10",
      "text": "不管怎么样，我们刚才从一个层面来讲的话，在操作系统层面，比如说IOS和mac s就不一样，对吧？针对一个语言的话，因为IOS它是移动的系统，所以它的一个语言它只有一个默认的排序。但是neck with上面跟你一个语言的话，你可以选好多个排序，你可以你是可以选的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:50:35",
      "text": "在操作系统层面，像刚才我们说的很最最典型的有很多需要这个通讯录，它是可以再另外加一个field的。还有一个很典型的是itunes，itunes它各种歌曲的名字，因为那个取名有也有个各国的取名。对，他在MP3的或者你在一个音乐的另一个meta data里面，你可以再继续把这个名像刚才注人的名字一样，把个歌曲的名字也是给他注音注进去也是可以的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:51:09",
      "text": "就是那个比较鸡贼，他其实做的不是注意，他直接给了一个选项叫做short order，就是排序的这个顺序去定，他完全不管。",
      "speaker": "发言人4"
    },
    {
      "time": "00:51:18",
      "text": "对，但是他至少就是他有一个meta data可以写。你往那里面写的话，然后i do就会去读那个feel的，对吧？是itunes他给提供的这样一个可能吗？就专门为了排序他提供了他做了这样一个功能。所以像这样的功能是application层面给他提设计出来，然后给他做的，对吧？",
      "speaker": "发言人2"
    },
    {
      "time": "00:51:39",
      "text": "对，如果你不在那边做的话，他会默认先去调用系统的顺序，对吧？他有个for back的顺序的。所以如果系统也没事的话，那那他直接就去读内马的顺序了，对吧？有你扣他默认的他他的真正的那个内码是什么顺序。",
      "speaker": "发言人2"
    },
    {
      "time": "00:52:02",
      "text": "所以看这个那现代软件里面多少复杂性就是由这些原因导致。",
      "speaker": "发言人4"
    },
    {
      "time": "00:52:12",
      "text": "好吧，我们今天终于可以讲讲正题了吗？",
      "speaker": "发言人2"
    },
    {
      "time": "00:52:15",
      "text": "今天正题还有正题。今天我们要讲一个非常开阔的问题。",
      "speaker": "发言人1"
    },
    {
      "time": "00:52:22",
      "text": "就是很多人都没有意识到这个问题的存在。今天我们要讲的是unicode的规范化形式，叫Normalization。很多人都讲那么edition是什么东西？",
      "speaker": "发言人2"
    },
    {
      "time": "00:52:34",
      "text": "你来自问自答一下好了。",
      "speaker": "发言人1"
    },
    {
      "time": "00:52:36",
      "text": "他他有中文的标准意义法吗？或者我们有什么什么推荐译法？",
      "speaker": "发言人3"
    },
    {
      "time": "00:52:42",
      "text": "因为unicode的它就是国标它就是国际标准IOSO。那ISO它又又是各国的都会写到自各国的国标国家标准里面。中国的国标就是ISO的那个中国国标是13000。然后他对这个Normalization翻译是叫规范化，我们在今天节目里面就叫规范化。",
      "speaker": "发言人2"
    },
    {
      "time": "00:53:07",
      "text": "要不然挺乱的。OK然后。",
      "speaker": "发言人1"
    },
    {
      "time": "00:53:11",
      "text": "很多朋友就不知道这还有一个规范化的东西，其实很简单。就是你看到的比如说带声调的字符，比如说拼音啊啊啊啊那个比如说那个是字母A上面加个所谓的第二声，对吧？你看到的是这样一个字形，可是它的背后可能是一个编码，或者它也可能是两个字符，两个编码。也就是说一个字母A的编码加上一个带声调的这个编码组合而成的一个东西。",
      "speaker": "发言人2"
    },
    {
      "time": "00:53:46",
      "text": "对，哼其实就是本质上unna ode的有一个现象，就是说当我们看到一串unicode的马位的组合的时候，他们可能在马位上是不同的。但他们实际上表示的这个字符或者是字符串是相等的。在用的口里有这样一个所谓的等，对。",
      "speaker": "发言人3"
    },
    {
      "time": "00:54:07",
      "text": "有一个等级数码专项。对，那主要是这主要还是一个本质上还是有历史的遗留问题。他如果当初不要一不是一定要兼容那个asp I的低位的话就不会。我是这么理解。",
      "speaker": "发言人1"
    },
    {
      "time": "00:54:24",
      "text": "但是而且现在是由于unicode是多语言的，那各个语言也都会有这样一个问题，所以这个规范化就越搞越烦。然后这个东西的话，有时候你要给它看成是11个字，因为比如要看成两个字，因为这有时候必须区别，就是带声调的和不带声调的肯定是两个字，不一样，你不能给它混在一起。但是有时候你要又要给他混在一起。比如说你在搜索的时候，你可能希望你只打只打一个字母A但是你能顺带你能把这些带声调的东西能一起搜索到，就是能在那个候选项能出来。所以这个时候你又习惯模糊的把这些全部带。所以这个是有这样的需求的。就是有时候你需要区别，有时候你又不想不区别。",
      "speaker": "发言人2"
    },
    {
      "time": "00:55:13",
      "text": "这里有个问题就是为什么要同一个码位要对应两个？最开始它它产生的原因是什么？刚才那个吴涛提了一个一个解释。",
      "speaker": "发言人4"
    },
    {
      "time": "00:55:22",
      "text": "但是不是是反过来，是反过来，是同一个字符会有多个码位，而不是同一个码位会对应两个字符。",
      "speaker": "发言人1"
    },
    {
      "time": "00:55:30",
      "text": "那就是就为什么会出现这种情况？就是它的历史背景是什么？",
      "speaker": "发言人4"
    },
    {
      "time": "00:55:35",
      "text": "最简单的一个，比如说当时欧洲各自都是都使用很多带有扩展符号的拉丁字符，所以当时SK的那个高位就被拿来做扩展，然后最常见的就是windows上那个叫什么CP1252还是。",
      "speaker": "发言人1"
    },
    {
      "time": "00:55:58",
      "text": "哪个代码页。",
      "speaker": "发言人2"
    },
    {
      "time": "00:56:00",
      "text": "对，windows直到今天都是在使用代码页这套机制，这套非常坑爹的机制。所以对这是一个这是一个不能忽视的历史问题。所以uni KO的一开始在做的时候，他的我记得是第一位的，完全兼容asking。然后此时就出现了一个问题，就是比如说UU上面加两点这个字符，那它就有可能出现它就等于在unico里面出现了两种组合的可能。一种是因为unicode的兼容，它固有的表达方式就是U这个字符是在哪个马位上，然后他会他直接把那个马位就呃坐进了unicode的里面，说在这个马位上面，unicode的这个马位上面，这里就是U上加两点。但与此同时他又给出了单独的一个U和单独的一个两点。于是此时你就又可以用说我要一个U然后上面加两点来做出。",
      "speaker": "发言人1"
    },
    {
      "time": "00:57:00",
      "text": "这个字符来。这个就是问题，就是为什么会有这种组合的需求存在？如果说我提一个比较极端的情况，就是如果说我们把所有的组合都是就组合后的字都变成一个独立的码位，就不存在这个问题了。",
      "speaker": "发言人4"
    },
    {
      "time": "00:57:17",
      "text": "因为首先一方面就是它比较节省空间，另外一个就是你如果你要组合的话，你是组合不穷尽的。尤其是比如说有些组合，一方面有些组合可能完全没有意义。另外一方面你比如说像越南语，就是一个字符上面可能有四五个，四五个可能太夸张了，三个应该是有可能，三个也可能。对你三个标音符号，然后你要把所有的convention都弄出来的话，这对于空间其实是很大的浪费。",
      "speaker": "发言人1"
    },
    {
      "time": "00:57:48",
      "text": "给大家一个比较更直观的一个例子，比如说汉语拼音那个屋上有两点是瘀，对吧？然后迂也可以带声调，晕云允运。对，所以比如说鱼对吧？那你你这因为单纯你就可以看见，上面加两点，再加那个第二声，这其实是这到底是一个字还是三个字？",
      "speaker": "发言人2"
    },
    {
      "time": "00:58:13",
      "text": "你这个例子举的不对，鱼应该那个YU的时候。",
      "speaker": "发言人1"
    },
    {
      "time": "00:58:17",
      "text": "我我我我不说那个单音节，我我不说单音节的情况，我不说那个汉语拼音那个音节情况，我单单是。",
      "speaker": "发言人2"
    },
    {
      "time": "00:58:26",
      "text": "说这个字符。对OK，比如说绿色的绿对你加了一个声调，然后此时这个双点和下降调都是存在的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:58:38",
      "text": "就是为了这个我们组合成部件，然后通过一个固定的方法来组合的，避免去存多种变种。",
      "speaker": "发言人4"
    },
    {
      "time": "00:58:47",
      "text": "对，一个是这个，另外一方面就是比如说像韩语，韩语那个字母的，它是把几个字母拼在一起的这一套合成机制，跟那个在字母上面加点的合成机制实际上是同一套。你如果你要把这一套，我要完全摒弃这一套，然后把所有的combination全都做出来的话，那韩语的completion那就恒河沙数，一个白曾经就直接还有吗？对吧？",
      "speaker": "发言人1"
    },
    {
      "time": "00:59:17",
      "text": "就可能导致什么？对，UTF18 2，UTF16就不够用了是吧？对。",
      "speaker": "发言人4"
    },
    {
      "time": "00:59:22",
      "text": "我记得微软好像为了这个事情就hack过这个事情，还把unique的标准给hike。所以uniq的标准在韩语有坑吗？",
      "speaker": "发言人3"
    },
    {
      "time": "00:59:32",
      "text": "还特别乱。对，特别乱。没有。首先是这样子的，如果大家觉得要审编码的话，就是说像就不用组合对吧？就给他当你就给它当成是一个东西的话，就会在不同语言里面会有不同的认知。比如说在德语里面屋上加两点，它就是一个字母。它对于普通的德文的母语者来讲，它是一个字母，它没有这种组合的感觉。像比如说在法语里面，它底下有个C底下可以加个软音符，然后像这样的这对于法说法语的人来讲，这是一个字母，而不会说是什么C加一个符号。",
      "speaker": "发言人2"
    },
    {
      "time": "01:00:12",
      "text": "对。",
      "speaker": "发言人1"
    },
    {
      "time": "01:00:13",
      "text": "所以在历史上而且在历史上就各国因为他自行的对阿斯卡进行扩充，所以在他也有一个向后兼容的一个需要。所以他必须有这样就当成一个字母的的这样的一个需求，然后又有想分开的需求。因为你有时候会加的不穷无穷尽，但还是说有有这种单独第二声的这样的一个东西，或者两点儿这样的东西，这样的你可以自由的往其他的字母上面加，这样明显是更灵活的，虽然很灵活，但是你又浪费了马位。就变成原来一个字符就可以搞定的东西，现在就变成两个字符了。然后就是现在的历史结果就变成有的时候要一个字符，有时候要两个字符，然后又有向后兼容性。那没办法，那就大家统统一起来unique的就搞得这样出一个这样一个Normalization，就是所谓的规范化的一个形式。",
      "speaker": "发言人2"
    },
    {
      "time": "01:01:12",
      "text": "而且其实我们刚刚一直在讲这个组合的问题。然后事实上unicode的这个等价性问题或者说Normalization问题，它不仅仅要解决组合的问题，它要解决的是两个字符之间，它们虽然码位是不同的，他们各自也只有一个码位的时候，他们也有可能是等价的。比如举一个例子，就是omega和这个单位欧姆之间，它其实各有一个码位，但他们其实本质上是完全是同一个字符，他们有的时候也需要一种等价的处理方式。",
      "speaker": "发言人3"
    },
    {
      "time": "01:01:45",
      "text": "对，这就是认知的问题。就是我们人类在说我看见这个符号的时候，我想的是哪一个东西？",
      "speaker": "发言人4"
    },
    {
      "time": "01:01:54",
      "text": "对对对，另外还有像日语的一些遗留问题，比如说日语有半角和全角的问题。",
      "speaker": "发言人3"
    },
    {
      "time": "01:01:59",
      "text": "这样对日语就坑多了。因为大家也知道，比如说像日本普通的50音图里面卡扣给加上两点儿就会变成浊音，就变成嘎勾。所以首先它就会有这种就我所谓的加点儿这种组合的问题。比如说咖如果是嘎的话，他可能是一个字嘎，也可能是咖加上两点变成的旮。首先就是有刚才说的这个组合问题，也有刚才字形不同的问题。就因为要有那个等价关系，一个他的话他可能可以是半角的，也可以是全角的。半角全半角的片假名是也是因为传历史上有这个阿里日本人自己扩展的问题，所以他必须有一个向后兼容性，他要保持这个半角片假名，就以前发电报时候用的，所以这也是一个向后金融留下来的一个坑。",
      "speaker": "发言人2"
    },
    {
      "time": "01:02:59",
      "text": "对，基本上就是当年跑步进入信息时代的这些国家各自为战，然后才导致了今天现在才导致了今天有什么ISO8859或者是这JS的start。然后unit不得不捏着鼻子把这些历史遗留问题全都收进来。所以才会有这样的问题。就如果我们今天能够把人类社会推倒重来，然后把信息技术从头再来的话，很多东西都会不一样。阿斯卡也是就编码也是里面的一个。",
      "speaker": "发言人1"
    },
    {
      "time": "01:03:33",
      "text": "所以这个规范化解决的问题其实就是说看它是一个可以理解为它是一个叫什么查查找的一个表。通过这个表可以找到说哪些unique ode的这种一个一个一一个uni字符串，它两个的意义其实是等价的。来解决这么一个问题。",
      "speaker": "发言人4"
    },
    {
      "time": "01:03:55",
      "text": "所以大家去看unicode的话，就专门它有个标准附录。那moralization是在标准附录的第15号里面，会有具体的这个组合是等于什么什么的。它有这个机制的介绍和各个语言的所有unicode里面带的一个Normalization的，它是一个表格都有。然后如果大家去看了，发现各个语言都有很奇怪的，就各种等价。",
      "speaker": "发言人2"
    },
    {
      "time": "01:04:19",
      "text": "对，其实我记得以前前一阵子swift的语言，当然比较这个部分可能比较内核恐慌。就是swift语言在好像在上一版里面又改变了字符串的那个表达方法。字符串现在又是一个collection，并且它就是支持你直接compare两个字出来，是否相等，然后这个相等的依据就是他们的在做unicode Normalization之后是不是相等。",
      "speaker": "发言人1"
    },
    {
      "time": "01:04:52",
      "text": "比如说你这两个字符串可能在败的层面上是不一样的。一个是一个的一个的一个自动少女的U上面加点可能是SK的马威220，另外一个可能是一个U加上两个点。但是如果你问在swift里面问这两个字符串是不是相等的话，所以它会说这两个字串是相等的对对。",
      "speaker": "发言人1"
    },
    {
      "time": "01:05:18",
      "text": "所以这个时候我不不太喜欢那个swift的地方，他老是把一些本来该交给这个library来做的事情，放到这个language的层面来搞，就搞得很乱。",
      "speaker": "发言人4"
    },
    {
      "time": "01:05:28",
      "text": "对他没有某一种选项机制，就是什么情况下我要认为他们是相等，什么情况下认为他们是不相等。",
      "speaker": "发言人3"
    },
    {
      "time": "01:05:36",
      "text": "其实现在是有的，就是现在理思路就是如果你把它当做一个string来处理的话，那么它默认是个unique的string。然后我刚才说的这个就是他们在Normalization之后，成相等就算相等。而如果你要一定要比较他们在外子层面上的大小的话，你需要取出他们的，我想想是叉set，还是你可以把它们转化为另外一种形式来比较，然后这样的话再比较就不相等。",
      "speaker": "发言人1"
    },
    {
      "time": "01:06:13",
      "text": "好吧，那看来这个Normalization是很必要的那我们再就给大家介绍各种不同的Normalization。规范化这是另外一个坑，就大家都来做规范化就好了。同样规范化就大家都按同样的规范化来做。",
      "speaker": "发言人2"
    },
    {
      "time": "01:06:27",
      "text": "这个事情不一样。对。",
      "speaker": "发言人1"
    },
    {
      "time": "01:06:29",
      "text": "这个坑真是的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:06:33",
      "text": "我们需要一个meta Normalization。",
      "speaker": "发言人4"
    },
    {
      "time": "01:06:36",
      "text": "其实这里有我觉得有两个层面。首先就是我们刚才说了这个规范化，它要解决的是两个unicode的都串它是不是等价这样一个问题。这个等价其实是有多种意义的，或者说有多种用途的。有的时候我们希望这个等价是一个相对来说比较严格的等价。他们只是我们对一种字符的分解方式或者组合方式的认知不同。有的时候我们可能对这个等价要求是比较宽松的，他们可能是一种更宽松的语义层面的等价。因为我们有这个搜索的需求，对吧？",
      "speaker": "发言人3"
    },
    {
      "time": "01:07:13",
      "text": "所以等价就是所谓的规范化，它有两大类，然后每个大类又有两小类，所以一共有4种。两大类就是标准标准等价和兼容性的等价。刚才说兼容就是为了大家能，比如说为了搜索能找到，所以它有个向后兼容的需求。那兼容的话它有两种，那标准分标准的规范化有两种，一种就是叫什么D型，有C型D型。C型那个叫什么？先分解。",
      "speaker": "发言人2"
    },
    {
      "time": "01:07:49",
      "text": "后合成？先d composite，然后再composite。",
      "speaker": "发言人1"
    },
    {
      "time": "01:07:56",
      "text": "然后地形的话就是分解掉这个暗的暗的分解掉，然后金融分解也两两小类也是金融的默认是分解的或者是兼容性的，先分解后组合。然后很坑的一点就是操作系统它又分别又采用了不同的方法，所以这个又跟操作系统有关系。那最近这个Normalization提上话题的话，就有一个很有意思的一个时机，就是因为刚好苹果要改文件系统了。",
      "speaker": "发言人2"
    },
    {
      "time": "01:08:32",
      "text": "OK上次到GDC出来消息。",
      "speaker": "发言人1"
    },
    {
      "time": "01:08:36",
      "text": "对。",
      "speaker": "发言人2"
    },
    {
      "time": "01:08:36",
      "text": "我们我们好像之前还提过了。",
      "speaker": "发言人1"
    },
    {
      "time": "01:08:39",
      "text": "对，现在我们跑的IOS10点几。",
      "speaker": "发言人4"
    },
    {
      "time": "01:08:44",
      "text": "来三点，现在的10.3已经是新的系统了。",
      "speaker": "发言人2"
    },
    {
      "time": "01:08:48",
      "text": "对。",
      "speaker": "发言人4"
    },
    {
      "time": "01:08:48",
      "text": "已经是APFS了。对，就apple file system。他你们知道为什么明明是apple five system，那为什么要缩写成APFS.",
      "speaker": "发言人2"
    },
    {
      "time": "01:08:59",
      "text": "而不不是AFS吗？FS被占了。",
      "speaker": "发言人4"
    },
    {
      "time": "01:09:04",
      "text": "对，原来因为有一个苹果文件协服务，apple f apple five six services。",
      "speaker": "发言人2"
    },
    {
      "time": "01:09:10",
      "text": "对，刚说哪个版本的CRA已经是APFS.",
      "speaker": "发言人3"
    },
    {
      "time": "01:09:15",
      "text": "下一个才会是嗨。",
      "speaker": "发言人4"
    },
    {
      "time": "01:09:17",
      "text": "这才是对IOS的话更快。IOS在10.3就已经把这个文件改为了APFS了。而在在之前，也就是说现在的我们的m mac都是HFS加。这是一个超好老，这个已经十几年。",
      "speaker": "发言人2"
    },
    {
      "time": "01:09:38",
      "text": "多少不多少长8几年的是8几年的文件系统超年了。",
      "speaker": "发言人4"
    },
    {
      "time": "01:09:43",
      "text": "对，终于要苹果一咬牙一狠心要换把它，给它换掉。那换掉了以后，就出现了一个问题，就是在这个新的APAPFS里面，他把原来的Normalize系统默认的Normal ization换掉了。因为新的APFS它是叫Normalization的insensitive，它是不敏感的对这个规范化不敏感的。所以就说无论他可以，到时候你就是他都能找到这个文件。因为刚才说了，他如果对他不敏感的话，搜索就更容易搜索到。无论你是用什么样的规范化来做的话，它都能指向这个文件。",
      "speaker": "发言人2"
    },
    {
      "time": "01:10:27",
      "text": "以前会有坑的问题，而对于用日语的朋友来讲，这个是最坑的问题。我们在我刚才说了，就因为日文经常要用，会涉及到就踩到这个规范化的坑。是因为日本像刚才说那个着音点是经常用的，然后经常会出现在日文的windows的文件名。考到mac的时候，刚才说凡是带有那个着音点的字儿放到mark里面就被被拆成了两个字儿。然后因为是两个字，你还可以一个字一个字删除，所以你可以把那个浊音点分别删除。这是因为在老的HFS加的时候，这也就是迈克现在用的这个系统里面，他对这个Normalization的处理是不一样的。因为它采用的是分解优先，所以他他会把这个字拆成认成是两个字。",
      "speaker": "发言人2"
    },
    {
      "time": "01:11:28",
      "text": "这里可能要解释一下这个背景，就是为什么从改了一个新系统会导致这个选的问题。因为HFS plus就是旧的文件系统，是对这个有一个默认的一个处理的。就是那个文件系统它其实是知道你写进去一个文件名，它会帮你去自动做一遍这个nomination。是这样，如果没记错的话，然后这个APFS其实就之前那个设计其实有点问题的。因为照理说一个文件系统不应该去掺和这种应用层的事情，对吧？因为这个。",
      "speaker": "发言人4"
    },
    {
      "time": "01:12:04",
      "text": "因为的事情吗？",
      "speaker": "发言人1"
    },
    {
      "time": "01:12:07",
      "text": "这显然是应用层的问题，因为文件系统应该就是这可能有一点。",
      "speaker": "发言人4"
    },
    {
      "time": "01:12:12",
      "text": "其实这里有个哲学问题，这也是我一个疑问，就是Normalization究竟是应该在这个存储的层面或者在层级上发对，还是在这个应用调用某一个数据的过程中对它进行实时的处理。",
      "speaker": "发言人3"
    },
    {
      "time": "01:12:26",
      "text": "因为本质上你说对于一个文件系统来说，它并不关心里面存的内容是什么。就是你给我一堆bites，对吧？然后我把这个bites按照某一种规则存编码，然后到到时候到时候你再问我要这对base的时候，我就把这对base就还给你。但是我需要一个key找到这对bites，这个key就是所有的文件名和路径。",
      "speaker": "发言人4"
    },
    {
      "time": "01:12:47",
      "text": "那么APFS最开始的他的那个逻辑，我我我记得当时他说过，他说对这个东西他是完全不过不过问这些东西，你给我什么，你给我那个文件叫什么，我就写什么。但是在HFS里面，它其实是已经他会去解析那个文件名的格式和内容的规范化。这个事情是一个逻辑的概念，它并不是它是我们在做这个叫做API的层面解决的问题。但是最终你写到那个磁盘上的那个那个东西的时候，它肯定是一堆被子。所以就是APSFPFS它的这个设计理念就是我我我我作为一个文件系统一个非常底层的东西，我不应该去掺乎上从逻辑API应该去解决的问题。",
      "speaker": "发言人4"
    },
    {
      "time": "01:13:32",
      "text": "不是real我明白你的意思，real我明白你意思。但是我有一个问题，比如说你说你说文件系统是一个非常底层的系统，那么请问获得一个文件的路径这些这件事情很底层对不对？那么获得一个文件的路径跟这个文件的名字是以什么样的标准化形式写出来的，有没有关联？",
      "speaker": "发言人1"
    },
    {
      "time": "01:13:58",
      "text": "对这个对我肯定有啊。不但这个不是文件系统，就在这个文件系统没有关系。因为文件中拿到最终都是一堆败词，他不需要去concern这件事情。",
      "speaker": "发言人4"
    },
    {
      "time": "01:14:09",
      "text": "其实他做了。",
      "speaker": "发言人3"
    },
    {
      "time": "01:14:10",
      "text": "一次先real的意思是说先规范化再存储这件事情不是在文件系统的层面上。",
      "speaker": "发言人1"
    },
    {
      "time": "01:14:17",
      "text": "发生的对，他是在一个他们叫做什么foundation.",
      "speaker": "发言人4"
    },
    {
      "time": "01:14:21",
      "text": "那个那个在放在操作系统的层面上发生的那最后是在操作系统和文件系统的，就管理文件系统那一部分的API里面产生的，而不是文件系统本身需要操心的事情。",
      "speaker": "发言人1"
    },
    {
      "time": "01:14:33",
      "text": "对，但这里就会导致一个问题，就是它就向后不兼容了。因为在HFS里面，它是就是文件系统确实管了这么一件事情的。所以操作系统和包括很多应用程序，它去不需要过度的去考虑这个问题。你用什么API去访问那个文件，反正你只要给到他他都会通过统一的方法规范化，然后形成统一的一个base然后再去通过那个base在文件系统里面去找，这最后就变成向后兼容的问题。",
      "speaker": "发言人4"
    },
    {
      "time": "01:15:00",
      "text": "但这个问题之所以在这个IOS里面没有暴露出来，是因为IOS并没有起码对用户而言，没有暴露出一个文件系统，起码到目前为止是没有的对吧？那么也就不存在不就并不会大量存在说有很多这个历史文件的名，它的规范化形式不太对，导致可能找不回来的一个问题。但是在mac里面就会存在这个问题了。因为m mac我们现在大量还在使用用户直接访问文件系统，大家还是用finder，对吧？所以就导致这么一个很尴尬的情况，所以现在都出的都是一些打补丁的方案。",
      "speaker": "发言人4"
    },
    {
      "time": "01:15:39",
      "text": "即使你没有你你一直用同样一个系统化，相对来讲还会好一些。那就主要是像跟和windows，不像windows因为它默认的那它规范化的方式不一样，所以从那边不同规范化方式里拷过来的东西就会有问题。你麦克一直都多用这样一个规范化形式的话，它其实还相对来讲，它的那个先后金融性是挺好的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:16:05",
      "text": "但是有一个问题是这样的，因为APFS如果按照最开始的那个设计理念，是不涉及规范化和你怎么就你不他他不涉及你的文件怎么编码，你甚至可以不用UTF8编码。",
      "speaker": "发言人4"
    },
    {
      "time": "01:16:18",
      "text": "理论上是可以的对吧？APP只接受有效的UTF8的编码的文件名。",
      "speaker": "发言人2"
    },
    {
      "time": "01:16:23",
      "text": "不，我就说就是说如果他只就是刚才讲如果他只管是拜次的话。",
      "speaker": "发言人4"
    },
    {
      "time": "01:16:28",
      "text": "就他只在字节层面上说你给我什么我就存什么。",
      "speaker": "发言人1"
    },
    {
      "time": "01:16:31",
      "text": "对对对，存什么就会有文件系统的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:16:34",
      "text": "对，就出现刚刚那个问题，就是说假设我们用那个，我们就是遵守这个apple的一个规范，用这些foundation的这些library去去命名文件，去访问文件。它是open file之类的API的话，那你可能得到的是一个路径，对吧？然后你再那个就是叫什么来着？命那个命令行的界面下，你用那个unique那套API去访问，又会得到另外一个文件的路径。它两个可能是不一样的。这个时候就会发现你用那个文件，你用那个麦克的那套API去存那个文件，然后你在unique上面找不回那个文件了，就很尴尬。",
      "speaker": "发言人4"
    },
    {
      "time": "01:17:10",
      "text": "这个事情当年也存在的话，像当年老麦克转成mico extent的时候。",
      "speaker": "发言人2"
    },
    {
      "time": "01:17:20",
      "text": "他换一个对吧？",
      "speaker": "发言人4"
    },
    {
      "time": "01:17:22",
      "text": "九改成真正不OSN的，是OSN是真正的unix。对，但是原来老的这个mac不是。对，所以他他那个路径的那个标志符分隔符都不一样，就是正斜杠反斜杠那个事情，那这是操作系统的事情，那这和他那个文件系统也不搭边。",
      "speaker": "发言人2"
    },
    {
      "time": "01:17:45",
      "text": "我们其实知道windows一直以来都是用NFC这种形式的对吧？这点应该没错。那么apple的话对apple的话HFS plus它是用哪一种形式的？是用NFC还是用NFD？",
      "speaker": "发言人3"
    },
    {
      "time": "01:18:03",
      "text": "这个还真的不知道。",
      "speaker": "发言人4"
    },
    {
      "time": "01:18:04",
      "text": "不知道。对我觉得这可能是第一个问题。然后第二个问题可能就是real刚才说的就是在HFS plus的年代里面，apple是就是说micros会做一件事情。他做的这件事情就是当你输入一个文件名的时候，他会帮你转成已经标准化后的形式，再存储到你的存储介质上，对吧？我理解的没错。",
      "speaker": "发言人3"
    },
    {
      "time": "01:18:30",
      "text": "应该刚才real也说的也是在这个文件错系统里面，它我们只说它的alizon，它是sensitive还是insensitive，对这个规范是否敏感，他没有在做，的确他只是在存储代码而已，存储的这个bit而已。但是他是不是对这个Normal ization敏感？",
      "speaker": "发言人2"
    },
    {
      "time": "01:18:52",
      "text": "对HFS是的确是对Normalization敏感。但是AFSAPFS它。",
      "speaker": "发言人1"
    },
    {
      "time": "01:18:58",
      "text": "就新的就不敏感了，他就不敏感了。对，这个和那个大小写也是一样的，就是sensitive。这叫什么case sensitive和case insensitive。",
      "speaker": "发言人2"
    },
    {
      "time": "01:19:13",
      "text": "这里还有个比较坑的一个事情，就是所谓叫做case preserving和noize ation preserve的问题。对。",
      "speaker": "发言人4"
    },
    {
      "time": "01:19:22",
      "text": "他可以保持按照道理保存下来，但是他对他不敏感，还是当成一样的是可保存，但是它不敏感，就是有这样的。现在的话就是新的APFS就是这样，它可以保存下来。然后NFC他也认得，NFD他也认得，但是他不敏感，所以两边都可以。",
      "speaker": "发言人2"
    },
    {
      "time": "01:19:45",
      "text": "其实按我的理解，apple并没有改它的这个标准化形式，它改的只是它对这个标准化形式是不是敏感这样一个问题。",
      "speaker": "发言人3"
    },
    {
      "time": "01:19:55",
      "text": "就是在这个处，所以他对这个文件文件名处理，他这个行为变发生变化了。",
      "speaker": "发言人2"
    },
    {
      "time": "01:20:01",
      "text": "刚刚我查了一下那个HFS plus用的是NFD的这种标准化形式。第一个问题就是跟windows肯定是不一样的了。",
      "speaker": "发言人3"
    },
    {
      "time": "01:20:12",
      "text": "分解优先。对。",
      "speaker": "发言人2"
    },
    {
      "time": "01:20:16",
      "text": "我们刚才把那个带过了，就是刚才讲的NFCNFD它到底是个什么意思？可能还要解释一下OK。",
      "speaker": "发言人4"
    },
    {
      "time": "01:20:23",
      "text": "FC就是先就等于是这么说，规范化有两个思路，一个是说什么叫规范化的最终形式，第一种思路就是规范化的最终形式是所有能够被拆分的东西都已经被拆分了，然后我存储这个形式。第二种思路是说存储的最终形式应该是所有能够被合成的东西已经被合成了，而且是按照某一种特定的方式合成，这是第二种思路。所以比如说B型规范化就是NFD的话，那就是说以标准方式分解到不能再分解了，那我的镖规范化的完成过程就就就就结就结束了。",
      "speaker": "发言人1"
    },
    {
      "time": "01:21:12",
      "text": "比如说刚才那个那个鱼的话的话，它就分成三就分成三个了，俩点儿，然后删掉它能分就尽量分。所以他我们看到是一个字，但是它背面它分成了三个码。",
      "speaker": "发言人2"
    },
    {
      "time": "01:21:25",
      "text": "对，一个是U一个是合成，一个是两点。然后如果你要是如果你说我要把它合成的状态作为最终状态的话，那刚才这个U就是就把它合成成一个字符串这样的情况。然后但是由于分解和解分解和合成又分别有所谓标准方式和兼容方式。所以你可以说标准方式分解结束还是金融方式分解结束，还是标准方式分解之后再以标准方式合成结束，还是以标准方式分解之后再以兼容方式合成结束，或者是反过来。对，基本上是一个come combination来的对。",
      "speaker": "发言人1"
    },
    {
      "time": "01:22:12",
      "text": "我我我想问一下为什么要做这么多种？我们的这个Normalization的目的不就是为了解决这个标准化的问题吗？为什么还要再搞4种不一样的方式呢？就他们之间各有什么，或者说应用场景是什么？",
      "speaker": "发言人4"
    },
    {
      "time": "01:22:27",
      "text": "我比如说以标准方式分解，分解到不能再分解了，这个实际上是非常适合编程的，对吧？",
      "speaker": "发言人1"
    },
    {
      "time": "01:22:34",
      "text": "就是你最小单元。",
      "speaker": "发言人4"
    },
    {
      "time": "01:22:37",
      "text": "就比如说你刚才说我刚才说那个swift语言，判定两个字符串相等的时候，那你就把他们全都拆成不能再拆的状况，然后看两个是不是一样，然后一个扣。如果是一样的话，那就不管他们原来是怎么样的对，这样就结束了。但是如果说你要换太。",
      "speaker": "发言人1"
    },
    {
      "time": "01:22:57",
      "text": "死板的话，对，就是你要拆的要先拆，拆的这么细了以后，要每一个部件都一样，他才认判定为是一样，对吧？",
      "speaker": "发言人2"
    },
    {
      "time": "01:23:09",
      "text": "对，但是这种方式的时候，就是就这种规范化的方式是只适合存储或者是比较的那如果你要把它以节省空间的方式显示出来的话，那你还是很有可能希望说我要把它最终还是要合成起来。",
      "speaker": "发言人1"
    },
    {
      "time": "01:23:31",
      "text": "就刚才那个拆的方式说可能会导致刚才是刚那个特殊的字符一就是一再加一个声调的话，它会从理论上它可以从一个一个点位变成三个点位，它的空间存储空间的要求变成三倍了。对，然后那我们如果就全部合到一起有什么不好呢？的确是为了比较好比如NFD的应用场景和FC的应用场景，它们各有什么不同？就是不能互相替代的地方。",
      "speaker": "发言人4"
    },
    {
      "time": "01:24:04",
      "text": "因为NFD你要少做一步计算，就FC你最终要把它合成起来。",
      "speaker": "发言人1"
    },
    {
      "time": "01:24:09",
      "text": "但是FD的你要付出更多的存储空间。",
      "speaker": "发言人4"
    },
    {
      "time": "01:24:13",
      "text": "对，所以这个就是一长一短。",
      "speaker": "发言人2"
    },
    {
      "time": "01:24:16",
      "text": "这就是时间，就是有时间换空间，还是空间换时间的间隔。",
      "speaker": "发言人1"
    },
    {
      "time": "01:24:21",
      "text": "对，所以这个就是逻辑问题，然后只是偏好问题而已，这个并没有什么对错或者怎么样。",
      "speaker": "发言人2"
    },
    {
      "time": "01:24:28",
      "text": "所以刚刚才提了一个的兼容分解和标准分解有什么不一样。",
      "speaker": "发言人4"
    },
    {
      "time": "01:24:33",
      "text": "我简单来说一下金融分解，我不把它说的非常细，金融分解要解决一个问题，就是说有一些有一些串，它在这个字符的bit的表达层面是不一样的。然后它拆分组合之后也是不一样的。但是我们希望认为它们是一样的。",
      "speaker": "发言人3"
    },
    {
      "time": "01:24:51",
      "text": "比如一个场景就是盒子的问题，比如FI盒子，那么FI盒子我们可以理解成它是一个F和一个I的两个字母的合成。但它同时又是一个单独的码位，就是unicode里面有一个码位，就是FI这个盒子了。我们在搜索的时候，用户可能输入FI盒子是非常复杂的，所以我们可能希望用户输入一个FI一个F和一个I我们可以把所有FI盒子相关内容也给它匹配起来。所以这个时候就是这个兼容性分解和合成所需要起到作用的这样一个场景。",
      "speaker": "发言人3"
    },
    {
      "time": "01:25:24",
      "text": "等一下这里我提一个问题，没好像没有区别，只用分解一次就好了，或者合成一次就好了。就是你你这个时候你讲这个问题是这样子，就是说有一堆文档里面包含这个FI的盒子和FI分解的两种情况，对吧？我们没有做对他做任何处理。",
      "speaker": "发言人4"
    },
    {
      "time": "01:25:41",
      "text": "这个时候你用户来了的时候，用户说输入FI我们希望把前面那个FI盒子和FI分开的都搜出来，对吧？这个时候有两种做法，第一个是说我们把我们之前存的一些文档全部做分解，就把FI的盒子一个一个扣point分成两个。然后这个时候我就可以直接跟那个用户输入的FI直接对比了。第二个方法就是说我们把用户输入的FI弄成一个盒子，同时把所有我们已有的文档里面的FI分开来弄成一个盒子。这个时候再搜索也可以了，对吧？就这两种操作方式。",
      "speaker": "发言人4"
    },
    {
      "time": "01:26:14",
      "text": "对对对。",
      "speaker": "发言人3"
    },
    {
      "time": "01:26:15",
      "text": "OK但是。",
      "speaker": "发言人4"
    },
    {
      "time": "01:26:16",
      "text": "因为你这就是为了兼容，用户并不知道这里面到底用的是盒子还是分开的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:26:23",
      "text": "但这里问题就是说这个标准分解和和这个兼容分解好像没有区别在这里面。",
      "speaker": "发言人4"
    },
    {
      "time": "01:26:30",
      "text": "这个区别就在于哪些东西是可以分的，就是说哪些东西是可以等价的。其实它们的区别就在比如说那个FI和字，它本质上不能完全等同于一个F和一个I它们本质上是两种不同的字符。有的时候我们希望他们是。",
      "speaker": "发言人3"
    },
    {
      "time": "01:26:46",
      "text": "等价的对他这个其实不仅仅是说这不纯粹是一个字符层面的问题，还是一个语就是语言层面的问题。比如说在有些语言里面的问题。对，在有些语言CH或者是SH是一个是被视成一个视作一个单独的字母。或者是在比如说像荷兰人里面，igg经常是一个单独的字母。",
      "speaker": "发言人1"
    },
    {
      "time": "01:27:11",
      "text": "另外就是对，另外就是有些语言里面一个字母可能有两种形式。比如说阿拉伯字字首字中字末一个字母是表达形式是不一样的。比如希腊语那个是sigma，sigma在词尾的时候写法和在词中不一样。就比如说那个英语里面的长S就是微积分那个符号，那个S他跟普通S也不一样。在德语里面，在旧式的德语政治法里面，如果他如果一个S出现在词中的话，你必须写成长S但是长S你用标准分解的话，你只能最终只能分解出一个长S但如果你用这样。",
      "speaker": "发言人1"
    },
    {
      "time": "01:27:53",
      "text": "因为它本来就是一个字符，它对它不管内部还是和它就是一个内部。",
      "speaker": "发言人2"
    },
    {
      "time": "01:27:57",
      "text": "对，而如果你用兼容分解的话，他会说这个S实际上这个长S实际上是S的一个变种，所以在匹配的时候我必须把它匹配成一个短S。",
      "speaker": "发言人1"
    },
    {
      "time": "01:28:08",
      "text": "就是说有一些便于搜索到，就有一些组合在标准分解，它是不能分解。但是为了让大家方便，他这样这个就把它拆就强行拆开了。",
      "speaker": "发言人4"
    },
    {
      "time": "01:28:21",
      "text": "对，是的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:28:23",
      "text": "天哪。",
      "speaker": "发言人4"
    },
    {
      "time": "01:28:23",
      "text": "这个对它有它有几种常见的形式，一种就是一个字母，它可能有一些字体设计，这个历史原因带来的不一样。比如说一个拉丁字母，它可以设计成好几种形式的，比如说什么有什么双层型之类的。这个双层是指这个视觉样式上，比如它有一个双勾线的这种形式。然后另一种形式，比如说有一些空白字符，他们可能都是一个空格，但是他们可能有我们知道unit里有非常多种空格，但是我们希望他们在搜索的时候或者在语音识别的时候，认为他们都是空格。",
      "speaker": "发言人3"
    },
    {
      "time": "01:28:56",
      "text": "这一都是y space。",
      "speaker": "发言人4"
    },
    {
      "time": "01:28:58",
      "text": "对，然后另外一种就是刚才吴涛说了，有一些语言里面有一些字母，它在不同的位置上，它其实会有不一样的写法。然后它也有不一样的unique的马蔚华对OK.",
      "speaker": "发言人3"
    },
    {
      "time": "01:29:07",
      "text": "对。",
      "speaker": "发言人1"
    },
    {
      "time": "01:29:07",
      "text": "然后接下来有一种，比如说数字有的是带圈的，有的是不带圈的那他们可能都是同一个数字一或者数字2，那么他们应该是一样的，就我们希望他们识别成一样的。然后日语里面假名有半角和全角的区别，然后汉语里面标点符号有竖排和横排的区别。然后还有像数学里面有上标和下标和非上标下标的这个普通数字的区别，但它们都是同一个数字。",
      "speaker": "发言人3"
    },
    {
      "time": "01:29:33",
      "text": "另外日语里面还有一些就是几个字母、几个字或者几个假名，它会组合成一起。比如说这个年号像什么平成，它可能会组合成一个字符，但它也可以写成平成这两个字。对。",
      "speaker": "发言人3"
    },
    {
      "time": "01:29:46",
      "text": "株式会社对对对，株式会社一个叠在一起的，选择个田字格的方式。",
      "speaker": "发言人4"
    },
    {
      "time": "01:29:52",
      "text": "对，另外就是算有分数，比如说2分之1，它可能有一个单独的马位就是2分之1，但我们也可以写成一写二战。",
      "speaker": "发言人3"
    },
    {
      "time": "01:30:00",
      "text": "对，这个例子很好。对我第一次我刚到德国的时候，最惊艳的一件事情就是德语键盘上有2分之1、3分之1这两个键，我靠。",
      "speaker": "发言人1"
    },
    {
      "time": "01:30:13",
      "text": "所以我问一下，刚才我们讲的很多都是这个外文的问题。",
      "speaker": "发言人4"
    },
    {
      "time": "01:30:17",
      "text": "中文有这个问题吗？中文我刚刚说了一个就是标点的横竖型，就是横排和竖排标点。",
      "speaker": "发言人3"
    },
    {
      "time": "01:30:22",
      "text": "但这个不涉及拆解的问题，它就是说把哪些对它本来不在一个马位的标点，但是因为我们认为它的在某一些情况下认为它是等价的。",
      "speaker": "发言人4"
    },
    {
      "time": "01:30:33",
      "text": "所以Normalization不只是一个拆分的问题，它有的时候也是单个字符之间相互的等价问题。",
      "speaker": "发言人3"
    },
    {
      "time": "01:30:39",
      "text": "对，中文是没有拆分和组合这个问题吗？",
      "speaker": "发言人4"
    },
    {
      "time": "01:30:42",
      "text": "中文基本上没有，但韩语可能就会有。",
      "speaker": "发言人3"
    },
    {
      "time": "01:30:45",
      "text": "那中文那个代语都是有这个问题，没中文。",
      "speaker": "发言人4"
    },
    {
      "time": "01:30:48",
      "text": "什么。",
      "speaker": "发言人1"
    },
    {
      "time": "01:30:49",
      "text": "他那有带圈子的话，就会有刚才那个兼容的问题。因为你他即使加了一个圈，但是比如说那个圈里面加一拆是吧？对对，就是圆圈。有人说要为他生几个特殊的马尾，这是另外的。还有比如说像什么括弧一对吧？括弧12345678都是汉字的对吧？像这些都是有那个兼容的，这样的看兼容的话，它拆成三个，前筷壶汉字一后括弧，就是它要这样热，以便于可以搜索到。",
      "speaker": "发言人2"
    },
    {
      "time": "01:31:24",
      "text": "中文其实也有这个问题。",
      "speaker": "发言人4"
    },
    {
      "time": "01:31:25",
      "text": "对吧？对，这些其实都是日本过来，我觉得最早应该都是日本人去申请这些马微。",
      "speaker": "发言人3"
    },
    {
      "time": "01:31:31",
      "text": "那我再问一下，是不是说现在不是流行那个火星文吗？火星不是只有半截式那个正常的字母。",
      "speaker": "发言人4"
    },
    {
      "time": "01:31:39",
      "text": "哦买噶部首都。",
      "speaker": "发言人1"
    },
    {
      "time": "01:31:40",
      "text": "是没有用的是吧？",
      "speaker": "发言人4"
    },
    {
      "time": "01:31:42",
      "text": "所以说一个火星文。",
      "speaker": "发言人1"
    },
    {
      "time": "01:31:44",
      "text": "能不能等价，是不是？",
      "speaker": "发言人3"
    },
    {
      "time": "01:31:46",
      "text": "对，你必然就是我们在实际使用的情况下，火星人火星文必然是等价为某一些这个就是非火星文的文本的。",
      "speaker": "发言人4"
    },
    {
      "time": "01:31:55",
      "text": "其实他也我觉得还是这个还是留给人工智能解决这个你强要一个Normal ization的过程，考虑这种情况实在是太强人阻拦不。",
      "speaker": "发言人1"
    },
    {
      "time": "01:32:08",
      "text": "我就说因为这个可能不用不需要在这个就不能写到规范里面去。但是如果说比如说我们现在在做一个审查系统对吧？我们做这个内容过滤，可能要过滤到某一些不合时宜的字的时候，你肯定还是要做这个火星文的拆解，然后做一个等价替换。",
      "speaker": "发言人4"
    },
    {
      "time": "01:32:27",
      "text": "你说能不能沿用unicode的，no less.",
      "speaker": "发言人3"
    },
    {
      "time": "01:32:31",
      "text": "就是它的逻辑肯定是逻辑。对它就是所谓的兼容分解。",
      "speaker": "发言人4"
    },
    {
      "time": "01:32:35",
      "text": "所谓的这个不一定，我觉得不一定，就要看你能不能设计出这样一套机制。因为其实Normalization有一个数学上特性，它叫密幂等性。就是你无论对一个串做多少次那么拉C之后最。",
      "speaker": "发言人3"
    },
    {
      "time": "01:32:49",
      "text": "结果最终是一样的。",
      "speaker": "发言人4"
    },
    {
      "time": "01:32:50",
      "text": "对对对，就是看你的设计的这套拆解和组合机制能不能符合这个幂等性。",
      "speaker": "发言人3"
    },
    {
      "time": "01:32:57",
      "text": "该开而且逆等于要倒回来。",
      "speaker": "发言人2"
    },
    {
      "time": "01:32:59",
      "text": "对，当然要能倒回来，倒不回来的话就不就不就都错了。对，所以我觉得火星人可能有问题，火星文有问题。",
      "speaker": "发言人3"
    },
    {
      "time": "01:33:09",
      "text": "那肯定是倒不回来的。比如说它原始的一个，我们刚才举那个一和上面有一个一撇一个情况。但其实我们想来它应该有好几种组合形式，对吧？它可以说是U组合，一个就是拆解三个位点，然后拼一起的方式，它也可以说是U上面就U然后再加一个薇音调，就两个点对吧？它也可以是U有声调再加两个点。那其实你拆解之后你是回不去的，它这个是一个单向的过程，就好像那个繁体中文转简体中文一样，你是不能过去。",
      "speaker": "发言人4"
    },
    {
      "time": "01:33:46",
      "text": "又回来的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:33:49",
      "text": "OK他应该不是个一个可逆的操作。",
      "speaker": "发言人4"
    },
    {
      "time": "01:33:53",
      "text": "为什么？",
      "speaker": "发言人3"
    },
    {
      "time": "01:33:53",
      "text": "对，因为你你丢失了你最开始。",
      "speaker": "发言人4"
    },
    {
      "time": "01:33:56",
      "text": "你丢失了一开始的信息，这是没错的。你你Normalize过后，你一开始是什么样你就不知道。",
      "speaker": "发言人1"
    },
    {
      "time": "01:34:04",
      "text": "对，所以他这个能做到B的，就是可以不断重复的做一个东西，而且他得到的结果是稳定的。但是他不能做，不能返回，不能再再逆回，就不可逆了。",
      "speaker": "发言人4"
    },
    {
      "time": "01:34:14",
      "text": "你就你的意思是你不知道他最初这个south究竟是哪一种表达形式。",
      "speaker": "发言人3"
    },
    {
      "time": "01:34:19",
      "text": "是对，你不知道是罗马仕就破坏掉那个信息了。",
      "speaker": "发言人4"
    },
    {
      "time": "01:34:23",
      "text": "对，OK, 但是他们永远是相等的。但是如果你拆这个汉字的话就不一定了。因为你本质上猜汉字就是把汉字拆成各种偏旁部首，然后把它们组合起来。但我们知道汉字这个偏旁部首，可能前一个字的一个偏旁可以成为后一个字的另一个偏旁。所以他们的组合方式有很多。这个时候他们他们就很容易等了。",
      "speaker": "发言人3"
    },
    {
      "time": "01:34:47",
      "text": "就是那个火星文的左右两边，你可能选出来的那个字是就是一个是选择左边那个部首，一个是右边，选的是右边那个部首，对吧？",
      "speaker": "发言人4"
    },
    {
      "time": "01:34:54",
      "text": "对对对，就有可能会有这种情况。对，这有可能会破坏这个幂等性的。",
      "speaker": "发言人3"
    },
    {
      "time": "01:35:00",
      "text": "所以还是挺坑的一件事。",
      "speaker": "发言人4"
    },
    {
      "time": "01:35:02",
      "text": "因为unique为了维持这个幂等性，它其实是做了很多工作的。包括它定义了这个拆解出来的部件的顺序。如果你破坏了这个顺序的话，就有可能破坏了这个密等性。所以它拆解的这个顺序是有确定的顺序的。比如有一些字母，它可能上面可以加一个点，下面也可以加一个点。那么哪个点是下面这个点在前，还是上面这个点在前？它其实是有固定顺序的。",
      "speaker": "发言人3"
    },
    {
      "time": "01:35:28",
      "text": "本期节目的那个show note里面还得注标注一下幂等性的一个连接。",
      "speaker": "发言人4"
    },
    {
      "time": "01:35:32",
      "text": "到底在幂等性，天哪，我靠。唐家，对，就是最后肯定我相信肯定有读者连着幂等性一路点点到什么唐家来什么，这就是一个数学问题。对，哥德尔不完备定理知道吗？",
      "speaker": "发言人1"
    },
    {
      "time": "01:35:52",
      "text": "在VPP的各种链接点点点，你最后都会点到那几个页。面对最终。",
      "speaker": "发言人3"
    },
    {
      "time": "01:35:57",
      "text": "肯定会回到哲学，我的印象为什么？",
      "speaker": "发言人1"
    },
    {
      "time": "01:36:07",
      "text": "刚才我们讲了Normalization的各种方法和它的背后的一些机制哈那就这样。然后我们回来讲那个APFS它在mac OS和IO层面到底不一样的地方，我觉得这个还是挺挺有意思的。因为照我的理解，APFS在macos里面对于某能性的处理是最近才决定的。其实我们在之前上那个IOS的APFS，他是没有考虑这个问题的。对，所以他现在搞了一个什么样的一个哈希的方式，我还没太明白你们谁看。",
      "speaker": "发言人4"
    },
    {
      "time": "01:36:43",
      "text": "我也不知道他因为他改成APFS，不管mac也是用HFS加还是用APFS，它都是这个Normalization insensitive的。它就他不敏感，他的他对你这个规范化形式不敏感。但是HFHFS他是他就直接它就直接存在那个磁盘上了。那APFS它会它是先规范化，然后这个文件名它会另外生成一个哈希值。哼来来指来给这个提供那个Normalization的，这个就不敏感性，要不然的话就找不到了。所以他必须再给他付一个自动付一个哈希值OK。",
      "speaker": "发言人2"
    },
    {
      "time": "01:37:31",
      "text": "这里面其实还挺麻烦的，因为有几个问题，就是刚才也讲的有几个事情揉在了一起。就是一个说他要不要保留那个就是你开始的这个，先说一下，还有个事情没说，刚才因为这跟你也有关系，就是IOS的那个文件系统是大小写敏感的，大小写是就是同样一个文件名，大小写不一样，他认为是不一样的的那个那个文件。在macos里面，不管是它不管是过去的HFS还是现在APFS，它默认的都是大小写不敏感。他认为但是。",
      "speaker": "发言人4"
    },
    {
      "time": "01:38:09",
      "text": "他是大小写保可保存。",
      "speaker": "发言人2"
    },
    {
      "time": "01:38:11",
      "text": "但是不敏感。对他会把你开始原始的那个大小写保留下来，但是就是说他不会说他会去区分这个事情。但是当然也可以就是说你在那个macos里面，你在格式化一个磁盘的时候，你可以选择让那个文件系统是做成大小写敏感的。但这个应该用的人不多，而且这样用的就会导致很多兼容性的问题，就是不太鼓励大家这么做的。所以这里面如果它是用哈希值的话，就会牵涉到这个问题了。如果它是大小写preserving，就是case preserving的话。",
      "speaker": "发言人4"
    },
    {
      "time": "01:38:43",
      "text": "他他哈希。",
      "speaker": "发言人2"
    },
    {
      "time": "01:38:45",
      "text": "的那个串是到底是什么？因为大小写不同的两个同样的字符串的哈希值是不一样的。对，这样的话他的他的这个他的case preserve和他的这个哈希的方式其实是有冲突的。所以我一直没太搞明白这里是怎么一回事。",
      "speaker": "发言人4"
    },
    {
      "time": "01:39:06",
      "text": "对我觉得先要给自弹自自唱的这个听众简单解释一下哈希是个什么样的过程。",
      "speaker": "发言人3"
    },
    {
      "time": "01:39:13",
      "text": "哈希你可以理解成为就是我们把一个字符串，然后通过某种数学的方式把它变成一个固定长度的一个数字。这边的可能都是，比如说是120，不对，它是一般16个字节是多少？16个字节是乘以8对吧？256个错了。",
      "speaker": "发言人4"
    },
    {
      "time": "01:39:39",
      "text": "就等于给他给给他一个生成了一个特定的一个个定号。",
      "speaker": "发言人2"
    },
    {
      "time": "01:39:46",
      "text": "对病程的会返回一个比如说256个bit的一个数，或者是512个bit的一个数。然后因为这个数其实足够大，你想一下二的256次方，这个数其实是非常大的。那么这个哈希有什么特性呢？就是说只要我们这个哈希算法或者是哈希函数选的少，我们可以做到在一个几乎可以忽略的概率上得到那个数和就两个就不太可能的。你不太可能拿两个有意义的文本得到两个完全一样的哈希的值。这个可能有很多人比较容易费解这个东西，就因为你想一下，这个在数学上是不可能的。因为你的那个字符串的就是你的那个函数的哈希函数的输入的那个space input space是远远大于这个output space。要它是一个固定的一个，它这个对它是个有限极，但你输入的其实是一个无限极。但是因为那个无限有输出，那个有限级的空间足够大，然后只要我们这个哈希函数选的足够好的话，我们是可以在大概率上认为是不会出现这种两个不同的输入得到同一个哈希值的。",
      "speaker": "发言人4"
    },
    {
      "time": "01:40:56",
      "text": "然后这个哈希值就我们可以拿来做很多事情，比如说我们可以拿来对把一个东西缩短成一个，我们认为它的是一个类似于指纹的一个概念，对吧？我们觉得它这一串哈希值可以对应那串原文，因为我们找不到另外一串原文跟这个可以得到同样的哈希值，然后APFS里面就他就是说我是用这个哈希值来保存文件的对吧？",
      "speaker": "发言人4"
    },
    {
      "time": "01:41:20",
      "text": "保存文件名。",
      "speaker": "发言人3"
    },
    {
      "time": "01:41:22",
      "text": "对，但我就不太理解，就是说这里面如果他怎么去解决刚才讲的那个case preserve的问题，其实我看起来觉得还挺难的。",
      "speaker": "发言人4"
    },
    {
      "time": "01:41:29",
      "text": "所以这有一个历史，就是在这个麦克维C的去年6月份，他已经他有做一个APFS的第一版的开发者的预览版。当时这个预览版里面只有case sensitive的版本。就是说明那时候苹果还没没想好就怎么做，你知道吧？所以当时他做的第一版的开发者预览，只能做case sensitive。对。",
      "speaker": "发言人2"
    },
    {
      "time": "01:41:57",
      "text": "大小写也就是最简单。",
      "speaker": "发言人4"
    },
    {
      "time": "01:41:59",
      "text": "对对对，然后等到后面macos的10.12.4了以后，给这个开发者的医疗板，后面他才补加的做出来这个case insensitive的版本。",
      "speaker": "发言人2"
    },
    {
      "time": "01:42:10",
      "text": "因为它这个是也是因为为了去填那个历史的坑，因为过去HFS它是默认是insensitive的，你就很很尴尬。",
      "speaker": "发言人4"
    },
    {
      "time": "01:42:20",
      "text": "对，所以其实就是他在在后面，具体他再再怎么搞，其实我也不大清楚。但是就是因为有这个坑，所以对，因为有这个坑，所以他他他也是花很长时间在搞的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:42:32",
      "text": "因为现在那个APFS那个SR还没有正式发布，现在指的是beta版，他们还有的有的机会改。但是如果说到了今年的这个九月份，也就两个月的时间。对，就会放出来。放出来之后如果没有这个问题没解决好的话，就会导致很多人的软件可能用不了，或者说是文件主问的情况。所以他们必须在这段时间把这个问题给彻底解决了。各用各种方式。就现在我们看到的其实也不是一个，我觉得应该也不是一个最终的版本。",
      "speaker": "发言人4"
    },
    {
      "time": "01:43:05",
      "text": "不过反正high server是可以定了，就是肯定要用新的这个APFS了。在安装过程中，它会默认的，它会先把你格式化一遍，你用吗？格式化。没有，但是升其实在升那个IOS10.3的时候就是这样的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:43:24",
      "text": "IOS都说了，他不存在这个，他不他不担心这个问题。因为IOS并没有，对，没有系统。而且IOS还有一个特性，就是它没有一个，它只有一套API去访问那个文件，就是都是用那个foundation那些库，它不像那个mac里面和我们用这个terminal的时候，就是直接用posc就unique那套逻辑去访问。所以它对他他考虑的那个那个难度就是要小很多。所以我觉得mac其实挺大的一个坑的。",
      "speaker": "发言人4"
    },
    {
      "time": "01:43:53",
      "text": "而且说实话这个东西对于用户来讲是完全看不见的。像我们刚才说的，他这个格式化的过程，它其实安就放到了那个安装进程里面去。你开始对于尤其是对于IIOS，你在装在更新的时候，用户不能做任何事情，反正你就等着他不要重重新启动两遍，反正就是新的了，就这样。",
      "speaker": "发言人2"
    },
    {
      "time": "01:44:16",
      "text": "而且就是用户计算即便知道了这个区别，他也改不了，做不了任何事情。因为你用的这个程序，如果没有更新去支持这个事情的话，你也是只能抓瞎了。",
      "speaker": "发言人4"
    },
    {
      "time": "01:44:26",
      "text": "对那对麦克的话可能就是因为如果万一搞不清楚的话，就会造成找不到文件了，对吧？因为Normalization不一样，文件名不一样，然后就和你支配是西班牙传统，很多西方家就找不到了，有时候就是最坑的最差的结果。",
      "speaker": "发言人2"
    },
    {
      "time": "01:44:47",
      "text": "所以这个Normalization这个事情会对我们交换在不同系统里面交换文件产生影响吗？就是因为现在有很多问题，比如说我不知道你们有没有收到，windows用户发给你们这种zip这种打包的这种压缩包，经常会乱码的事情，就经常会解解出来里面的那个文件，就是那个名字是乱的。",
      "speaker": "发言人4"
    },
    {
      "time": "01:45:08",
      "text": "但是那个乱码的机制很复杂的，为什么会乱？",
      "speaker": "发言人2"
    },
    {
      "time": "01:45:15",
      "text": "简单来说那个zip打包的时候，他会把那些文件名的信息也装进去，这个时候他用的那个encoding的方式就是zip。Zip这个格式其实是没比较灵活的，它不会要求说你一定要有什么input的方式。这个时候都是由那个打包程序决定的。但是解码的程序用如果用的跟那个打包程序他用的那个理解是不一样的话，就会导致这个问题。经常我们收到一个windows用户发过来打包的。",
      "speaker": "发言人4"
    },
    {
      "time": "01:45:44",
      "text": "但是这是编码层次的问题，比如说他没有用UTF8之类的这是编码和解码的事情。",
      "speaker": "发言人2"
    },
    {
      "time": "01:45:53",
      "text": "对对对，但是我就说如果是哪怕他们都是用的UTF8去编码，那个能不能进行不同的话，解出来会也会导致不同，也会不一样。对，没错，是的，所以这是一个非常深的一个坑。",
      "speaker": "发言人4"
    },
    {
      "time": "01:46:08",
      "text": "对对对，所以就刚才说一般遇到乱码问题的话，是编码层面的问题。而像我刚才说了，在日文的windows拷贝到mac上面，就会发现一个字被拆开来了，就会会有这样的问题。",
      "speaker": "发言人2"
    },
    {
      "time": "01:46:24",
      "text": "就是变成一个字，它变成两个字了是吧？两个字了。对，就是你看的也是两个字了。",
      "speaker": "发言人4"
    },
    {
      "time": "01:46:30",
      "text": "那看着就已经是两个字，就会就完全会被被拆开来。就是因为他他已经他从就透到那个操作系统层面上来后。",
      "speaker": "发言人2"
    },
    {
      "time": "01:46:41",
      "text": "变成就会因为系统不一样。那这个时候你们怎么办呢？",
      "speaker": "发言人4"
    },
    {
      "time": "01:46:46",
      "text": "没办法。",
      "speaker": "发言人2"
    },
    {
      "time": "01:46:47",
      "text": "就自己再重新编辑一下文件名。",
      "speaker": "发言人4"
    },
    {
      "time": "01:46:50",
      "text": "对，但其实这件事情并不是发生在Normalization的这个过程中。我觉得没错。",
      "speaker": "发言人3"
    },
    {
      "time": "01:47:00",
      "text": "这不是这个过程当中。但是毕竟是因为moderation它的采取的原则方式不一样。然后最后他而且原来你刚才也说了，就moderate这个事情，它其实是不会被用户所知道的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:47:15",
      "text": "其实他是这样的，就是说说明windows的某一个用户，他在输入这个文件名的时候，他输入的那一串字符其实就是一个被拆解的形式。他就被windows的这个操作系统记录下来并且保存下来。它传到这个OS ten上的时候，OS看就觉得这里其实是两个字符，那么我就把它们分开进行一个操作。比如说删除的时候，你能删除其中的一半对吧？对，但是其实两个操作系统之间，这里反而体现了Normalization的一个好处。虽然他可能输入的这个字符串行为是不一样的，但是至少我们在看的时候看起来他们是一样的，并且我们搜索的时候也能搜索到它。就是我觉得这个时候反而是Normal起到了一个保护的作用。就是它没有让整个文件名变得不兼容，而还起到了一定的最基本的兼容。",
      "speaker": "发言人3"
    },
    {
      "time": "01:48:09",
      "text": "哼对。",
      "speaker": "发言人4"
    },
    {
      "time": "01:48:10",
      "text": "所以在这种是必要的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:48:14",
      "text": "我问其实你们知道中国用户怎么解决这个问题吗？",
      "speaker": "发言人4"
    },
    {
      "time": "01:48:19",
      "text": "中国用户其实遇到的不算太多多。",
      "speaker": "发言人3"
    },
    {
      "time": "01:48:23",
      "text": "对，就为了就要避免在那个文件里面面使用中文，那就用拼音的首字母。",
      "speaker": "发言人4"
    },
    {
      "time": "01:48:30",
      "text": "代替就好啊。",
      "speaker": "发言人2"
    },
    {
      "time": "01:48:32",
      "text": "很多人这么干的。",
      "speaker": "发言人4"
    },
    {
      "time": "01:48:34",
      "text": "好吧，但其实这个完全是为了避免编码的问题。",
      "speaker": "发言人3"
    },
    {
      "time": "01:48:38",
      "text": "这也为了打字比较简单，总比你找字相对来说方便一些。所以我不知道这个eric你可能比较熟悉一点，就是在日文用户里面会有很多人用日文去命名那个文件名。",
      "speaker": "发言人4"
    },
    {
      "time": "01:48:52",
      "text": "对，那肯定OK.",
      "speaker": "发言人2"
    },
    {
      "time": "01:48:54",
      "text": "我其实经常。",
      "speaker": "发言人4"
    },
    {
      "time": "01:48:55",
      "text": "遇到的一个问题。比如说我看一个英文的文档，然后这个文档可能是排版的比较精细的，它里面有一些单词就会出现盒子。",
      "speaker": "发言人3"
    },
    {
      "time": "01:49:05",
      "text": "对。",
      "speaker": "发言人2"
    },
    {
      "time": "01:49:05",
      "text": "FI盒子搜不到。对，这个时候我用那个系统的自带的那个，比如说三指双击可以取词查查字典，这时候他查到那个字它就会识别不了，因为它里面带了一个盒子。我觉得这方面好像至少我现在用的这个c era还处理的不是很好。",
      "speaker": "发言人3"
    },
    {
      "time": "01:49:23",
      "text": "PDF会有这个问题吗？",
      "speaker": "发言人4"
    },
    {
      "time": "01:49:25",
      "text": "主要是对的，就preview这个APP，它在这方面的处理我觉得还不是特别的完善。它其实理论上它应该是帮你做好这个novation再去查字典。",
      "speaker": "发言人3"
    },
    {
      "time": "01:49:34",
      "text": "这里面跟那个PDF生成好像还有什么关系，这就是这这个对这个比较复杂。",
      "speaker": "发言人4"
    },
    {
      "time": "01:49:40",
      "text": "这完不完全是preview的错。",
      "speaker": "发言人2"
    },
    {
      "time": "01:49:43",
      "text": "对，就是规范有一定关系。",
      "speaker": "发言人4"
    },
    {
      "time": "01:49:45",
      "text": "对，跟PDF有关系，而且是，对，没错，是的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:49:49",
      "text": "但其实如果他用的这个兼容方式的，那么拉ation他处理的特别好的话，它其实可以绕开这个问题。他其实没有做这个兼容处理，他只是做了一个标准处理。可能但基本上。",
      "speaker": "发言人3"
    },
    {
      "time": "01:50:04",
      "text": "如果你在网页上的话，它应该还是可以正确识别出来。",
      "speaker": "发言人4"
    },
    {
      "time": "01:50:08",
      "text": "不一定，我觉得还真不一定。",
      "speaker": "发言人3"
    },
    {
      "time": "01:50:10",
      "text": "还不一定。",
      "speaker": "发言人4"
    },
    {
      "time": "01:50:11",
      "text": "不一定对。因为网页上很多时候你看到的这个lecture，可能它并不是一个真正的unique的lecture。它可能只是一个funt来显示出来的。那个是可能用户输的都是单独的字符，所以你不太会遇到这个问题。对。",
      "speaker": "发言人3"
    },
    {
      "time": "01:50:28",
      "text": "所以说这是你你看到东西其实一个很多很多层面的东西。你看到是一个字，它可能是两个字。但是变成一个字的时候，可能是系统帮你做的，可能是application帮你做，那也可能是放T帮你做的，这中间隔了好多道。",
      "speaker": "发言人2"
    },
    {
      "time": "01:50:45",
      "text": "对对对。",
      "speaker": "发言人3"
    },
    {
      "time": "01:50:46",
      "text": "所以人类为什么要给自己找这么多麻烦？",
      "speaker": "发言人4"
    },
    {
      "time": "01:50:50",
      "text": "其实说实话如果不unicode的话，就各国各自做各的就不会有这么多问题。",
      "speaker": "发言人2"
    },
    {
      "time": "01:50:56",
      "text": "但是就会有各种好多好多套规则比较。所以unicode对。",
      "speaker": "发言人4"
    },
    {
      "time": "01:51:03",
      "text": "就是这一个大熔炉，就什么东西都有，然后就会发生说以前不曾出现过的问题。",
      "speaker": "发言人2"
    },
    {
      "time": "01:51:10",
      "text": "知道吧？不对，其实你各搞各的也会出现这个问题，你还是要考虑比如你搜索的时候，你要考虑说做兼容的问题。无非就是说有有各个应用程序自己去搞，还是说交给uni QLE的这个组织来统一搞一套，大家都遵守这个标准来搞就好了。",
      "speaker": "发言人4"
    },
    {
      "time": "01:51:25",
      "text": "虽然很复杂，可能各搞各的问题更多。",
      "speaker": "发言人3"
    },
    {
      "time": "01:51:28",
      "text": "可能搜都搜不到。对。",
      "speaker": "发言人4"
    },
    {
      "time": "01:51:31",
      "text": "你你你一个汉字可能在这个big five里和在GB里面完全是不一样的内码，这个搜都搜不到。",
      "speaker": "发言人3"
    },
    {
      "time": "01:51:39",
      "text": "但是还好人类在这一个时机的话，又发现必须要做尤尼扣的。然后现在大家走上了尤尼克的阳光大道了，才发现还要做很多很多的向后兼容。",
      "speaker": "发言人2"
    },
    {
      "time": "01:51:50",
      "text": "哼但非常不幸的是，还有很多国内的网站还是用GB这个2312的。",
      "speaker": "发言人4"
    },
    {
      "time": "01:51:58",
      "text": "台湾有很多就在用big five，然后可能打开就会变成乱码。",
      "speaker": "发言人3"
    },
    {
      "time": "01:52:04",
      "text": "对对对。",
      "speaker": "发言人4"
    },
    {
      "time": "01:52:05",
      "text": "声明又又很不正确的，那个HTM声明。",
      "speaker": "发言人2"
    },
    {
      "time": "01:52:11",
      "text": "对我在台湾教育部好像还有一个网站是用big five。然后他那个网页不知道是出什么问题，用safari打开基本都会是乱。",
      "speaker": "发言人3"
    },
    {
      "time": "01:52:19",
      "text": "就默认就是乱的对对你要用手动去调，对浏览器。",
      "speaker": "发言人2"
    },
    {
      "time": "01:52:24",
      "text": "的那个那个就启发式判断的方法都已经失效了，特别坑。好吧，今天差不多讲到这里了。",
      "speaker": "发言人4"
    },
    {
      "time": "01:52:35",
      "text": "我其实想经通过这样一个节目，告诉我们的听众朋友，就说平时大家说uni k的，就感觉就编码对吧？就马位什么什么这些东西。其实uni co除了给字符编码的以外，他还有很多就是在unico，这个叫stand alex。Anees就是他一个标准的附录。然后这附录里面其实有很多文字处理方面的一些技术信息。比如说像今天我们说的这个Normalization，其实这是一个很复杂的一个技术环节的问题。这其实也是unique标准的其中之一是而且对作为uni KO的它是必要的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:53:18",
      "text": "然后像比如说我们上次在节目也提到，就比这次10.0里面增加了一个尤尼克的标准附录，就是uni KO的竖排文本。这其实也是必要的，就是说在横排和竖排之间是有什么样的关系，要给他提升到这样一个标准附录里面的话，能给这个他首先有一个core specification，就核心的这个标准的一个规范。还周边有这么多标准的附录，这样组合起来才是一个整体的unique的这样一个应该可以说是一个系统了，对吧？其实我们在自弹自唱的这个专题里面，其实我们还可以再讲很多很多关于这样的事情。",
      "speaker": "发言人2"
    },
    {
      "time": "01:54:07",
      "text": "关于这个number aliza的应用层面的问题。就是第一个我想问的问题是，作为一个软件的开发者来说，他多大程度上会遇到说我要去主动解决这个问题？Real你有没有遇到过要去解决这个问题比较少。",
      "speaker": "发言人3"
    },
    {
      "time": "01:54:24",
      "text": "其实因为特别是就特别操作系统和他的那个系统库都提供了这个标准的流程给你去去调用的时候，你肯你不要自己去搞，因为这样你自己去搞的话，有可能和系统的不兼容。但是你就有刚才提到那个难题，比如说在麦克S这种比较特殊的系统上面，它有多套API的时候，你就很你就比较尴尬了，因为他有unique unix那套比较底层的API和相对像foundation API那些比较高层的API的时候，那你怎么办？这个时候你可能要把这两个的，就哪些是支持什么样的nominalist的规范的可能搞清楚。然后具体说怎么实现，其实你是不用去太多考虑的，反正那些都是有有标准函数去去调用的。",
      "speaker": "发言人4"
    },
    {
      "time": "01:55:14",
      "text": "对对对，这个规范化的转换算法其实已经有一些非常标准的方式来实现。",
      "speaker": "发言人3"
    },
    {
      "time": "01:55:21",
      "text": "唯一作为开发者，你需要的知道的就是说你知道在什么时候用什么样的API去调用API什么样的结果，这个是比较重要的。",
      "speaker": "发言人4"
    },
    {
      "time": "01:55:31",
      "text": "所以去查文档的话，其实他肯定也就是说为了防止发生这个Normalization错误的话，就是去调用很广泛的API就完了。对这样对。",
      "speaker": "发言人2"
    },
    {
      "time": "01:55:43",
      "text": "另外还有个事情跟我们今天讲的有点关系，是real上次提到的那个IDN的一个伪装攻击的问题，是吗？就一个网址的一个漏洞。",
      "speaker": "发言人3"
    },
    {
      "time": "01:55:54",
      "text": "就pink code那个的问题。哼这个是一个这也是unique的一个坑。我们可以这里作为这个节目的事后的环节。",
      "speaker": "发言人4"
    },
    {
      "time": "01:56:05",
      "text": "所以顺便顺顺便吐个小槽，就是我们现在知道很多这个网站，它有一种叫做什么就钓鱼网站了，他骗你，他说他是这个银行某你的那个银行的网站，然后让你输入你的这个卡号密码，然后让你去转你的钱，对吧？但可能银行这个例子不太好，现在银行都有这个两步认证了，可能也不太那么容易去做。但是逻辑是这样的，就是我们传统的在浏览器里面去判定一个网站是不是你访问的那个网站的时候，你是看他的那个域名吗？对吧？域名其实就是一个字符串构成的东西，那坑就坑在于，因为unicode的里面也不叫这也不是unicode的，可能就是这个人类的问题。就是在某一些不同的语言里面，它的两个完全不同的字符，它看起来是一模一样的。",
      "speaker": "发言人4"
    },
    {
      "time": "01:56:58",
      "text": "比如说英文的第一个字母叫A对吧？但是希腊文的第一个字母叫alpha但是两个大写字母长得一模一样。",
      "speaker": "发言人2"
    },
    {
      "time": "01:57:07",
      "text": "对，在在过去不存在这个问题。因为在过去的话，那个域名7系统其实是一个非常简单的系统，它就只有SK就是它它只能用就是我们讲域名那个部分只能用哪几个字符，26个英文字母不区分大小写，十个阿拉伯数字，然后再加一个很短横线对吧？然后在这个点肯定没得说了，就是A就是A点B这个是可以知道的。然后后来为了支持所谓的多语言的这个域名我们中国其实也搞过CNIC，搞过所谓的中文域名，对不对？就是什么汉字域名。对，汉字域名什么什么点，中国很傻的。之前应该是90年代末的时候就流行过一段时间。然后之后谢天谢地，终于没有流行起来，对吧？",
      "speaker": "发言人4"
    },
    {
      "time": "01:57:58",
      "text": "然后刚才讲的那个希腊文的那个A和英文那个A就有问题。比如说你都想访问i apple点com就苹果的官网对吧？那你看的是apple点com但其实人家把那个A给换成了希腊语的那个A然后你看起来也是apple点com但是你访问的是一个完全不同的网站。这个时候，假的apple dot com这个网站，让你输入你的i cloud这个账号密码，你输不输呢？",
      "speaker": "发言人4"
    },
    {
      "time": "01:58:24",
      "text": "所以我觉得就是在域名这个比较关乎安全的这种领域里面，我其实挺反对去加入这种多语言支持的。虽然说听起来政治不正确，凭什么域名一定要是一个英文的一个东西，或者说对吧？或者说so其实也就拉丁文的东西。为什么韩国人不能用韩语做域名，中国人不能用中文做域名，日本人不能用日语做域名呢？但是你用了之后就会出现这种不可知的结果，这个时候就比较尴尬了。",
      "speaker": "发言人4"
    },
    {
      "time": "01:58:59",
      "text": "哼另外我还有个问题，其实就是如果我们输入两个在这个标准化之后是相等的uni KL的字符串，那么浏览器会认为它们是同一个域名吗？但是他们实际上是不一样的。",
      "speaker": "发言人3"
    },
    {
      "time": "01:59:19",
      "text": "这里面好像那个域名有一个叫pony，它是有一个规范的。但是这里要扯一个很很坑爹的事情，unique ode的规范是早于unicode的。",
      "speaker": "发言人4"
    },
    {
      "time": "01:59:29",
      "text": "是的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:59:31",
      "text": "就会有一个对他转换的问题。",
      "speaker": "发言人4"
    },
    {
      "time": "01:59:34",
      "text": "所以比如说我们刚才说比如说有一些字母，比如说像欧米伽，它就是两个完全一模一样的字符串。对在形式上，在语义的来源上也是一样。但它就是分裂成两个字符了，一个是用来表示物理单位的，一个是欧米伽这个字符本身。",
      "speaker": "发言人3"
    },
    {
      "time": "01:59:52",
      "text": "对，这个我没有去查过，但是照我的理解，应该是要先做unicode的规范化，然后再转成那个p code，才能拿到一个最终的一个结果。这个时候应该是一个唯一的一个点。",
      "speaker": "发言人4"
    },
    {
      "time": "02:00:06",
      "text": "但我不是，他们其实应该是一样的。",
      "speaker": "发言人3"
    },
    {
      "time": "02:00:07",
      "text": "是我我的理解应该是一样。不然的话就会出现刚才我说的另外一个问题，就是你看见的两个完全一模一样的，而且你用unicode的看都是一模一样的，或者unique e都是等价的两个域名。但是它其实访问两个不同的网站，这个时候你就非常坑爹了，对不对？当然这个事情可能也不会越来越不是一个事了。其实我们现在看很多这个移动网站上，你根本就不知道那个网址是什么，对不对？比如说你在这个微信的浏览器里面打开一个网站，你都看不见那个U那个URLURL了。",
      "speaker": "发言人4"
    },
    {
      "time": "02:00:41",
      "text": "对，所以最终你可能还是得靠一些证书之类的东西，就其他的一些工具来验证这个网站。",
      "speaker": "发言人3"
    },
    {
      "time": "02:00:47",
      "text": "是不是你想要反对。但也会你认一个人总是不能看名字。",
      "speaker": "发言人2"
    },
    {
      "time": "02:00:55",
      "text": "这里就会变成另外一个很好玩的事情，这个跟EM有关了，就是之前我前几天在那个推特上转发的一个事情。就是现在那个浏览器它不是前面靠那个地址的左边有一个小锁的图标来表示，这是一个加密连接。对，然后觉得你可能觉得很安全，然后你知道有那个emerge.",
      "speaker": "发言人4"
    },
    {
      "time": "02:01:18",
      "text": "里面是有一个锁的图标。",
      "speaker": "发言人3"
    },
    {
      "time": "02:01:20",
      "text": "的然后那个有些那个有些那个域名的有些顶级域名是支持em级域名的。就刚才我们讲unique的tuning的域名之外，他还真是一个的域名。这个时候有人就说画了一个，他做了一个他的那个域名的第一个就是一个锁，你知道吗？然后后面假设它是一个锁，然后HTTPS，然后这两点斜杠然后就是那个希腊字母的A的APPL点com这个时候你敢不敢访问这个网？对吧？",
      "speaker": "发言人4"
    },
    {
      "time": "02:01:55",
      "text": "所以我觉得这怎么这可能有点不太正确。但是我觉得这个事情是是是有有得有的有些事情你是不能做的。这样我说你不能在域名里面去加emerge，你不能在域名里面去加这个unique de的东西。这真的会把事情搞得无比复杂。",
      "speaker": "发言人4"
    },
    {
      "time": "02:02:14",
      "text": "就是本来大家只能考虑大家讲26个字母加十个数字再加一个横线才多少？才37个对吧？的一个一个那这个一个一个space的一个问题。现在突然你变成一个整个unicode的space就在那里，那是多少倍的一个复杂度的扩张。对于用户的认知理解来说，你是没有办法去做这个教育的。所以你看中中国用户大家还是比较乖的，大家干脆这个数字域名就不会出现这种情况了，对吧？163点com数字应该不会有这个长得一样的数字，但是不一样的点位。有也有。",
      "speaker": "发言人4"
    },
    {
      "time": "02:02:57",
      "text": "数字的nozing不是很多吗？",
      "speaker": "发言人2"
    },
    {
      "time": "02:03:00",
      "text": "天哪，对，有什么半高的这种数字，对不对？还有那个叫什么来着？",
      "speaker": "发言人4"
    },
    {
      "time": "02:03:07",
      "text": "另外罗马数字，那是罗马数字，就是罗马数字也是有罗马数字自己的马可以，对，但我们一般都是用拉丁字母来写，他们就用什么IV之类的字。",
      "speaker": "发言人3"
    },
    {
      "time": "02:03:18",
      "text": "对，所以我就觉得有些事情其实是都是一些政治的因素，让我们把这个事情变得非常复杂。本来技术是可以做的非常简单可靠稳定的，但是一会儿过来一个PM那会儿过来一个PM都在提这个需求，这个时候你就爆炸了。",
      "speaker": "发言人4"
    },
    {
      "time": "02:03:34",
      "text": "对其实说到这个UIL，我想起来就是其实W3C也是有一套自己的Normalization的机制的。",
      "speaker": "发言人3"
    },
    {
      "time": "02:03:45",
      "text": "对。",
      "speaker": "发言人4"
    },
    {
      "time": "02:03:46",
      "text": "当然他其实是基于uni code了。他当然他首先推荐的是NFC的这种标准化的形式，规范化的形式。同时我们知道因为W3C在网页上它其实有一个特殊的字符串形式，叫character reference。就是一个percent和井号键开头的，然后后面加一个数字的序列，然后加一个分号，这样一个可以用来引用到任何一个unicom的字符上的这样一个序列。这个系列如果你在网页上，在HTML里面输入的话，它其实要被这个nobilities ed成为另外一个真正的10亿的自付的，而不是直接保留这个东西。这个就其实是在unique ode的基础上扩展了一下。",
      "speaker": "发言人3"
    },
    {
      "time": "02:04:33",
      "text": "应该说那不就是那个puny code的吗？",
      "speaker": "发言人4"
    },
    {
      "time": "02:04:38",
      "text": "可以这么说，可以有机制是类似的，可能是，但他们的表达形式不太一样。",
      "speaker": "发言人3"
    },
    {
      "time": "02:04:47",
      "text": "这是一个挺沉重的事情，我觉得就反正我我在在我的那个理解里面，我是不建，就是我是反对。把一些其实你说一定有那么强的必要要用一个中文或者日文的域名吗？其实也没有，对不对？大家不也过得很好吗？就为什么要认为把这个事情搞那么复杂？就是太多的downside，没有很好的这个upset。",
      "speaker": "发言人4"
    },
    {
      "time": "02:05:15",
      "text": "但是对于这个网页来说，其实它有这些需求。比如你输入一些不可见字符的时候，你在HTML里面你可能输入这个character reference就变成可见了。那么对于程序员来说，这个是比较友好的一种形式。",
      "speaker": "发言人3"
    },
    {
      "time": "02:05:28",
      "text": "不，我就是说你不要在网页里面做这个，不要在那个那个域名和网址里面做这个事情。",
      "speaker": "发言人4"
    },
    {
      "time": "02:05:34",
      "text": "对对对，在域名里面。",
      "speaker": "发言人3"
    },
    {
      "time": "02:05:35",
      "text": "做的话就是要得有所节制，你知道吗？就是现在很多很多这个技术对技术产品之所以如此复杂，就是因为上面提产提需求的人？不考虑后果。",
      "speaker": "发言人4"
    },
    {
      "time": "02:05:54",
      "text": "好吧，今天我们就聊到这里。",
      "speaker": "发言人2"
    },
    {
      "time": "02:05:58",
      "text": "对。",
      "speaker": "发言人3"
    },
    {
      "time": "02:06:03",
      "text": "对了，我们这次要抽，我们这次就不抽奖了是吧？",
      "speaker": "发言人2"
    },
    {
      "time": "02:06:07",
      "text": "对对对，但是我们其实上一次抽奖的结果已经出来了，但是有一位听众联系不到，所以其实我们可以借这次节目先做一个通知。你说。对，就是之前的那个我们在第十个，就上一期，应该是第51期，我们公布了一个抽奖的通知。接下来了一周之后，我们这个抽奖的结果其实已经出来了。",
      "speaker": "发言人3"
    },
    {
      "time": "02:06:32",
      "text": "那么我们这次抽到的两位听众，都是来自支付宝捐赠的听众。第一位听众他的署名是翚，一个辉煌的辉这个单字。第二位听众署名是friend。第二位听众我已经联系上他了，他应该也已经收到了我们的奖品。但是第一位听众我没法联系到他。所以如果你听到这期节目，也可以直接给我们发邮件，发到podcast at the type点com来跟我们联络。然后我们会跟你进一步沟通，然后把奖品发给你。",
      "speaker": "发言人3"
    },
    {
      "time": "02:07:01",
      "text": "好，感谢大家的捐赠。别忘记了，和我们的联系的方法是podcast at the tale点com，有捐赠也就有机会参加我们的抽奖。我也今天我给大家准备了新的礼物，那等我们下次再说，好吧？",
      "speaker": "发言人2"
    },
    {
      "time": "02:07:18",
      "text": "好，感谢大家收听今天的节目。如果大家喜欢我们的节目的话，喜欢自弹自唱的话，就可以给我们捐赠。我们的捐赠渠道跟我们的邮箱地址是一样的，都是for cast at the type点com PODCAST at THETYPE点COM。同时大家也可以在社交网站上关注，我们在新浪微博、在推特、在微信上面，我们的ID都是the type HETYPE。那么在facebook上搜索type is beautiful也可以关注到我们。同时我们在知乎专栏上也会同步的发布每一期节目的这个节目简介。同时也欢迎大家关注type beautiful的网站，types beautiful点COM。",
      "speaker": "发言人3"
    },
    {
      "time": "02:08:03",
      "text": "感谢收听IP podcast网络旗下的IT技术主题娱乐节目内核恐慌，我们号称哈科尔，但是也没有干货，想听人听，想听就别听。您可以为本节目捐款，地址是在panic dota m slash donate。捐款金额随意，只要是bug证人入背就可以了。捐款不会给你带来什么，不捐也不会让你失去什么。我们的口号是no hard feelings。如果你有任何反馈，可以发邮件到ker，可以发电子邮件到kernel panic at IPNDLI。同时也欢迎你收听real主持的风投圈，风投圈现在好像改成收费的了。",
      "speaker": "发言人1"
    },
    {
      "time": "02:08:38",
      "text": "对，OK.",
      "speaker": "发言人4"
    },
    {
      "time": "02:08:39",
      "text": "我还在旗下的其他几档节目未知道太医来了、流星通讯、high story映影像、无次元博物志、选美陛下、关一天世界、时尚怪物。我们下期节目再会，拜拜拜拜拜拜拜。",
      "speaker": "发言人1"
    }
  ],
  "lab_info": {
    "summary": "本期播客，聚焦于技术领域的复杂议题，包括Unicode字符规范化的重要性，以及其在不同语言和字符集处理中的作用。讨论深入字符规范化形式，如NFC和NFD，强调了操作系统对文件名敏感性的影响，同时探讨了国际域名（IDN）的使用，指出了多语言域名可能带来的安全挑战。对话不仅覆盖了技术实现的难点，还提及了播客制作、与听众互动等方面，展现了技术与内容创造的交融。特别地，播客强调了自弹自唱和内核恐慌在各自领域的独特地位，以及对技术细节和最新动态的关注，为听众提供了深入的见解和娱乐。此外，还预告了涉及中文字体设计的课程信息，整场对话风格轻松，旨在促进深入交流。",
    "qa_pairs": [
      {
        "question": "我们四个人第一次一起线下见面是什么活动？",
        "answer": "那是TIB10周年活动节目，也是我们自弹自唱和内核恐慌串台的第五期。",
        "time": "00:00:29"
      },
      {
        "question": "四个人在一起的合影最后是否拍了？",
        "answer": "当时没有拍到四个人都在的合影，只有我和real与其他两位合过影。",
        "time": "00:02:20"
      },
      {
        "question": "七月份的type school课程是什么内容，持续多久？",
        "answer": "七月份的type school是西文字体设计课程，持续了两个礼拜，我自己也过去和大家凑了个热闹。",
        "time": "00:03:01"
      },
      {
        "question": "格尔格老师是一个怎样的背景？",
        "answer": "格尔格老师是字体设计师出身，但具备计算机开发基础，全职在做字体设计软件grips。",
        "time": "00:03:36"
      },
      {
        "question": "八月份的type school中文字体设计课有什么特点？",
        "answer": "八月份在北京开课的中文字体设计课将由方正字库的经验丰富的设计师授课，会教大家如何实现字库，从12个字扩展到5000多个字，并且优秀的学员有机会与方正签约合作。同时，学员还能接触到grips软件，并由其开发者奥格格参与活动。",
        "time": "00:04:05"
      },
      {
        "question": "关于打字机没有回车键的说法，实际情况是怎样的？",
        "answer": "打字机确实没有专门的回车键，换行是通过拨动滚轮实现的，滚轮左端的手柄兼具回车与换行功能，而非现代意义上的回车键操作。",
        "time": "00:07:44"
      },
      {
        "question": "Pages软件在编辑文章结构方面与word有何不同？word中对于格式修改的一致性和统一性处理如何？",
        "answer": "Pages软件允许用户先定义文章结构，如标题、正文和表格内容等，并且可以通过改变特定类型的文本样式，实现整个文档中该类型文本风格的一致更新，而word在这一点上实现起来相对不那么稳定。word并不强调结构和格式统一的概念，用户可以随意修改，导致一致性问题，而专业用户在使用word编写长文档时，通常会依赖于样式表来进行格式管理。",
        "time": "00:16:28"
      },
      {
        "question": "在word中使用格式刷是否会出现不稳定的情况？word中对于格式修改存在哪些具体问题？",
        "answer": "是的，在word中使用格式刷确实会出现不稳定的问题，尤其是在处理长文档时，可能会因为多种格式并存且不易统一管理而变得混乱。word格式修改存在多种格式可能随着文档页数增加而变得复杂多样，且在小细节调整上容易出现问题，例如两个字之间出现的额外空格等问题。",
        "time": "00:17:31"
      },
      {
        "question": "对于word格式修改，为何需要高度自律？",
        "answer": "因为word中格式刷功能存在局限性，如果用户不保持高度自律，可能会在格式调整上遇到许多问题，比如格式刷无法恢复某些细节格式变化，以及格式一致性难以保证。",
        "time": "00:18:10"
      },
      {
        "question": "中文打字机相较于英文打字机有何不同之处？",
        "answer": "中文打字机在使用时对力度有严格要求，轻则字迹不清，重则纸张受损，而英文打字机则没有此限制。此外，中文打字机采用滚筒式打字原理，通过控制手柄压力来决定字迹深浅。",
        "time": "00:18:44"
      },
      {
        "question": "关于AMOJ表情符号的相关新闻是什么？",
        "answer": "最近有新闻提到7月17日是MG日，苹果在其官方网站上预告了今年晚些时候推出的iOS11版系统中的新表情符号，包括僵尸、穆斯林女性等，并已在iOS11 beta版中可供预览。",
        "time": "00:21:21"
      },
      {
        "question": "听众tiger老虎提出了哪些问题？",
        "answer": "tiger老虎询问了关于中西文混排时文字最终展示高度如何确定，以及在中英混排情况下，文字高度是否会比纯英文或中文还要高，同时他也询问了关于多语言字符串的相关问题。",
        "time": "00:24:47"
      },
      {
        "question": "排版引擎在处理不同文字时，如何确定基线位置？字体文件中关于基线的具体设定名称是什么？",
        "answer": "排版引擎在处理任何文字（包括中文、西文、阿拉伯文、印度天成文等）时，都会调用字体文件中的matrix中的基线位置。无论何种语言，它们都有一个固定的基线值。这个设定的名称就是baseline，并且在OpenType中对应一个名为“base”的table来存储这个信息。",
        "time": "00:30:17"
      },
      {
        "question": "印度天成文的基线位置是在上面还是下面？",
        "answer": "印度天成文本身的基线是靠上的，但在混排时为了适应也会设定一个机卸（即baseline），这个值可以是固定的，例如在OpenType格式中有一个名为“base”的table来描述baseline在原始坐标原点的位置。",
        "time": "00:31:05"
      },
      {
        "question": "在线排版中如何控制字符底端对齐？",
        "answer": "在CSS中可以通过vertical align属性实现字符底端对齐，尽管其设置方式可能不够直观。而在更专业的排版软件如InDesign中，可以进行基线偏移以达到对齐效果。",
        "time": "00:32:15"
      },
      {
        "question": "CSS中的基线对齐机制如何工作？",
        "answer": "CSS通过计算line box的高度并基于line height属性来决定基线的位置，但这个过程可能存在不准确之处，因为它默认使用的line height值可能与字体设计师设定的默认值不同。",
        "time": "00:34:44"
      },
      {
        "question": "对于多语言字符串的排序和索引规则，尤其是像iPhone通讯录中的姓名排序规则是怎样的？",
        "answer": "iPhone通讯录中的多语言字符串排序规则遵循Unicode标准，但具体实现较为复杂。在不同的系统设置（如语言和地区）下，排序规则也会有所不同，例如中文和英文的排列顺序会依据系统偏好设置的不同而变化。对于汉字读音的获取，通常依赖于操作系统内置的排序规则和对照表，但对于多音字和非标准读音的情况，则可能需要依据上下文语义或其他特定规则处理。",
        "time": "00:35:58"
      },
      {
        "question": "在英文或拉丁语世界中，是否存在名字拼写与发音不一致的情况？",
        "answer": "是的，这种情况在英文和拉丁语世界中同样存在。例如，前阵子在朝鲜被美国人暖死的温某，其名字在德语中是\"warm beer\"，如果按照美语发音规则念会是\"one beer\"，而不是原名的地道德语发音。",
        "time": "00:44:44"
      },
      {
        "question": "苹果手机的联系人里如何处理名字的多种发音方式？",
        "answer": "在iPhone的联系人里，可以添加两个额外项目来标记名字的发音，分别是pronunciation和spelling variant。例如，对于名字“吴涛”，可以在pronunciation中写WUTAO，而在spelling variant中写WOO dash TAU，这样Siri可以根据这些信息尝试不同的发音方法。",
        "time": "00:45:50"
      },
      {
        "question": "这些额外的发音字段是给语音合成器使用的吗？",
        "answer": "是的，这些字段主要是为了教语音合成器如何正确读音。只有iOS系统上才有这种字段，macOS上虽然有Siri但没有这个字段，不过在通讯录和其他应用中也能通过meta data来实现类似功能。",
        "time": "00:47:58"
      },
      {
        "question": "在多语言环境下，如何处理和排序混合多种语言的名字？",
        "answer": "处理多语言混合环境下的排序问题需要从操作系统层面、APP层面等多个层次考虑。例如，在iOS系统中，对于一个语言会有默认排序，而在macOS上可以设置多个排序顺序。此外，通讯录和iTunes等应用可以通过额外字段（如spelling variant）或专门的排序顺序选项来控制名字的排序方式。",
        "time": "00:50:10"
      },
      {
        "question": "Unicode规范化（Normalization）是什么？",
        "answer": "Unicode规范化是指在Unicode标准中，对于同一个字符可能会有不同的编码组合，但它们在视觉上显示为同一个字符。规范化处理旨在确保跨语言、跨平台的一致性和可预测性，解决因编码方式差异导致的混乱问题。同时，Unicode还存在一些历史遗留问题，如为了兼容某些字符编码表而出现的同一字符对应多个码位的情况。",
        "time": "00:53:11"
      },
      {
        "question": "在历史上，为什么阿斯卡编码需要有向后兼容性以及字母组合的需求？",
        "answer": "因为各国自行对阿斯卡编码进行扩充，导致了对阿斯卡编码的扩展需求。在处理字符时，有时需要有向后兼容性，例如保持原有字符的书写方式。同时，在编码中又存在组合问题，即同一个字符可能通过添加符号变为另一个字符，虽然这种灵活性可以支持更多字符表达，但也增加了字符长度，原本一个字符可以表示的内容现在可能需要两个字符来承载。因此，为了解决这种灵活性与兼容性的问题，出现了规范化（Normalization）的概念，旨在统一处理字符组合和等价性问题。",
        "time": "01:00:13"
      },
      {
        "question": "Unicode的等价性问题和规范化处理是如何解决的？",
        "answer": "Unicode的等价性问题不仅涉及组合问题，还涉及到即使两个字符码位不同但含义相同的字符间的等价处理。例如，omega和单位欧姆虽然各自有一个码位，但在某些情况下被认为是同一个字符。规范化通过创建一个查找表来解决这个问题，该表可以帮助找到在Unicode中具有等价意义的不同编码形式，并进行统一处理。",
        "time": "01:01:12"
      },
      {
        "question": "日本语言中的半角和全角问题如何影响Unicode规范化？",
        "answer": "日语中有半角和全角的区别，这源于日本国内扩展阿斯卡编码的历史遗留问题，必须保持向后兼容性，即保留半角片假名。这种历史遗留问题导致在Unicode规范化过程中需要考虑到不同字符形态和等价关系的处理。",
        "time": "01:01:59"
      },
      {
        "question": "swift语言在字符串比较上是如何处理Unicode Normalization的？",
        "answer": "在swift语言中，默认情况下，两个字符串被视为经过Unicode Normalization后的相等，即即使底层字符形式不同，只要规范化后的结果相同，就会认为两个字符串相等。但如果需要比较原始层面上的大小，则需要采取额外措施去除规范化影响。",
        "time": "01:04:19"
      },
      {
        "question": "Unicode规范化有哪些不同的类别？",
        "answer": "Unicode规范化主要有两大类：标准等价和兼容性等价。标准等价包括D型和C型，其中D型是先分解再组合，C型则是先组合后分解。而兼容性等价同样有D型（分解优先）和C型（组合优先）之分，主要区别在于处理字符组合和分解的方式。",
        "time": "01:07:13"
      },
      {
        "question": "APFS文件系统为何对Unicode规范化处理有所不同？",
        "answer": "APFS文件系统采用了不敏感的Unicode规范化处理方式，不再像HFS+那样自动进行规范化处理。这一改变是为了提高搜索效率，无论以何种规范化形式写入，都能更容易地找到文件。但对于依赖于特定规范化形式的日语等语言用户而言，可能会出现文件名中的特定字符（如着音点）在新旧文件系统间不兼容的问题。",
        "time": "01:09:43"
      },
      {
        "question": "在苹果系统中，APFS是否像Windows系统那样对文件规范化编码敏感？",
        "answer": "如果按照最开始的APFS设计理念，它并不涉及规范化和文件编码方式，理论上可以不使用UTF8编码。但实际情况是，Apple在APFS中对文件名的规范化敏感，比如只接受有效的UTF8编码的文件名。",
        "time": "01:16:05"
      },
      {
        "question": "如果在遵守Apple规范的前提下使用Foundation库来命名和访问文件，可能会遇到什么问题？",
        "answer": "当通过Apple的API存入一个文件后，在命令行界面下使用Unix工具访问时，可能会得到一个不同的文件路径，导致用一套API存的文件无法通过另一种方式找回，这种情况类似于早期Mac OS X转换到Unix系统的时期所遇到的问题。",
        "time": "01:16:34"
      },
      {
        "question": "HFS Plus采用的是NFC还是NFD形式进行文件路径的存储和处理？",
        "answer": "根据查证，HFS Plus采用的是NFD标准化形式，这与Windows系统不同。",
        "time": "01:20:01"
      },
      {
        "question": "HFS和APFS在文件名处理上的行为有何差异？",
        "answer": "HFS对文件名中的规范化敏感，而APFS则不敏感。在HFS中，当输入一个文件名时，系统会将其转换为标准化后的形式再存储到存储介质上；而在APFS中，即使文件名经过了不同的规范化形式（如NFC或NFD），它也能识别并保存下来，但并不进行敏感性判断。",
        "time": "01:20:23"
      },
      {
        "question": "为什么要在Unicode规范中引入多种不同的规范化方式，如NFC、NFD等？",
        "answer": "主要有两种规范化思路，一种是将可拆分的字符都分解为不可再分的形式存储；另一种是将可合成的字符按照特定方式预先合成后存储。例如NFC是先分解到不能再分的状态，而NFD则是尽可能地将字符合成后再进行存储。不同的规范化方式适应不同的应用场景，如编程比较中可能需要将字符串分解至最小单元以判断是否相等，而在显示或存储空间优化时则可能希望将字符重新组合起来。",
        "time": "01:20:23"
      },
      {
        "question": "兼容分解（NFC）和标准分解（NFD）有何区别？",
        "answer": "兼容分解（NFC）主要解决同一个字符在不同编码方式下的表示形式能被等价匹配的问题，例如FI盒在搜索时既能匹配分开的F和I，也能匹配合成的FI盒。而标准分解（NFD）则更侧重于按照Unicode标准规范将字符分解到基本字符层面，不考虑兼容性问题。",
        "time": "01:24:51"
      },
      {
        "question": "火星文是否也存在等价的问题？",
        "answer": "是的，在实际使用情况下，火星文必然是等价于非火星文的文本。",
        "time": "01:31:46"
      },
      {
        "question": "在中文中是否存在拆分和组合的问题？",
        "answer": "中文基本上没有拆分和组合的问题，但韩语可能会有。",
        "time": "01:30:42"
      },
      {
        "question": "是否可以沿用Unicode的兼容分解处理火星文？",
        "answer": "不一定能直接沿用，需要设计一套能够保持幂等性的拆解和组合机制。",
        "time": "01:32:50"
      },
      {
        "question": "为什么Unicode Normalization具有幂等性？",
        "answer": "因为无论对一个串做多少次规范化操作，最终结果是一样的，只要设计的拆解和组合机制符合幂等性的数学特性。",
        "time": "01:35:02"
      },
      {
        "question": "火星文的拆解是否可逆？",
        "answer": "火星文的拆解过程不是可逆的，因为它破坏了原始信息，无法回到初始表达形式。",
        "time": "01:34:19"
      },
      {
        "question": "APFS在macOS和iOS层面有哪些不同，特别是在处理规范化问题上？",
        "answer": "在macOS中，APFS最近决定加入对规范化的处理，通过生成哈希值来确保对规范化形式不敏感。而在iOS中，由于APFS之前并未考虑这个问题，因此需要额外处理大小写敏感性和哈希化的问题，以保证文件系统的兼容性和一致性。",
        "time": "01:36:07"
      },
      {
        "question": "哈希是如何工作的？",
        "answer": "哈希是一种将字符串通过特定算法转换为固定长度数字的过程，一般生成一个256位或512位的数字，其特性是在大概率上保证不同输入不会得到相同的哈希值，从而用于文件指纹识别或数据校验等方面。",
        "time": "01:39:13"
      },
      {
        "question": "在文件系统中，比如Windows和Mac之间交换文件时，是否会出现乱码问题？",
        "answer": "是的，当Windows用户发送使用zip打包且编码方式不一致的文件到Mac上时，可能会出现文件名乱码的情况。这主要是因为zip打包时采用的encoding方式灵活，不同打包和解码程序可能使用的编码类型不同导致的。",
        "time": "01:45:15"
      },
      {
        "question": "这种乱码问题是否与Unicode标准有关？",
        "answer": "不是直接与Unicode标准相关，而是在编码和解码过程中产生的问题。即使都是UTF8编码，也可能因为解码程序与打包程序使用的编码方式不匹配而出现乱码。",
        "time": "01:45:44"
      },
      {
        "question": "Unicode标准如何解决不同语言间字符差异带来的问题？",
        "answer": "Unicode标准旨在提供一个统一的字符编码方案，解决各国各自制定的多种字符编码标准之间的不兼容问题。虽然这导致了新的复杂性，但也避免了如不使用Unicode时可能出现的大量特定于地区的编码问题。",
        "time": "01:45:44"
      },
      {
        "question": "遇到乱码问题时，通常是什么原因？对于日文Windows用户拷贝文件到Mac上时出现的日文字符被拆解的问题，该如何处理？",
        "answer": "遇到乱码问题时，通常是因为文件名在编码层面的问题，例如双方使用的编码方式不同。通常情况下，这种情况无法自动解决，用户需要手动编辑文件名以保证兼容性。",
        "time": "01:46:08"
      },
      {
        "question": "是否有一些方法可以帮助解决这类问题？",
        "answer": "中国用户有时会采用拼音首字母来代替中文文件名，以避免因编码问题导致的混乱。但在日文环境下，很多日文用户直接使用日文字符命名文件，这在操作系统层面上能够实现一定程度的兼容和保护。",
        "time": "01:48:38"
      },
      {
        "question": "在处理Unicode字符和PDF阅读器的问题上，有什么具体的挑战？",
        "answer": "在Unicode字符处理上，某些应用程序如 Preview 对某些Unicode字符的识别和处理可能不完善，而在网页上某些情况下，即使使用了Unicode标准，也可能因为显示方式不同而不易识别。",
        "time": "01:49:25"
      },
      {
        "question": "对于软件开发者来说，在处理Unicode和兼容性问题时，需要多大程度地主动解决这些问题？",
        "answer": "在操作系统和系统库提供了标准API调用的情况下，开发者通常不需要自己解决这些问题。但在特殊系统如Mac OS上，可能需要明确调用支持Unicode规范的API，并确保代码与系统的兼容性。",
        "time": "01:54:24"
      },
      {
        "question": "在Unicode中，像欧米伽这样的字符是如何处理的？",
        "answer": "欧米伽字符在形式上和语义来源上都是一样的，但在某些情况下会被分裂成两个字符，其中一个用于表示物理单位，另一个则是欧米伽字符本身。",
        "time": "01:59:34"
      },
      {
        "question": "对于完全相同的两个字符串，在Unicode规范化和编码过程中是如何确保它们具有唯一性的？",
        "answer": "理论上应该先进行Unicode规范化，然后再转换为p code，以得到一个唯一的结果。但现实中可能存在一些特殊情况，例如两个看似相同的域名访问不同的网站，这可能导致混淆问题。",
        "time": "01:59:52"
      },
      {
        "question": "现在移动网站上URL的显示情况如何？",
        "answer": "许多移动网站上，用户可能无法看到完整的URL，例如在微信浏览器中打开网站时，用户通常无法看到原始的URL地址。",
        "time": "02:00:07"
      },
      {
        "question": "在安全验证网站身份时，除了证书外还需要依赖什么方式？",
        "answer": "最终可能还需要依靠其他工具来验证网站的真实性，因为仅凭肉眼或Unicode无法有效区分。",
        "time": "02:00:41"
      },
      {
        "question": "浏览器中的加密连接图标如何影响用户对网站的信任？",
        "answer": "浏览器地址栏左侧的加密锁图标会让用户认为该连接是安全的，但如果顶级域名支持EM（可能是指HTTPS），甚至有人将域名设计成类似“锁”的图标加上其他元素，这可能会误导用户。",
        "time": "02:00:55"
      },
      {
        "question": "是否可以在域名中添加特殊字符或Unicode字符？是否支持在网页和域名中使用特殊字符或Unicode字符？",
        "answer": "建议不应在域名中随意添加特殊字符或Unicode字符，因为这会极大地增加复杂度，不利于用户的认知和理解，同时也可能导致混淆问题。不建议在网页或域名中大量使用特殊字符或Unicode字符，尤其是不应该直接在域名中添加类似EMerge的标识或难以识别的字符，因为这会带来复杂性和潜在风险。",
        "time": "02:02:14"
      },
      {
        "question": "W3C是否有自己的字符串规范化机制？",
        "answer": "是的，W3C有一套基于Unicode的 normalization机制，推荐使用NFC标准化形式，并且在HTML中通过 character reference 引用任何Unicode字符，这一过程会将其转换为可显示的字符。",
        "time": "02:03:46"
      },
      {
        "question": "对于网页开发人员来说，在HTML中使用不可见字符有何优势？",
        "answer": "使用character reference将不可见字符转换为可见字符对于程序员而言较为友好，可以在HTML中方便地输入和显示这些字符。",
        "time": "02:05:15"
      }
    ],
    "chapters": [
      {
        "time": "00:00:00",
        "title": "自弹自唱与内核恐慌第五期串台节目回顾",
        "summary": "本期是自弹自唱与内核恐慌的第五次串台节目，也是两档节目合作的里程碑。自弹自唱作为首个用华语制作的字体排印主题播客，与IT技术主题娱乐节目内核恐慌合办节目，展现了不同领域播客之间的交流与合作。回顾了过去活动的难忘时刻，包括主播们在五月底的首次线下聚会，以及一些有趣的聚会细节。虽然大家有几次线下见面的经历，但四人同时见面的机会难得，凸显了播客社区的紧密与友情。此外，还提到了即将结束的字体设计课程，暗示了节目之外的学习和成长机会。"
      },
      {
        "time": "00:03:17",
        "title": "中文字体设计课程及Type School活动介绍",
        "summary": "即将在北京举行的中文字体设计课程，由方正字库的资深设计师授课，重点教授如何从12个字扩展到数千字的字库设计方法。课程为期五天，强调效率提升和问题解决，优秀学员有机会与方正字库签约。此外，活动还吸引了德国Meta Design的参与，提供了一个难得的学习和交流机会。特别地，课程还将介绍Gripes软件的新功能，以应对汉字设计的特殊需求。尽管北京夏季炎热，但活动为设计界人才提供了宝贵的参与和成长机会。"
      },
      {
        "time": "00:07:41",
        "title": "探讨打字机的换行机制及中文打字机的使用",
        "summary": "对话中讨论了打字机的换行机制，指出传统的打字机通过滚筒左端手柄的特定操作来实现回车和换行，而非使用专门的回车键。进一步地，讨论转向了中文打字机的复杂性，描述了它们的大型尺寸和使用笛卡尔平面来选择汉字的机制，以及一些特定的设计，如滚筒式选择机构，以应对中文字符的大量需求。"
      },
      {
        "time": "00:11:27",
        "title": "探讨打字机与现代文字处理系统的演进",
        "summary": "对话从对传统打字机的回忆开始，提及了按拼音和部首排列的不同方法，以及对日语多音字的记忆挑战。随后转向讨论中文打字机的使用，包括字盘的可换性和多层设计，以及通过UCDOS和WPS等早期电脑系统进行中文处理的经验。最后，讨论转向现代文字处理软件，如Word和Pages，探讨了格式一致性、样式应用和所见即所得的编辑体验等问题。整体上，这段对话涵盖了从机械打字机到现代文字处理系统的演变，以及这些变化如何影响文本编辑和排版的实践。"
      },
      {
        "time": "00:18:44",
        "title": "中文打字机的技术挑战与字体设计",
        "summary": "中文打字机与英文打字机相比，存在力度控制的技术难题，导致打印质量不稳定。使用者需精确控制按键力度，以防力度过大破坏纸张，特别是在打印繁体字时更为明显。讨论还提到了高端打字机通过机械设计解决这一问题，如IBM的滚筒式打字机，采用等宽字体设计，确保打印质量。此外，还提及了7月17日为MG日，关联到表情符号（AMOJ）的话题。"
      },
      {
        "time": "00:21:31",
        "title": "苹果iOS11新表情符号及iPad更新体验",
        "summary": "讨论了苹果在官方网站上预先展示的iOS11里面的新表情符号，包括僵尸、戴头巾的女人、长胡须的人、饺子和筷子等，这些表情符号是基于Uni第十版通过的设计。同时，也提到了iOS11的beta版在iPad上的一些使用体验，尽管有人反映不稳定，但iPad的改动较大，引起了一定的关注。"
      },
      {
        "time": "00:23:30",
        "title": "解决中西文混排与多语言字符串问题",
        "summary": "一位自称老虎的听众向主播求教两个问题：1）中西文混排时，一个label上展示的文字高度如何确定，特别是中英文混排时文字高度会增加的原因；2）关于多语言字符串的处理，探讨了iOS系统如何维护逻辑尺寸，以及字体对文字渲染尺寸的影响。主播通过邮件回应，详细解释了iOS系统逻辑尺寸的应用、动态类型调整和字体设计对文字显示尺寸的影响，并提到了macOS文本编辑程序中中英文混排行高问题的改进。"
      },
      {
        "time": "00:28:35",
        "title": "中西文排版对齐问题及CSS应用探讨",
        "summary": "讨论集中在中西文在排版时的对齐问题，主要由字体内部的基线位置决定。在现代字体设计中，无论是中文还是西文，都基于基线对齐，尽管存在不同的排版引擎和格式（如Web和印刷品）对对齐方式的不同处理。特别指出，在CSS中，对齐问题因line box的计算和vertical align属性的复杂性而变得不直观，可能与字体设计师预设的对齐位置不一致，引发排版问题。此外，讨论也触及了多语言字符串的处理，暗示了在排版和设计领域，处理多语言内容时需要考虑到基线对齐等技术细节。"
      },
      {
        "time": "00:35:44",
        "title": "多语言字符串排序和索引的挑战",
        "summary": "讨论集中在如何在国际化背景下对多语言字符串进行排序和索引，特别是关注了Unicode提供的一套规则。讨论者分享了对iPhone通讯录中姓名排序规则的研究，探讨了中文和英文混排时的排序问题，以及如何获取汉字的读音。此外，还讨论了在不同语言设置下，iOS通讯录的排序行为及其带来的挑战，包括无法在系统语言设置中指定特定的排序方式。整体上，这次讨论突出了在处理多语言环境时遇到的复杂性和挑战。"
      },
      {
        "time": "00:41:05",
        "title": "解决中日文名字注音与排序问题",
        "summary": "讨论集中在如何在手机通讯录中正确标注和排序中日文名字。一个常见的问题是，由于日本人使用汉字时往往不知道其正确读音，因此建议在注音字段中加入拼音，以便于日文环境下的正确识别和排序。对于中文名字，由于存在多音字和非标准读音，自动标注phonetic names的小软件可以提供便利。同时，讨论还涉及了如何处理不同文化中的名字读音问题，以及iOS系统中如何利用特定字段教导语音合成器正确发音。"
      },
      {
        "time": "00:48:34",
        "title": "多语言环境下的文本排序问题探讨",
        "summary": "在多语言环境下，文本排序成为一个复杂的问题，涉及代码、操作系统和APP等多个层面。讨论指出，对于精通多种语言的用户，如何在尊重各种语言特性的同时，实现有效的信息排序变得尤为重要。在操作系统层面，以iOS和macOS为例，它们对于语言排序的处理方式不同，反映出在移动和桌面平台上对语言支持的差异。在应用层面，如iTunes通过提供额外的字段来支持音乐名称的多语言显示和排序，展示了应用设计如何应对多语言环境下的排序挑战。此外，文本排序还与政治策略有关，说明了在Unicode编码中虽然有排序规则，但在具体应用时需要考虑环境和文化的特殊需求。整体上，多语言环境下的文本排序问题展示了现代软件复杂性的一个侧面。"
      },
      {
        "time": "00:52:15",
        "title": "探讨Unicode规范化形式及其应用",
        "summary": "Unicode的规范化形式（Normalization）是一个被很多人忽视的重要问题。规范化涉及到如何处理看起来相同但实际编码不同的字符组合，如带声调的字符可能由一个基础字符和一个声调符号组合而成。这一现象主要由于历史遗留问题及Unicode需要兼容多语言的需求。规范化处理在文本处理中尤其重要，如搜索功能中需要决定是否将带声调和不带声调的字符视为相同。"
      },
      {
        "time": "00:55:12",
        "title": "Unicode编码的历史背景与组合字符的挑战",
        "summary": "Unicode编码系统在设计初期，考虑到历史遗留问题和语言的多样性，特别是欧洲多国使用的带有扩展符号的拉丁字符，采取了兼容ASCII并留有扩展空间的策略。随着国际化的需求增加，出现了同一个字符可能有多个码位的情况，这主要是因为Unicode需要兼容各种语言和字符的组合规则，如德语中的特殊字母和越南语中带有多个标音符号的字符。为了应对这种复杂性，Unicode引入了规范化处理，解决等价字符的编码问题，同时试图节省空间并保持灵活性。此外，对于某些语言如韩语，其组合字符的编码方式也提出了挑战，导致了编码空间的扩展需求。这些问题凸显了Unicode设计时需要平衡编码的效率、兼容性和语言的多样性。"
      },
      {
        "time": "01:01:43",
        "title": "探讨Unicode规范化及字符编码问题",
        "summary": "对话内容涉及认知问题、日语中的字符编码问题（如半角和全角字符的区别），以及字符编码的历史遗留问题对现代信息技术标准（如ISO8859、Unicode）的影响。强调了Unicode规范化处理的必要性，讨论了Swift语言对字符串处理的改动，以及对字符串等价性的判定方式，指出了规范化处理在解决字符编码问题中的重要性。"
      },
      {
        "time": "01:06:27",
        "title": "Unicode规范化及其在操作系统中的应用",
        "summary": "讨论了Unicode规范化的需求及其在解决字符等价问题中的重要性。规范化分为两大类：标准等价和兼容性等价，每类又细分为两种形式，共计四种规范化方式。此外，还提到了操作系统对规范化方法的不同采纳，以及苹果公司因文件系统更新而对Normalization的关注。"
      },
      {
        "time": "01:08:32",
        "title": "APFS文件系统及其对规范化处理的改变",
        "summary": "对话集中在苹果新的文件系统APFS（Apple File System）上，特别是其对文件名规范化处理的改变。与旧的HFS+文件系统不同，APFS对规范化不敏感，这使得文件搜索更加容易，无论文件名如何规范化。这一改变对于使用日语等包含特殊字符的语言的用户来说尤为显著，因为旧系统中，文件名的规范化处理可能导致文件被错误地拆分。APFS的设计理念是文件系统作为底层系统不应过度涉及应用层的问题，比如文件名的规范化处理，这应该是API层面需要解决的问题。然而，文件系统的底层性质意味着它在存储文件名时不可避免地需要考虑到标准化形式。"
      },
      {
        "time": "01:14:17",
        "title": "操作系统和文件系统兼容性问题探讨",
        "summary": "讨论集中在操作系统和文件系统层级上API导致的向后兼容性问题，特别是从HFS到APFS的转变中，如何处理文件系统对文件名规范化和编码的敏感度。在iOS中，由于未公开文件系统，兼容性问题不明显，但在Mac中，用户直接访问文件系统可能遇到问题。此外，还提到了APFS设计理念的变化，不再强制规范化文件名编码，允许更灵活的编码方式，但这也可能导致在不同API下文件路径不一致的问题。最后，讨论了在从旧版Mac OS到真正Unix系统转变过程中，路径分隔符和文件名处理的变化，以及Apple对文件名标准化形式敏感性的调整。"
      },
      {
        "time": "01:20:14",
        "title": "NFD和FC规范化形式的比较与应用场景",
        "summary": "对话中讨论了NFD和FC两种规范化形式，以及它们各自的特点和应用场景。NFD（规范分解形式）强调将字符分解到不能再分解的状态，适用于需要精确比较字符的场景，如编程中的字符串比较，但可能导致存储空间增大。FC（合成形式）则侧重于将可以合成的字符按照特定方式合成，更适合需要节省存储空间或优化显示效果的场合。同时，还提到了兼容分解和标准分解的区别，以及它们在处理字符编码和显示时的重要性，特别是在考虑兼容性问题时。"
      },
      {
        "time": "01:25:24",
        "title": "字符分解与兼容性处理方法探讨",
        "summary": "讨论集中在如何处理文档中包含的字符及其分解方式，以适应用户的搜索需求。提出了两种方法：一是将文档中的复合字符分解为单个字符，二是将用户输入的字符合成盒子形式，以便与文档中的字符进行比对。讨论还涉及到不同语言中字符的特殊性，如某些字符在不同位置有不同写法、数字的全角与半角区别、以及字符在特定语言中的组合使用等，强调了字符分解在兼容性和搜索功能中的重要性。"
      },
      {
        "time": "01:30:08",
        "title": "中文文本处理中的规范化问题",
        "summary": "讨论集中在中文文本处理中遇到的规范化问题，包括标点符号的横竖型问题、火星文的使用及等价替换、以及Unicode兼容性分解。特别指出，中文不像其他语言那样存在明显的拆分与组合问题，但在某些情况下需要考虑单个字符间的等价性。讨论还涉及了规范化处理的幂等性原则，强调了在文本拆解与重组时维持一致性的重要性。"
      },
      {
        "time": "01:35:59",
        "title": "APFS在macOS和iOS中的实现差异及挑战",
        "summary": "APFS作为苹果的新文件系统，在macOS和iOS中的实现有所不同，尤其是在处理文件名大小写敏感性和Normalization方面。在iOS中，APFS最初未考虑Normalization问题，而macOS的APFS通过哈希值解决文件名的Normalization不敏感性，但这也带来了大小写保留和哈希冲突的挑战。苹果通过版本迭代尝试解决这些技术难题，以确保在新的文件系统下，用户数据的兼容性和安全性。"
      },
      {
        "time": "01:44:45",
        "title": "解决文件名乱码和Unicode标准化的重要性",
        "summary": "讨论重点在于不同系统间文件交换时遇到的文件名乱码问题，主要原因是编码方式不一致。以Windows用户发送的ZIP压缩包为例，指出由于ZIP格式编码方式灵活，打包和解包程序使用的编码不同可能导致乱码。进一步讨论了Unicode编码在解决乱码问题中的作用，强调了Unicode不仅提供字符编码，还有助于解决文本处理技术问题，如Normalization。通过具体例子说明了在不同操作系统和软件应用中，Unicode标准化如何帮助确保文本的正确显示和处理，从而提升了跨系统文件兼容性和用户体验。"
      },
      {
        "time": "01:54:06",
        "title": "软件开发中的Unicode规范化处理与域名安全问题",
        "summary": "软件开发者在处理Unicode规范化时遇到的挑战，包括在不同操作系统和API间的兼容性问题，以及Unicode字符在域名系统中可能导致的安全漏洞。讨论强调了开发者需要了解何时使用何种API来避免规范化错误，以及Unicode多语言支持在域名系统中引发的安全风险，如钓鱼网站利用相似字符欺骗用户。此外，还提到了Unicode规范化标准早于域名系统规范，导致在转换过程中可能出现的问题。"
      },
      {
        "time": "02:00:54",
        "title": "探讨Unicode和域名复杂性及其影响",
        "summary": "对话中讨论了Unicode在域名中的使用以及它如何增加了技术产品的复杂度。提到了浏览器加密连接标志的误用可能性、Unicode对用户认知的挑战，以及技术产品需求过度复杂化的问题。同时，指出W3C的Normalization机制和punycode的作用，强调了对域名中使用Unicode字符的节制。此外，还提到了抽奖活动的结果和联系方式。"
      }
    ],
    "mindmap": {
      "children": [
        {
          "children": [
            {
              "children": [
                {
                  "children": [],
                  "content": "解决字符编码与实际显示不一致的问题"
                },
                {
                  "children": [],
                  "content": "多语言环境下字符等价性的处理"
                }
              ],
              "content": "定义与必要性"
            },
            {
              "children": [
                {
                  "children": [],
                  "content": "NFC (Normalization Form C): 合成优先"
                },
                {
                  "children": [],
                  "content": "NFD (Normalization Form D): 分解优先"
                },
                {
                  "children": [],
                  "content": "NFKC (Normalization Form KC): 兼容性合成"
                },
                {
                  "children": [],
                  "content": "NFKD (Normalization Form KD): 兼容性分解"
                }
              ],
              "content": "规范化形式"
            },
            {
              "children": [
                {
                  "children": [],
                  "content": "字符串比较"
                },
                {
                  "children": [],
                  "content": "文件名处理"
                },
                {
                  "children": [],
                  "content": "搜索功能优化"
                }
              ],
              "content": "实际应用"
            },
            {
              "children": [
                {
                  "children": [],
                  "content": "文件系统APFS对规范化处理的变化"
                },
                {
                  "children": [],
                  "content": "Unicode字符在不同操作系统中的显示差异"
                }
              ],
              "content": "案例讨论"
            }
          ],
          "content": "Unicode规范化"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [],
                  "content": "IT技术主题娱乐节目"
                },
                {
                  "children": [],
                  "content": "字体排印主题播客节目"
                }
              ],
              "content": "节目类型"
            },
            {
              "children": [
                {
                  "children": [],
                  "content": "串台合作"
                },
                {
                  "children": [],
                  "content": "奖项与捐赠"
                },
                {
                  "children": [],
                  "content": "社交媒体互动"
                }
              ],
              "content": "节目动态"
            },
            {
              "children": [
                {
                  "children": [],
                  "content": "提问与解答"
                },
                {
                  "children": [],
                  "content": "听众反馈"
                },
                {
                  "children": [],
                  "content": "抽奖活动"
                }
              ],
              "content": "听众互动"
            }
          ],
          "content": "播客节目"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [],
                  "content": "国际化支持"
                },
                {
                  "children": [],
                  "content": "多语言兼容性"
                }
              ],
              "content": "Unicode标准"
            },
            {
              "children": [
                {
                  "children": [],
                  "content": "域名欺骗与安全"
                },
                {
                  "children": [],
                  "content": "IDN (国际化域名) 的安全问题"
                }
              ],
              "content": "网络安全"
            },
            {
              "children": [
                {
                  "children": [],
                  "content": "多语言支持的社会意义"
                },
                {
                  "children": [],
                  "content": "技术发展与文化多样性保护"
                }
              ],
              "content": "社会文化影响"
            }
          ],
          "content": "技术与社会影响"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [],
                  "content": "Unicode标准的演进"
                },
                {
                  "children": [],
                  "content": "文件系统更新对Unicode规范化的影响"
                }
              ],
              "content": "技术进步"
            },
            {
              "children": [
                {
                  "children": [],
                  "content": "多语言互联网内容的需求增长"
                },
                {
                  "children": [],
                  "content": "全球化背景下语言多样性保护"
                }
              ],
              "content": "社会需求变化"
            },
            {
              "children": [
                {
                  "children": [],
                  "content": "技术标准化与全球化趋势"
                },
                {
                  "children": [],
                  "content": "信息安全与多语言支持的平衡"
                }
              ],
              "content": "挑战与机遇"
            }
          ],
          "content": "行业发展与未来展望"
        }
      ],
      "content": "5e84c3ac418a84a0462df8df"
    }
  }
}