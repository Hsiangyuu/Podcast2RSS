{
  "pid": "5e284e0c418a84a0462693e4",
  "eid": "5e84c3ac418a84a0462df8f5",
  "title": "42. Kerning Panic·字谈字串（二）",
  "task_id": "47z39vd5o4ge9edg",
  "transcription": [
    {
      "time": "00:00:00",
      "text": "321开始。",
      "speaker": "发言人1"
    },
    {
      "time": "00:00:22",
      "text": "大家好，今天是7月26号，自弹自唱的第26期.",
      "speaker": "发言人2"
    },
    {
      "time": "00:00:28",
      "text": "同时也是内核恐慌应该是第42期。我希望是第。",
      "speaker": "发言人1"
    },
    {
      "time": "00:00:32",
      "text": "42期或者是41期.",
      "speaker": "发言人3"
    },
    {
      "time": "00:00:36",
      "text": "为什么不？不可能？",
      "speaker": "发言人1"
    },
    {
      "time": "00:00:38",
      "text": "不一定，对吧？我们我这个欢迎同时也是内核恐慌第41和42的纠缠态。那一期OK.",
      "speaker": "发言人3"
    },
    {
      "time": "00:00:46",
      "text": "大家听到的时候才可以review这到底是哪一期。",
      "speaker": "发言人1"
    },
    {
      "time": "00:00:52",
      "text": "自弹自唱是全球首家用华语制作的字体白云主题播客节目。我是主播汶川西半东营剧eric.",
      "speaker": "发言人2"
    },
    {
      "time": "00:00:59",
      "text": "我是主播黄浦江边清蒸鱼。清蒸鱼。",
      "speaker": "发言人4"
    },
    {
      "time": "00:01:03",
      "text": "您正在收听IP pox网络旗下的IT技术主题娱乐节目内很恐慌，我们号称hot work，但是也没有干货，想听就听，不想听就别听。我是吴涛，我是real，我就不报花名。",
      "speaker": "发言人1"
    },
    {
      "time": "00:01:12",
      "text": "对，我们还没想起那个花名，还是？气势上，算了吧，何必。",
      "speaker": "发言人3"
    },
    {
      "time": "00:01:18",
      "text": "但是吴导上次来我来我们自然在做嘉宾的时候已经有花名了，我帮他起的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:01:23",
      "text": "我我我觉得那个还是对称之有愧，因为我现在已经不在莱茵河畔了，就离多瑙河可能还近一点的。所以还是。",
      "speaker": "发言人1"
    },
    {
      "time": "00:01:33",
      "text": "说纽伦堡内麦。",
      "speaker": "发言人2"
    },
    {
      "time": "00:01:36",
      "text": "塔壶看完了。",
      "speaker": "发言人3"
    },
    {
      "time": "00:01:40",
      "text": "然后我们程序员to the bone不要这一套好了。",
      "speaker": "发言人1"
    },
    {
      "time": "00:01:46",
      "text": "今天有没有口号吗？",
      "speaker": "发言人2"
    },
    {
      "time": "00:01:48",
      "text": "今天好像也没有口号，hero never .",
      "speaker": "发言人1"
    },
    {
      "time": "00:01:53",
      "text": "die太扯了。好了，自弹自串，我们这是第二期节目。在第二期节目正式进入主题之前，我们先来看一下第一期自谈之初，有一些听众反馈对吧？郑宇。",
      "speaker": "发言人2"
    },
    {
      "time": "00:02:07",
      "text": "是，那我来说一下，首先我们收到了一封邮件，一位署名叫虎虎萨？这个字念普萨的一位听众给我们的反馈是纠正读音的这个老传统。他说四位主播好，再次小小纠正一下曲线的吃念吃歌曲的曲念曲。好吧。",
      "speaker": "发言人4"
    },
    {
      "time": "00:02:29",
      "text": "为什么为什么？好吧。",
      "speaker": "发言人3"
    },
    {
      "time": "00:02:32",
      "text": "别问为什么，就是这样多音字就是这样。",
      "speaker": "发言人2"
    },
    {
      "time": "00:02:35",
      "text": "OK我明白了，趋势curve，然后取消lod送。",
      "speaker": "发言人3"
    },
    {
      "time": "00:02:44",
      "text": "好吧。",
      "speaker": "发言人2"
    },
    {
      "time": "00:02:45",
      "text": "这可能跟以前什么一个是动词，一个是形容词有关系，或者一对一个是名词，一个是名词。",
      "speaker": "发言人1"
    },
    {
      "time": "00:02:52",
      "text": "一个是好像不行。",
      "speaker": "发言人2"
    },
    {
      "time": "00:02:54",
      "text": "曲线是从九曲十八弯的那个曲来的对吧？就是拐弯的意思对吧？对，曲是曲，是歌曲的曲。",
      "speaker": "发言人1"
    },
    {
      "time": "00:03:05",
      "text": "对，所以刚才你又念错了，是曲线吗？",
      "speaker": "发言人3"
    },
    {
      "time": "00:03:09",
      "text": "九曲十八弯。对对对。",
      "speaker": "发言人2"
    },
    {
      "time": "00:03:11",
      "text": "我念的是九曲是吧？",
      "speaker": "发言人1"
    },
    {
      "time": "00:03:13",
      "text": "对，已经变成那个曲吗？歌曲那个曲了。",
      "speaker": "发言人3"
    },
    {
      "time": "00:03:17",
      "text": "这这个字这个字本意是指什么？这个字本来指的是是弯曲还是歌曲呢？",
      "speaker": "发言人1"
    },
    {
      "time": "00:03:24",
      "text": "本应该是弯曲。",
      "speaker": "发言人2"
    },
    {
      "time": "00:03:27",
      "text": "然后歌曲是引申义，指是指一开始是指一个弯，一开始指一个弯折了的事物。",
      "speaker": "发言人1"
    },
    {
      "time": "00:03:37",
      "text": "对，所以还是弯是弯曲是它的本这个词源本意OK.",
      "speaker": "发言人2"
    },
    {
      "time": "00:03:42",
      "text": "所以音乐是隐身音。",
      "speaker": "发言人1"
    },
    {
      "time": "00:03:44",
      "text": "所以它还有一个意思就是我们都有用过的，就是你们在你们猜一下这用这个用途的时候念哪个音，就是用那个发酵做酒那个东西。",
      "speaker": "发言人3"
    },
    {
      "time": "00:03:54",
      "text": "虚，那是。",
      "speaker": "发言人2"
    },
    {
      "time": "00:03:55",
      "text": "另一个错了。",
      "speaker": "发言人4"
    },
    {
      "time": "00:03:58",
      "text": "那是另外一个词简化来了。",
      "speaker": "发言人1"
    },
    {
      "time": "00:04:00",
      "text": "对，但那是另一个繁体。",
      "speaker": "发言人4"
    },
    {
      "time": "00:04:02",
      "text": "它是有个卖字的旁的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:04:04",
      "text": "对对对。",
      "speaker": "发言人4"
    },
    {
      "time": "00:04:05",
      "text": "那其实是另一个就是念区区医生OK医生第一声。对对，第一声区对，韭蛆，什么什么洋河大曲。广告没说错。然后还有一个曲是另外一个字是麦字旁，一个菊花的菊，不要那个草字头。",
      "speaker": "发言人3"
    },
    {
      "time": "00:04:31",
      "text": "那也是那个就是酵母。",
      "speaker": "发言人2"
    },
    {
      "time": "00:04:34",
      "text": "对对对，这个是这个是这个区，就九区这个区的一体字。",
      "speaker": "发言人3"
    },
    {
      "time": "00:04:39",
      "text": "好像是没有。所以你现在说的就是说其实原来繁体字是三个字，简化就变成一个字而已。",
      "speaker": "发言人2"
    },
    {
      "time": "00:04:48",
      "text": "不，那个是用九曲的那个趋势简化成了这个东西。但是前面那个弯曲和这个小曲儿，他们好像原始就这样吧。",
      "speaker": "发言人3"
    },
    {
      "time": "00:04:58",
      "text": "对对对，他们原来是两个字，没错，现在被那个简并成了一个字。",
      "speaker": "发言人4"
    },
    {
      "time": "00:05:04",
      "text": "这个还可以是一个姓。好，那考你们了，用作姓的时候，念几声吃。",
      "speaker": "发言人3"
    },
    {
      "time": "00:05:09",
      "text": "对，吃应该是念医生。吃吃羊。我记得那个笑傲江湖里面某派掌门人是不是。",
      "speaker": "发言人4"
    },
    {
      "time": "00:05:18",
      "text": "就姓屈的念用作姓是念医生的对，好吧，这个中文真是坑爹啊。我问你们一个事儿，那天我问到那天我想到的，你说手机和掌机有什么区别？",
      "speaker": "发言人3"
    },
    {
      "time": "00:05:32",
      "text": "掌机是我的游戏机，掌上游戏机的对。",
      "speaker": "发言人1"
    },
    {
      "time": "00:05:36",
      "text": "但是手机？",
      "speaker": "发言人3"
    },
    {
      "time": "00:05:39",
      "text": "手机是指手上电话机，手持电话机。",
      "speaker": "发言人1"
    },
    {
      "time": "00:05:44",
      "text": "然后我问你这是一个没有这个context基础的外国人来学中文，你说他怎么区分这两个东西呢？",
      "speaker": "发言人3"
    },
    {
      "time": "00:05:54",
      "text": "但是英文里面有handset这个词。",
      "speaker": "发言人2"
    },
    {
      "time": "00:05:56",
      "text": "德语里面首先是handy，对吧？对，然后最早的那个PDA是pom对吧？",
      "speaker": "发言人3"
    },
    {
      "time": "00:06:04",
      "text": "对，pom就是涨掌机。",
      "speaker": "发言人1"
    },
    {
      "time": "00:06:06",
      "text": "什么时候变成游戏机了？",
      "speaker": "发言人3"
    },
    {
      "time": "00:06:09",
      "text": "掌上游戏机，对嘛对，不是变了，这是个缩写吗？这是个简称吗？",
      "speaker": "发言人1"
    },
    {
      "time": "00:06:14",
      "text": "那手机。",
      "speaker": "发言人3"
    },
    {
      "time": "00:06:15",
      "text": "手持一手持电话机。",
      "speaker": "发言人1"
    },
    {
      "time": "00:06:17",
      "text": "我刚才不是说了，原来是这么来的那手持和掌持有什么区别？",
      "speaker": "发言人3"
    },
    {
      "time": "00:06:21",
      "text": "掌上对吧？",
      "speaker": "发言人1"
    },
    {
      "time": "00:06:22",
      "text": "和手持就那我就说没事，就是手持和掌上有什么区别。",
      "speaker": "发言人3"
    },
    {
      "time": "00:06:27",
      "text": "其实没有太大的区别了，因为这只是一个语用的习惯，至少在我看来就是嘛。",
      "speaker": "发言人4"
    },
    {
      "time": "00:06:33",
      "text": "所以说我所以很坑，就是没有任何理由。因为他你说手上拿个电话和手上拿个游戏机有本质区别吗？",
      "speaker": "发言人3"
    },
    {
      "time": "00:06:40",
      "text": "掌上电话这个说法好像对对。",
      "speaker": "发言人1"
    },
    {
      "time": "00:06:43",
      "text": "但其实这个问题在在英文里也会出现。比如给你一个首字母缩写的词，它有可能代表了多个词，必须有一个语境才可以去解读的。",
      "speaker": "发言人4"
    },
    {
      "time": "00:06:52",
      "text": "对我就是说这个就是中文有时候就是得靠这种context去积累。",
      "speaker": "发言人3"
    },
    {
      "time": "00:06:58",
      "text": "没有什么任何语文，任何语言都一样。那你给你excel，你没有上下文，你怎么知道他指的是求是。",
      "speaker": "发言人1"
    },
    {
      "time": "00:07:06",
      "text": "还是细胞。",
      "speaker": "发言人2"
    },
    {
      "time": "00:07:08",
      "text": "还是那个不是通讯的那个通讯信对吧？",
      "speaker": "发言人1"
    },
    {
      "time": "00:07:13",
      "text": "但这两个是同样。",
      "speaker": "发言人3"
    },
    {
      "time": "00:07:15",
      "text": "而且在我们今天的这个话题下，CL好像在中文里还被翻译成为？比如那个去位码的位，其实指的就是C了。",
      "speaker": "发言人4"
    },
    {
      "time": "00:07:24",
      "text": "是这样的吗？",
      "speaker": "发言人3"
    },
    {
      "time": "00:07:26",
      "text": "对，区位码就是row sale的意思。",
      "speaker": "发言人4"
    },
    {
      "time": "00:07:28",
      "text": "OK, good now。",
      "speaker": "发言人3"
    },
    {
      "time": "00:07:36",
      "text": "第二个是在TIB的这个帖子下面给我们留言的。其实有两位给我们留言，一位说有关这位的署名叫john，他应该是一位韩国人，这也是我们听众。对，但看他这个信的写法有点像韩国的是吧？你们这么国际化姓尹。他说有关键盘键位和键位的映射的移动设备，貌似又是一般风景了，各国的九键布局之类的。他的意思就是说我们那期说到键盘和键位映射的时候，没有提到这个九键布局的键盘。",
      "speaker": "发言人4"
    },
    {
      "time": "00:08:16",
      "text": "九键是九宫格那种。",
      "speaker": "发言人3"
    },
    {
      "time": "00:08:18",
      "text": "对，应该。",
      "speaker": "发言人4"
    },
    {
      "time": "00:08:20",
      "text": "就ten t是那个叫什么？",
      "speaker": "发言人1"
    },
    {
      "time": "00:08:22",
      "text": "在英文里面叫turkey.",
      "speaker": "发言人3"
    },
    {
      "time": "00:08:23",
      "text": "是叫turkey吗？对。",
      "speaker": "发言人1"
    },
    {
      "time": "00:08:25",
      "text": "实践日语叫turkey。",
      "speaker": "发言人2"
    },
    {
      "time": "00:08:28",
      "text": "为什么是turkey呢？",
      "speaker": "发言人3"
    },
    {
      "time": "00:08:29",
      "text": "因为1234567八九十个劲儿，因为有零为什么叫九宫格？它它是一个它是一个一般来说是一个3乘13乘4的矩阵。但是对，应该是12个键。",
      "speaker": "发言人1"
    },
    {
      "time": "00:08:43",
      "text": "就在英文版的那个IOS里面，你加那个九宫格键盘，它英文也是叫拼音，然后实就是ten key十个。",
      "speaker": "发言人3"
    },
    {
      "time": "00:08:52",
      "text": "实践这个sense。",
      "speaker": "发言人2"
    },
    {
      "time": "00:08:55",
      "text": "所以其实这里有一个问题是这样的，我一直很不确定这种触屏的这种屏幕上的输入法，它有扣叫什么那个key code的概念吗？应该没有了。",
      "speaker": "发言人3"
    },
    {
      "time": "00:09:07",
      "text": "触屏上面应该没有。但是以前电话机上是什么？怎么实现的？",
      "speaker": "发言人2"
    },
    {
      "time": "00:09:11",
      "text": "电话机是模拟信号。",
      "speaker": "发言人4"
    },
    {
      "time": "00:09:14",
      "text": "电话机以前是靠声音长短实现。",
      "speaker": "发言人1"
    },
    {
      "time": "00:09:17",
      "text": "对，做了一个modern那种方式了。",
      "speaker": "发言人3"
    },
    {
      "time": "00:09:20",
      "text": "所以其实我们可以认为这个九键布局的这个键盘，它相当于是含了一层输入法。如果它不只是输入数字的话。",
      "speaker": "发言人4"
    },
    {
      "time": "00:09:30",
      "text": "可以这么理解。",
      "speaker": "发言人1"
    },
    {
      "time": "00:09:31",
      "text": "对，而且那个还挺复杂的。它比如说那个那个turkey上面不是每个键它有三个字母吗？ABCDEF这种。然后其实在欧美生活的人很多都知道，他们会那个电话号码他不会写。比如中国都是号是8888666这种什么比较好记的数字。但他们会很取巧的直接把那个转写成他需要的那个字母的组合。",
      "speaker": "发言人3"
    },
    {
      "time": "00:09:54",
      "text": "比如说苹果的800电话，他写的是800，然后a apple对吧？然后你就照着那个ten key上面，不是你拿出你的那个那个手机，然后你找那个拨号那个键盘，你看它每个键就是上面只有一是二。对你这样A，然后就是二对吧，一是七，两下就27733，对对对，就打到是。比如说就是苹果的一个客服电话，很多厂商就会去做这么一种转化。但是好像我中国从来没有见过这么用过。",
      "speaker": "发言人3"
    },
    {
      "time": "00:10:28",
      "text": "毕竟不是一个拉丁字母为基础的国家。",
      "speaker": "发言人1"
    },
    {
      "time": "00:10:32",
      "text": "但我其实我觉得这个还挺挺有用的，就比较好记。你看如果像中国这个电话号码就只能死记硬背号码，或者是用这个谐音，所以各种连号、86、零什么的，大家特别喜好。",
      "speaker": "发言人3"
    },
    {
      "time": "00:10:47",
      "text": "我觉得一个问题一个一个很大的问题就是中文的那个中文中汉语暨数字太方便了。",
      "speaker": "发言人1"
    },
    {
      "time": "00:10:54",
      "text": "记数字太方。对，就全部都是单音节字的对。",
      "speaker": "发言人3"
    },
    {
      "time": "00:10:58",
      "text": "而且就是我在因为你在欧洲一般都会隔血，法国会两位隔血。",
      "speaker": "发言人1"
    },
    {
      "time": "00:11:03",
      "text": "我又想到开始发黑，法国要跟法。但是德语里面也是个位数先念的是吧？如果是几十几。",
      "speaker": "发言人2"
    },
    {
      "time": "00:11:12",
      "text": "我就念念电话一般不会那么复杂，就电话看情况。但是当然有些人也是两位。",
      "speaker": "发言人1"
    },
    {
      "time": "00:11:20",
      "text": "两位的计数的话，就德语跟英文是比较相近的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:11:24",
      "text": "除了最末两位比较坑爹之外，其他还好。",
      "speaker": "发言人1"
    },
    {
      "time": "00:11:27",
      "text": "要德德文里面的就是最末两位，就是他需要先念个位数再练十位数是吧？",
      "speaker": "发言人2"
    },
    {
      "time": "00:11:33",
      "text": "英文也是一样的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:11:35",
      "text": "英文是64，比如说sixty four 64码，但是德文是倒过来的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:11:41",
      "text": "德文是4和60。",
      "speaker": "发言人1"
    },
    {
      "time": "00:11:43",
      "text": "对，德文是倒过来的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:11:45",
      "text": "四六十是这个意思。对。",
      "speaker": "发言人3"
    },
    {
      "time": "00:11:47",
      "text": "OK德文是倒过来的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:11:49",
      "text": "就只有最后两位不一样。",
      "speaker": "发言人1"
    },
    {
      "time": "00:11:52",
      "text": "但其实就是一个念法的问题，比如说中文里面会说三个五，然后因为你们会说triple five对吧？然后说两个八，你会说double eight。如果比较长的数字的话，其实一般都是一组一组念的，就是两位数的念。英文里面。",
      "speaker": "发言人3"
    },
    {
      "time": "00:12:08",
      "text": "法国人要说2222 10加8.",
      "speaker": "发言人2"
    },
    {
      "time": "00:12:11",
      "text": "然后脑子里面全乱了，一团浆糊，还得先把那个电话号码拆成一个数，然后这个叫什么来着？那个数论叫什么来着？就是每一个自然数可以拆成这么几个数，就是那个质数的那种什么就power的组合啊啊啊。",
      "speaker": "发言人3"
    },
    {
      "time": "00:12:28",
      "text": "叫fundamental .",
      "speaker": "发言人2"
    },
    {
      "time": "00:12:30",
      "text": "serum of a math，中文叫算术基本定理算术。",
      "speaker": "发言人3"
    },
    {
      "time": "00:12:37",
      "text": "基本定理。",
      "speaker": "发言人4"
    },
    {
      "time": "00:12:39",
      "text": "算术基本定理。它就是说。",
      "speaker": "发言人3"
    },
    {
      "time": "00:12:40",
      "text": "每个大于一的自然数均可以写为质数的积。对，而且这些因就。",
      "speaker": "发言人1"
    },
    {
      "time": "00:12:45",
      "text": "它有一个唯一的表示。",
      "speaker": "发言人3"
    },
    {
      "time": "00:12:47",
      "text": "叫大小排列之后只有一种表示。",
      "speaker": "发言人1"
    },
    {
      "time": "00:12:50",
      "text": "这跟后面那个有我们要讲的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:12:51",
      "text": "那个unit就是质因数分解吗？",
      "speaker": "发言人4"
    },
    {
      "time": "00:12:55",
      "text": "还不一样，他他讲的是另外一个事儿，就是说其实这个跟我们后面要讲的那个的那个Normalization有点怪，有有点异有点异曲同工的意思。",
      "speaker": "发言人3"
    },
    {
      "time": "00:13:04",
      "text": "OK对。",
      "speaker": "发言人4"
    },
    {
      "time": "00:13:06",
      "text": "所以你要先这首先是这是正整数，而且你要先要断定说是什么是质数。",
      "speaker": "发言人2"
    },
    {
      "time": "00:13:11",
      "text": "对对对，然后它就有一种唯一的分解法。对，然后这个就是算术基本定理。",
      "speaker": "发言人3"
    },
    {
      "time": "00:13:19",
      "text": "我们为什么从键盘扯到这边？",
      "speaker": "发言人2"
    },
    {
      "time": "00:13:21",
      "text": "对，为什么扯到这边？说说法国人拆那个数好吧，OK各国念这个电话号码。",
      "speaker": "发言人3"
    },
    {
      "time": "00:13:28",
      "text": "的习惯应该是有一定的规律的了。我记得VTP的还有一个页面是专门汇总各国的这个习惯。",
      "speaker": "发言人4"
    },
    {
      "time": "00:13:38",
      "text": "所以也是你们念中国的手机号是先念，比如说34423434344.",
      "speaker": "发言人1"
    },
    {
      "time": "00:13:44",
      "text": "这样的规则。",
      "speaker": "发言人4"
    },
    {
      "time": "00:13:45",
      "text": "OK不看那个，很多人是335是吧？",
      "speaker": "发言人1"
    },
    {
      "time": "00:13:48",
      "text": "看那个就是叫什么，就是区号的区分。比如说中国的手机号码都是统一都11位，都是344，然后那个座机号码就不一定了，因为有些地区是最开始是这还有历史有五位、六位、七位、八位的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:14:03",
      "text": "对，现在基本都是八位的。",
      "speaker": "发言人4"
    },
    {
      "time": "00:14:05",
      "text": "八位大城市一次八位44.",
      "speaker": "发言人3"
    },
    {
      "time": "00:14:07",
      "text": "叫小村。而且主要是还有他有那个就是长途电话的区号吗？区号理论上讲就是三位或者四位，中国是三位或者四位的。对，日本是有两位的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:14:19",
      "text": "因为小区号其实是两位或三位，然后补一个0。",
      "speaker": "发言人4"
    },
    {
      "time": "00:14:24",
      "text": "对，国内波是补0，要跟那个国际长途分开。对，很多人不知道这个事情，就是怎么播那个国际长途，为什么是区号都是0？",
      "speaker": "发言人3"
    },
    {
      "time": "00:14:36",
      "text": "然后一个什么要要要对，要省掉那个零对吧？",
      "speaker": "发言人2"
    },
    {
      "time": "00:14:39",
      "text": "不是是有些国家是不省的。不是。",
      "speaker": "发言人1"
    },
    {
      "time": "00:14:41",
      "text": "中国对审不审是看那个电话规则。",
      "speaker": "发言人4"
    },
    {
      "time": "00:14:44",
      "text": "不是这样的，中国是这样的，就是说如果中国你播0，然后你再加一个数字的话，是就呃不。首先如果你播本地local number就不需要播区号的话，它肯定不会是零开头的，对不对？然后如果你要播另外一个区的话，你可能是零加一个非零数字开头的这他就知道你现在在播区号了，对不对？但是你拨00的话，其实就是变成所谓的那个加号。对，这个是在国际的那个prefix，它是这么来区分的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:15:13",
      "text": "OK然后这个时候就牵涉到一个表达的问题了。就是说比如说我们中国会写假设，比如说深圳市075555。对对对，深圳是075对吧？但是如果说你从外国打到深圳的话，你是拨008686是中国的那个国际期货代码。然后这个时候你就不会说不会拨075，你只会拨755。因为前面八六已经确定了你是中国，然后你要在下面就跟着要播区了，对吧？所以你看很多人写那个名片上的表达，他会写加号86，然后零括号表示optional是可选的，然后是755.",
      "speaker": "发言人3"
    },
    {
      "time": "00:15:48",
      "text": "从后面再跟一，我也再跟你确定这个零是可选的吗？就是我我的理解是不是每个国家打这个，就是不是从每个国家打打外国的电话的时候，这个零都是可以省略的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:15:58",
      "text": "中国是反，中国是可选的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:15:59",
      "text": "范没有，绝大多数都是的。就我的经验来讲的话，只有意大利不行。因为意大利他们本身那个号就是有一个零，所以那个零就不用省。",
      "speaker": "发言人2"
    },
    {
      "time": "00:16:09",
      "text": "它的开头是零有零开头的这个。",
      "speaker": "发言人3"
    },
    {
      "time": "00:16:12",
      "text": "对，就是意大利。",
      "speaker": "发言人2"
    },
    {
      "time": "00:16:14",
      "text": "这其实是有一份国际标准的，就是国际有个叫ITU的跟通信有关的组织，他对这个电话号码的注记格式对他对这个电话号码的注记格式，包括有些零是不是可以放在括号里，就是可选的这个格式。对，首先它的书写是有一个规范的，其次就这个书写对应的规范，其实是跟各国的这个电话制式的有关的。对，其实这个电话号码要不要加0，这个零可不可以省略，以及它是不是可选的，其实是跟那个模拟时代的这个通信的原理。",
      "speaker": "发言人4"
    },
    {
      "time": "00:16:47",
      "text": "那个叫什么程控机的那个东西是吧？",
      "speaker": "发言人3"
    },
    {
      "time": "00:16:50",
      "text": "这应该是可以查证的，只是我我我以前学的一些东西有点记得不太清楚。",
      "speaker": "发言人4"
    },
    {
      "time": "00:16:56",
      "text": "对，这个时候要透露你的底牌了吗？",
      "speaker": "发言人3"
    },
    {
      "time": "00:16:59",
      "text": "没有，我们真宇的专业。",
      "speaker": "发言人2"
    },
    {
      "time": "00:17:03",
      "text": "其实是。",
      "speaker": "发言人3"
    },
    {
      "time": "00:17:04",
      "text": "好吧，其实这个跟通信比较相关。但我的专业虽然有一些跟通信相关的东西，但还有离得有一点远，只是会顺带的学到一次。",
      "speaker": "发言人4"
    },
    {
      "time": "00:17:16",
      "text": "听众朋友们，我郑重的告诉你们一个惊人的事实，在座的四位主持里面竟然全部都是具有理工科背景。",
      "speaker": "发言人3"
    },
    {
      "time": "00:17:23",
      "text": "的这很惊人吗？这不是很正常吗？",
      "speaker": "发言人1"
    },
    {
      "time": "00:17:26",
      "text": "我一直以为你们两个是文科生。",
      "speaker": "发言人3"
    },
    {
      "time": "00:17:29",
      "text": "我靠，你太看不起他们了。你不能因为他们两个是自弹自唱的就看不起他们。",
      "speaker": "发言人1"
    },
    {
      "time": "00:17:36",
      "text": "只要看不起文科生。",
      "speaker": "发言人4"
    },
    {
      "time": "00:17:38",
      "text": "不是这不是这这个是一个这个是一个什么来着？所谓什么物以类聚，人以群分，所以我们要搞这个什么大串联，结果发现穿来穿去还是一伙人。",
      "speaker": "发言人3"
    },
    {
      "time": "00:17:48",
      "text": "你对文科生有什么幻幻？",
      "speaker": "发言人2"
    },
    {
      "time": "00:17:52",
      "text": "因为觉得特别文艺，这个挺好的，我就缺这个东西。",
      "speaker": "发言人3"
    },
    {
      "time": "00:17:55",
      "text": "自弹自唱不文艺。",
      "speaker": "发言人4"
    },
    {
      "time": "00:17:57",
      "text": "Rex是学什么的？说rex以前之前念了一个博士，那个哲学的博士。",
      "speaker": "发言人1"
    },
    {
      "time": "00:18:04",
      "text": "现在rax应该是我们这里比较偏社科类的。",
      "speaker": "发言人4"
    },
    {
      "time": "00:18:09",
      "text": "我想对rex是念哲学硕士，应该是之前他是本科学学经济的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:18:16",
      "text": "好像还好还好，终于有一个非非理工背景的人。",
      "speaker": "发言人3"
    },
    {
      "time": "00:18:22",
      "text": "那可是right rex不愿意上咱们的节目。",
      "speaker": "发言人1"
    },
    {
      "time": "00:18:26",
      "text": "对，rex好像都没有出现过怎么一回事。",
      "speaker": "发言人3"
    },
    {
      "time": "00:18:29",
      "text": "对他连自弹自唱都没有上。",
      "speaker": "发言人2"
    },
    {
      "time": "00:18:31",
      "text": "没有太太太不给面子了也没关系。",
      "speaker": "发言人1"
    },
    {
      "time": "00:18:35",
      "text": "我主编大人出场的话要有一个隆重的仪式，我已经给他安排好话题了，请大家期待。",
      "speaker": "发言人2"
    },
    {
      "time": "00:18:41",
      "text": "OKOK非常好。",
      "speaker": "发言人1"
    },
    {
      "time": "00:18:45",
      "text": "好，我们推进到最后一个听众反馈，最后一个也是在TIB上给我们的留言，他的ID是link zero。然后他说说到反斜杠，我首先想到的是钛和我们上期其实提了一下太，但没有细讲。泰和在反斜杠里就是作为转移符吗？还是什么？",
      "speaker": "发言人4"
    },
    {
      "time": "00:19:06",
      "text": "反斜杠在tag里作为转音符。对，没错，就是以反斜杠开头的一个标志符，然后后面可以可选用花括号方括号的一个parameter。",
      "speaker": "发言人1"
    },
    {
      "time": "00:19:19",
      "text": "在泰国里面还有一些什么希希腊文字母也都是用都是就像转译符一样，都用反斜杠开始用。",
      "speaker": "发言人2"
    },
    {
      "time": "00:19:25",
      "text": "对，说到这个反斜杠，我上次终于见到有人真人在我现实生活中的一个朋友，他用反斜杠表示，或者就是A或者。",
      "speaker": "发言人3"
    },
    {
      "time": "00:19:34",
      "text": "B上海很多的好了。",
      "speaker": "发言人4"
    },
    {
      "time": "00:19:37",
      "text": "不是在现实生活中，就是不是在魔幻都市里。",
      "speaker": "发言人1"
    },
    {
      "time": "00:19:41",
      "text": "而是在对对对。",
      "speaker": "发言人3"
    },
    {
      "time": "00:19:44",
      "text": "是上海原来就这样被你抛离了。现实生活。",
      "speaker": "发言人4"
    },
    {
      "time": "00:19:52",
      "text": "对，反正我还当时看的还是蛮蛮吃惊的。我我都都很想问说。",
      "speaker": "发言人3"
    },
    {
      "time": "00:19:56",
      "text": "为什么要用这个？不为你还没有说清楚他他在什么样情况下用的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:20:01",
      "text": "这个就是他写两个选项，我们说比如说就中文里面你会写A或者B的时候，你会把它利用斜杠把它表示选项。",
      "speaker": "发言人3"
    },
    {
      "time": "00:20:10",
      "text": "他是在手写还是在打字的时候。",
      "speaker": "发言人1"
    },
    {
      "time": "00:20:14",
      "text": "是那个打字对，打字的时候，而且他两种混用，关键是你要的，所以他在他看来这个左滑右滑其实。",
      "speaker": "发言人3"
    },
    {
      "time": "00:20:22",
      "text": "是要逼死处女座。处女座。",
      "speaker": "发言人2"
    },
    {
      "time": "00:20:24",
      "text": "但其实想想好像也没什么区别，就是左滑和右滑有什么区别？",
      "speaker": "发言人3"
    },
    {
      "time": "00:20:27",
      "text": "没什么区。在座有处女座吗？没有，但是我不能容忍这样，尤其是在一篇文章里面就混用这个东西。",
      "speaker": "发言人2"
    },
    {
      "time": "00:20:37",
      "text": "对他其实是个约定了。就是你单纯从这个作用上来说，你用左斜和右斜都是能起到同样的作用。",
      "speaker": "发言人4"
    },
    {
      "time": "00:20:45",
      "text": "那我问一个问题，你说在那种阿拉伯文这种从右向左写文字里面。",
      "speaker": "发言人3"
    },
    {
      "time": "00:20:51",
      "text": "他用什么阿拉伯文的逗号都是往往右逗了的，你知道吗？",
      "speaker": "发言人2"
    },
    {
      "time": "00:20:56",
      "text": "刚好做了个镜面对称。",
      "speaker": "发言人3"
    },
    {
      "time": "00:20:57",
      "text": "对，还有阿拉伯文那个问号也是镜面对称的，对。",
      "speaker": "发言人2"
    },
    {
      "time": "00:21:01",
      "text": "那样我不帮你解释一下，你们德国为什么前面那个引号要放在下面。",
      "speaker": "发言人3"
    },
    {
      "time": "00:21:05",
      "text": "这就是德意志的传统，就是从那个哥特文字，就是从那个哥特体的时代，black letter的时代的那个引号就一直是在那儿的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:21:15",
      "text": "就是左下右上对吧？",
      "speaker": "发言人3"
    },
    {
      "time": "00:21:16",
      "text": "应该是对一。这一开始是在左下，而且那个引号引的方向也是反的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:21:21",
      "text": "然后中文的那个方括号是左上右下。",
      "speaker": "发言人3"
    },
    {
      "time": "00:21:25",
      "text": "对吧，这个比较make sense。中文竖排的时候，那个就是一个符号，也是应该从左上角开始写。所以写括号好像也应该在左上角。",
      "speaker": "发言人1"
    },
    {
      "time": "00:21:34",
      "text": "竖排是右上左下对，竖排是右上左下。对，为什么呢？竖排右上左下的话符合笔顺。如果你是左上的话，就变成要运笔的话，要写完笔画。对对对，你右上左下的话就符合书写的笔顺，就是横折，就是横折和竖折。",
      "speaker": "发言人2"
    },
    {
      "time": "00:21:56",
      "text": "没错。",
      "speaker": "发言人1"
    },
    {
      "time": "00:21:57",
      "text": "这也是假设是又又利索的情况。但是中文默认。",
      "speaker": "发言人3"
    },
    {
      "time": "00:22:00",
      "text": "都是这样的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:22:01",
      "text": "左右手你也不可能从左下开始写一个挑然后右折。",
      "speaker": "发言人1"
    },
    {
      "time": "00:22:08",
      "text": "这很怪。就是中文的基本笔画顺序叫从上到下。",
      "speaker": "发言人2"
    },
    {
      "time": "00:22:13",
      "text": "比如说阿拉伯那些是默认是左利手的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:22:15",
      "text": "不是因为他们的运笔的话要从右往左画，就是横要往右往左画横。",
      "speaker": "发言人2"
    },
    {
      "time": "00:22:20",
      "text": "但阿拉伯人大部分也是用对手。",
      "speaker": "发言人1"
    },
    {
      "time": "00:22:24",
      "text": "但我只是说文就是文字从文字上讲。",
      "speaker": "发言人2"
    },
    {
      "time": "00:22:28",
      "text": "所以还是一个习惯问题，还是一个习惯问题。",
      "speaker": "发言人4"
    },
    {
      "time": "00:22:33",
      "text": "就没有什么不能改的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:22:34",
      "text": "就可能有一定的偶然因素。",
      "speaker": "发言人4"
    },
    {
      "time": "00:22:37",
      "text": "所以汉字的运笔的话默认是从左往右的。比如说你写一个口口的最后一笔的话，你不可能就我就顺便第就第二笔画画画，画画回来从右往左就连成了一笔，不能这样的，你要另外起第三笔从左往右写是在画圈，就是中文默认只能从左往右，他没有从右往左的笔划中文。",
      "speaker": "发言人2"
    },
    {
      "time": "00:22:59",
      "text": "好OK明白好吧？",
      "speaker": "发言人4"
    },
    {
      "time": "00:23:00",
      "text": "这样我们终于。",
      "speaker": "发言人3"
    },
    {
      "time": "00:23:02",
      "text": "花了半个小时的时把反馈说完了，那我们现在进终于可以进入正题了ok。我们上次第一期节目把从头到尾大概过了一遍，我们敲击下一个键盘，然后让一个字显示在屏幕，最后打印出来，终于发生了什么。我们现在终于可以开始拆开来一步一步讲了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:23:28",
      "text": "但今天讲的好像也不是键盘。",
      "speaker": "发言人1"
    },
    {
      "time": "00:23:31",
      "text": "今天我们讲什么？讲乱码是吗？",
      "speaker": "发言人2"
    },
    {
      "time": "00:23:34",
      "text": "对，这这个有点像这个有点像从显示开始了，从先先从显示的这一层面来讲，为什么有时候会看到我们不想看的东西，或者我们想看的东西显示出来是错误的？",
      "speaker": "发言人1"
    },
    {
      "time": "00:23:48",
      "text": "其实首先这个概念就是客户就是从用户来讲的话，他显示不正常，他就觉得是乱码。其实这个乱码的背后有很多不一样的道理，对吧？就是因为如果你一直从那个字面上来讲，乱码就是首先你有个码，然后那个码不对了就变成乱码。可是实际上并不一定完全都是码的问题，有时候还有这个字库显示的问题或者其他问题，对吧？",
      "speaker": "发言人2"
    },
    {
      "time": "00:24:16",
      "text": "英语里面有个乱码叫什么不知道。",
      "speaker": "发言人1"
    },
    {
      "time": "00:24:19",
      "text": "英文里面会有乱码吗？",
      "speaker": "发言人3"
    },
    {
      "time": "00:24:21",
      "text": "对，因为英文里面只有ask，虽然他们不存在乱码，而且乱码也就是我们我们双字节开始的。所以在日本来讲，日本他们说在英文世界里，他们都把乱码叫成某七八K是我们日语传过去的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:24:35",
      "text": "叫什么？",
      "speaker": "发言人1"
    },
    {
      "time": "00:24:37",
      "text": "因为日语叫魔机，8K就是文字。",
      "speaker": "发言人2"
    },
    {
      "time": "00:24:40",
      "text": "OK魔姬是文字。",
      "speaker": "发言人1"
    },
    {
      "time": "00:24:41",
      "text": "然后8K的就是变化，就是文字变掉了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:24:46",
      "text": "OK德语里面叫猜想，就是符号沙拉。对，就好像沙沙拉一样被办被绊脚起了。",
      "speaker": "发言人1"
    },
    {
      "time": "00:24:59",
      "text": "那英文叫什么？",
      "speaker": "发言人2"
    },
    {
      "time": "00:25:00",
      "text": "Including .",
      "speaker": "发言人4"
    },
    {
      "time": "00:25:02",
      "text": "error编码错误。",
      "speaker": "发言人3"
    },
    {
      "time": "00:25:04",
      "text": "应该就叫不就是就是因为。",
      "speaker": "发言人1"
    },
    {
      "time": "00:25:06",
      "text": "就感觉这个事情在英文里面其实挺难出现的。你想象一下他们都是那个asking对吧？大部分都基本上所有的这个编码方式都都兼容他们。",
      "speaker": "发言人3"
    },
    {
      "time": "00:25:17",
      "text": "那即便如此，比如说他们看到一个比如说俄语的那个编码，然后用什么用198859来显示的时候，那同样是没有任何意义的文字。那他们对这个玩意，对这个东西总有一个总总得有个称呼。",
      "speaker": "发言人1"
    },
    {
      "time": "00:25:36",
      "text": "反正在危机上面有一个这样相关的一个页面叫磨叽8K就是日文的那个影OK.",
      "speaker": "发言人2"
    },
    {
      "time": "00:25:44",
      "text": "就是音译的。日语是a garbo，garbo的text OK好吗？德语就是chasing salad.",
      "speaker": "发言人1"
    },
    {
      "time": "00:25:54",
      "text": "对应的对对。",
      "speaker": "发言人3"
    },
    {
      "time": "00:25:55",
      "text": "就是德文的拆分salad这个配置，这个就翻译成乱码。然后日语的英文界面。",
      "speaker": "发言人2"
    },
    {
      "time": "00:26:01",
      "text": "就是磨叽8K所以英文其实它是直译了，对它直译了。",
      "speaker": "发言人4"
    },
    {
      "time": "00:26:06",
      "text": "这OK所以英语没有。",
      "speaker": "发言人1"
    },
    {
      "time": "00:26:08",
      "text": "一个原生的这个就像是eo就是日文对这现代字符编码的一些贡献。",
      "speaker": "发言人2"
    },
    {
      "time": "00:26:18",
      "text": "这其实是一个比较本地化的一个说法，就是这种事情可能只是在东亚地区最先出现，然后日本又是一个最早在CJK领域确定了字符串比较标准字符集的这样一个国家。所以他们可能最早遇到这个问题，他们就创了一个术语。所以我们要从字符集和编码开始说。",
      "speaker": "发言人4"
    },
    {
      "time": "00:26:40",
      "text": "可以。",
      "speaker": "发言人1"
    },
    {
      "time": "00:26:42",
      "text": "那先讲中文，中文的GB编码是不能不说的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:26:47",
      "text": "好吧，是不是应该先讲汉字？整个的这个因为实际上东亚地区以CJK为核心的这个字符集的标准，最早是日本人做的。就是jess.",
      "speaker": "发言人4"
    },
    {
      "time": "00:27:02",
      "text": "对日本在那个时代有比较强烈的支持日本的需求，因为日本是东亚第一个开始电子化的国家，应该这么说。",
      "speaker": "发言人1"
    },
    {
      "time": "00:27:15",
      "text": "对。或者我觉得一部分原因也是因为他们最早能够在计算机上勉强的使用一些本地的文字。比如他们将那个片假名用asp的扩展，实现了日本。",
      "speaker": "发言人4"
    },
    {
      "time": "00:27:28",
      "text": "最早的一个文字编码，应该是GS的0201，它是个单字节的，很关键。它把这个七位的ask给他扩展，上面放入了他们的半角的片假名。而且他们在这里面还和阿斯卡里相比，还有两个字儿不一样。他们在那个99 2那一号原来是反斜杠，然后在这个祭祀里面他给他换成了日元符号。然后在126号里面原来是一个波浪，但是在这个句子里面给它换成了这个叫什么上划线，这不是下划线，也不是中划线那个连子符，而是一个上划线。所以这个比较古老了，因为已经是1969年6月1号制定的。这个可是日本最老最旧的一个文字系统，就是文字编码。所以这是第一次他们就是在这个计算机上面实现了日本。",
      "speaker": "发言人2"
    },
    {
      "time": "00:28:30",
      "text": "为什么那个时候要选片假名不选平价名？",
      "speaker": "发言人1"
    },
    {
      "time": "00:28:33",
      "text": "那就是传音就是打电报，因为这是主要是为了通信的方便。",
      "speaker": "发言人2"
    },
    {
      "time": "00:28:39",
      "text": "OK对。",
      "speaker": "发言人1"
    },
    {
      "time": "00:28:41",
      "text": "其实通常来说在技术领域是将日本的这个书写系统对应到4种字符上的。就是四种文字上。也就是在writing system下面，它用了4种的script。一种是所谓的罗马字，也就是拉丁文了。另一种就是片假名，还有一种平假名，最后才是汉字。",
      "speaker": "发言人4"
    },
    {
      "time": "00:29:05",
      "text": "我就是打个岔问个问题，日本有没有想过有没有过要把汉字整个废掉磁场，就是只用假名。",
      "speaker": "发言人1"
    },
    {
      "time": "00:29:13",
      "text": "有应该有吧？有，然后因为朝鲜就是有这样的字，而且朝鲜的确是朝鲜半岛朝鲜已经成功了，朝鲜的话他已经几乎就都不用了。韩国的话就是偶尔还用，但是现在也是尽量都是用那个文英文。对，中文叫中文习惯叫燕文。对，但是他们他们但他们不喜欢燕文这个词，他们觉得燕文这个词是有有歧视，所以他们更喜欢用hung .",
      "speaker": "发言人2"
    },
    {
      "time": "00:29:44",
      "text": "gw这个词所以hung gu和燕文其实还有两个词。",
      "speaker": "发言人4"
    },
    {
      "time": "00:29:48",
      "text": "对，因为晏文晏所谓的验是谚语的，谚就是俗俗字的俗字的意思。但是日本人倒是很乖的用假名，因为假名的对应的是真名，所谓的真名就是汉字。对日本人还。",
      "speaker": "发言人2"
    },
    {
      "time": "00:30:04",
      "text": "怪怪不是借的意思吗？",
      "speaker": "发言人1"
    },
    {
      "time": "00:30:06",
      "text": "在这里就是假借。对，所以假名的还有它的反义词是真名，所谓的真名就是汉字。所以后来即使后面在用片甲加入片，就是什么半角片假名义之后进行了。从七八年开始，他们后来83年、90年、97年改了好多次，然后后面就逐渐的相当于在区位码里面把所有的字都加进去了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:30:33",
      "text": "够用吗？那个码数。",
      "speaker": "发言人3"
    },
    {
      "time": "00:30:36",
      "text": "也是不停的加，所以每每改一次的话就是字数越来越多。",
      "speaker": "发言人2"
    },
    {
      "time": "00:30:40",
      "text": "因为你用那个SKI，你把高位置市场中也只有128个。",
      "speaker": "发言人3"
    },
    {
      "time": "00:30:45",
      "text": "SK只用来实现那个半角假名。对，SK的扩展就是SK扩展，它当然有一个这次的roman d就是一个对SKI的一个可以说是一个的一个variation了。",
      "speaker": "发言人4"
    },
    {
      "time": "00:31:00",
      "text": "你说半角假名还有全角假名。",
      "speaker": "发言人3"
    },
    {
      "time": "00:31:02",
      "text": "对，一开始只有半角假名吗？这个概念其实有点乱了，我们是不是可以趁机来整理一下，就是所谓的这个半角假名，它一方面指的是这个假名的宽度是全髋汉字的一半。然后同时另一方面他也同意的指向了说这个字符只使用了一个字节这样子的一个意思。",
      "speaker": "发言人4"
    },
    {
      "time": "00:31:24",
      "text": "所以在上次节目我也说过，就是所谓的单字节双字节和半角全角原来是两个概念。但是在字体排印里面是半所谓的半角全角，它只是一个宽度的概念而已。",
      "speaker": "发言人2"
    },
    {
      "time": "00:31:38",
      "text": "对，半角全角其实应该局限于描述视觉上的一个效果。",
      "speaker": "发言人1"
    },
    {
      "time": "00:31:42",
      "text": "对，它是实际物理上面的一个宽度问题。单字节双字节，这就是是编码的问题。而在在很久以前的确半半脚的就是单字节，然后全角的就是双字节，所以就可以有人开始混用了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:32:02",
      "text": "对，而且这个混用其实是带有一定的主动性的。就是说他们并不是错误的用了它，而是希望以这种方式帮助别人理解和记忆。",
      "speaker": "发言人4"
    },
    {
      "time": "00:32:13",
      "text": "是这两个吗？到了现在混在一起了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:32:17",
      "text": "所以那个假名到底是就是说个数一共能不能装到128个麻点里面去。",
      "speaker": "发言人3"
    },
    {
      "time": "00:32:24",
      "text": "实际上就是在最早的时候，它就是G4X的0208的话，它只赚了94个字，就只装了那个半角片甲面。",
      "speaker": "发言人2"
    },
    {
      "time": "00:32:34",
      "text": "就这样差不多用完了。128个点你用了九十几个94个，那全角的跟这个半角的有什么区别？",
      "speaker": "发言人3"
    },
    {
      "time": "00:32:40",
      "text": "是得用两个字符了吗？就用两个字节来表示。",
      "speaker": "发言人1"
    },
    {
      "time": "00:32:43",
      "text": "不就是。但是他表达的他就说一个半角的假明星和全角假名，他表示的是同一个东西吗？是同一个东西。",
      "speaker": "发言人3"
    },
    {
      "time": "00:32:49",
      "text": "所以现在就变成做两套了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:32:52",
      "text": "为什么要做两套？因为那个半角假名显示的时候，有一个就是一开始的那个假名的片假名在显示的时候，它的宽度和英文字母是一样的。对，然后为了当所以后来有了那个全宽度的汉字的时候，你在全宽度的汉字里面夹杂着显示半宽度的片假名就很丑。所以就做了一套全宽度的拳脚加密，就是这么来的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:33:23",
      "text": "所以我理解一下，因为是为了对齐的需求，因为那个时候是都是那种column display，就是阵列的显示器，就为了满足那个跟英文对齐的需求。所以我们强制牺牲了这个美观程度，把那个假名压缩成半段的对，然后后来因为有你后面因为就变成那个图形graphic的界面的时候就是为了好看。其实它应该是假明星。",
      "speaker": "发言人3"
    },
    {
      "time": "00:33:50",
      "text": "应该和汉字等宽的。没有到graphic时代，就是在那个显示器可以设置为双字节宽的时代就开始了。对，就跟汉字一样。这个需求就是因为是为了好看，为了好看，你在如果你两个汉字中间夹着一个半宽度的假名就很丑。而且制表什么乱七八糟的全都非常难。",
      "speaker": "发言人1"
    },
    {
      "time": "00:34:10",
      "text": "还是为了对齐。只是说以前是因为了半对半宽是为了和英文字母对齐，是为了和汉字本是为了和汉字对齐。",
      "speaker": "发言人3"
    },
    {
      "time": "00:34:18",
      "text": "对，但是比如说在日日本的，比如说当年就emo的手机时代。日本的手机时代因为片假名它是表音文字，所以片假名的外来语往往都写的很长。所以他故意用半角片假名是为了省空间。",
      "speaker": "发言人2"
    },
    {
      "time": "00:34:36",
      "text": "节约POK.",
      "speaker": "发言人1"
    },
    {
      "time": "00:34:37",
      "text": "就免得出现节约的情况。",
      "speaker": "发言人3"
    },
    {
      "time": "00:34:39",
      "text": "空间有这么做的。为什么要背德语德文。",
      "speaker": "发言人1"
    },
    {
      "time": "00:34:42",
      "text": "的单词那么长？",
      "speaker": "发言人2"
    },
    {
      "time": "00:34:44",
      "text": "因为德语你每个词都不写，都那么长。",
      "speaker": "发言人3"
    },
    {
      "time": "00:34:47",
      "text": "又没有空余，说需要大量使用简写和缩写。",
      "speaker": "发言人1"
    },
    {
      "time": "00:34:51",
      "text": "所以在在从字体排印的传统上来讲，德文是大量使用了和字nature和窄体字condense。",
      "speaker": "发言人2"
    },
    {
      "time": "00:35:00",
      "text": "对，是这样。尤其在高速公路路牌上。",
      "speaker": "发言人1"
    },
    {
      "time": "00:35:03",
      "text": "半宽的假名看起来会不会很别扭？",
      "speaker": "发言人3"
    },
    {
      "time": "00:35:05",
      "text": "因为那么窄，会有一点了，确实会有一点，反正我觉得很丑，对它是一种妥协。",
      "speaker": "发言人4"
    },
    {
      "time": "00:35:14",
      "text": "OK所以于是下一个问题就来了，就是说那半宽的假名对应的那个那个码点和全宽就是双字节的码对应的码点，它它有这个是一样的吗？或者这么问，就是说如果现在现在的这个来处理的话，它是两个字符。",
      "speaker": "发言人3"
    },
    {
      "time": "00:35:32",
      "text": "对，是是显示显示是不一样的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:35:36",
      "text": "OK在unicode里面的那个call point，它是一样的吗？",
      "speaker": "发言人3"
    },
    {
      "time": "00:35:40",
      "text": "好像也不一样。",
      "speaker": "发言人1"
    },
    {
      "time": "00:35:42",
      "text": "不一样。Unicode它为了向后兼容，所以它也不一样。对。",
      "speaker": "发言人2"
    },
    {
      "time": "00:35:48",
      "text": "那那如果说我们现在重新来设计这么一件事儿，其实它应该是从同一个core point。但是在render渲染的时候，应该选择不同的宽度以适应那个对齐就可以了。",
      "speaker": "发言人3"
    },
    {
      "time": "00:35:58",
      "text": "对，从理想角度的确实是可以这样做的是没错。对但对那对但这是一个向后兼容，历史就要重写了。",
      "speaker": "发言人4"
    },
    {
      "time": "00:36:08",
      "text": "对，这其实是一个。",
      "speaker": "发言人3"
    },
    {
      "time": "00:36:10",
      "text": "无法避免的问题了。因为这个编码的发展就是向后兼容有这个需求，所以它一定会保留两套。哼。",
      "speaker": "发言人4"
    },
    {
      "time": "00:36:19",
      "text": "对，以前是做了很多莫名其妙的事情，然后后面来的新方案就不停的要为前面。",
      "speaker": "发言人2"
    },
    {
      "time": "00:36:26",
      "text": "的擦屁股。好惨。",
      "speaker": "发言人3"
    },
    {
      "time": "00:36:31",
      "text": "然后后面我们就终于有了双字节了，对吧？有了双字节就有了区位，就所谓的以前的区位码。那日本好像叫屈点是吧？对，日本叫屈点，那英文区就是区是肉，就第几排柔，然后那个点就是刚说的就是sale。",
      "speaker": "发言人2"
    },
    {
      "time": "00:36:50",
      "text": "那这就是举这个行和列，所以他他是真的是有一个表，然后一行是多几行几列是什么字，会有这么一个表出来，对吧？对的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:37:03",
      "text": "后来咱们中国的GB的设计就是完全沿沿袭的这个技术的整个设计系统。而且是所以双字节。",
      "speaker": "发言人2"
    },
    {
      "time": "00:37:11",
      "text": "和那个区都是日本人。",
      "speaker": "发言人3"
    },
    {
      "time": "00:37:13",
      "text": "最早是日本的是祭司。对，而且咱们也是学习日本的，就是把汉字根据使用频率分成了两个等级，常就是常用字和次常用字。然后日本他们叫第一水准汉字和第二水准汉字。",
      "speaker": "发言人2"
    },
    {
      "time": "00:37:31",
      "text": "在怎么一种一流和二流的感觉？",
      "speaker": "发言人3"
    },
    {
      "time": "00:37:33",
      "text": "就是根据那个频使用的频率，那咱们的GB的2312也是吗？而且咱们常用字的话是按照音序排列的那字常用字就是按照笔画部首是笔画部首是就按照部首部首按部首排列的对。",
      "speaker": "发言人2"
    },
    {
      "time": "00:37:53",
      "text": "这个表，就是有按两个音序和这个部首排列的。这个表是后来所有做这个的输入法，然后转换到汉字那个基础。",
      "speaker": "发言人3"
    },
    {
      "time": "00:38:04",
      "text": "对，内核恐慌就是吴涛单独做一期，就是做了编码那一期。他开始一开始就说了一个问题，一首先是一个encoding，就是编码和解码的过程，对吧？所以GB比如说GB2312，它到底规定了什么东西？它不仅是规定的那个字会就是我要收这么多汉字，而且他还规定了要怎么来编这个码。",
      "speaker": "发言人2"
    },
    {
      "time": "00:38:26",
      "text": "就说这个就是GB2312那个那个书里面应该是有一个很很长的一个列表，把那个区每个区位的汉字都写。那然后再规定一个方法去怎么去索引。",
      "speaker": "发言人3"
    },
    {
      "time": "00:38:37",
      "text": "到那个汉字。因为GB2312它的正式名字叫信息交换用汉字编码字符集。首先它是要信息交换的，它是给汉字进行编码的。是一个字符，然后有个字符字符集character set这样一个东西。",
      "speaker": "发言人2"
    },
    {
      "time": "00:38:56",
      "text": "OK OK它是。",
      "speaker": "发言人3"
    },
    {
      "time": "00:38:58",
      "text": "94个区，94个区，94个位，然后就有这么多这个马位，然后把6763个汉字给它放进去。当然了除了汉字以外，还有那些什么图形符号什么东西的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:39:15",
      "text": "等一下你说94个区，94个是说有这个据94，94乘以94一个格子，对吧？",
      "speaker": "发言人3"
    },
    {
      "time": "00:39:22",
      "text": "这个跟祭祀是一样的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:39:25",
      "text": "那你刚才说常用和不常用从哪里体现出来呢？",
      "speaker": "发言人3"
    },
    {
      "time": "00:39:29",
      "text": "常用和不常用是两个集合，就是是常用不常用是人为规定的两个集合。然后他们以先后次序。",
      "speaker": "发言人1"
    },
    {
      "time": "00:39:37",
      "text": "如果在那个表格里面，他他因为你刚才讲有理由有两种方式来排序，一种是按这个读音排一个。",
      "speaker": "发言人3"
    },
    {
      "time": "00:39:44",
      "text": "其实不是这样，有点混。就是说首先将它们分成了常用和不常用两个区块。",
      "speaker": "发言人4"
    },
    {
      "time": "00:39:50",
      "text": "你可以理解成然后有对两个两类字，你先给我，你先把那个字。",
      "speaker": "发言人2"
    },
    {
      "time": "00:39:56",
      "text": "对，我们一般叫class，我们一般叫class。就一个class叫常用OK，或者说叫一级汉字。另一个class是不常用，叫二级汉字。那么在一级汉字这个class内部，它的排序是按英式的，而在二级汉字内部它的排序是按部首。",
      "speaker": "发言人4"
    },
    {
      "time": "00:40:12",
      "text": "的那跟这个94乘以94这个格子有什么？",
      "speaker": "发言人3"
    },
    {
      "time": "00:40:16",
      "text": "94乘94只是它排布这个区位表的一种方式。",
      "speaker": "发言人4"
    },
    {
      "time": "00:40:21",
      "text": "对号入座就是94，94是座位，而那些字就是把把它安到这个座位上去。",
      "speaker": "发言人2"
    },
    {
      "time": "00:40:30",
      "text": "那所以我可以这么理解吗？就是在这个94乘以94一个方格子里面，前半部分是常用的汉字，然后是按序音序排的，后半部分是不常用的汉字。",
      "speaker": "发言人3"
    },
    {
      "time": "00:40:40",
      "text": "三不，其实就是什么？从第16到55区是一级汉字，然后你所有一级汉字放在这里面，就是从第16区到第55区改成就是相当于一级汉字按拼音顺序排列，一共375 3755个。然后从第56区开始，一直到第87曲是二级汉字。然后拍了3008个，然后前面还有什么特殊符号之类的对，那个字就是音序里面的第一个字，它区位码是1601，就是它十六区的第一个。",
      "speaker": "发言人1"
    },
    {
      "time": "00:41:16",
      "text": "所以大家如果去翻这个GB的话，他就每个汉字它只是给每个汉字安排了一个座位。所以比如说字是1601，但问题是后面我们就好我们这个1601就怎么编程码，这是编这是另外一个编码的事情。对，我们刚刚讲的都是一些字符集的事情。对，所以不仅是有字，然后还要有个编码的过程。我们先有我们先找到那么多字，再给他安排这么多码位，然后给它放上去以后，还要进行编码。",
      "speaker": "发言人2"
    },
    {
      "time": "00:41:54",
      "text": "等等我我打个岔问一下。所以区位码和那个unique的那个code point是可以对应起来的对吧？",
      "speaker": "发言人3"
    },
    {
      "time": "00:42:00",
      "text": "可以对应，但是排列方式是完全不一样的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:42:06",
      "text": "就是说应该说GB2312它这份国家标准，它同时涉及两部分。一部分它涉及的是一个我们常称叫做编码字符集的这样一个字符集标准。而另一部分它也同时包含了一套编码的encoding的一套规则。",
      "speaker": "发言人4"
    },
    {
      "time": "00:42:25",
      "text": "对，那那我重新描述一下，应该是这么说，就是说GB22312这个我们作为编码方式来讲的时候，它是对应的是UTF8、UTF16、TF3这种东西。然后GB2312这个标这个规范里面那个区位和区位码其实对应unicode的那个code point。",
      "speaker": "发言人3"
    },
    {
      "time": "00:42:46",
      "text": "G2312就相当于一个只有一个编码方案，只有UTF16编码方案的code。",
      "speaker": "发言人1"
    },
    {
      "time": "00:42:52",
      "text": "对，没错，对，OK是。现在来讲这个GB2312作为编码方式的时候，他怎么玩的吗？",
      "speaker": "发言人3"
    },
    {
      "time": "00:43:04",
      "text": "作为编码方式来怎么就其实就是每个就其实跟GUTF16 1样，就是每个汉字和符号都需要两个字节，因为一个字节放不下，然后第一个字节叫高位，第二个字叫低位。然后高位高位有一个高位，高位有一个对应的方法，就是把一它它一的一共用了87个区，就是96个区没有用完，然后从一区到87区那个二级汉字加上特殊符号就已经排完了。所以他就把那个字节0X10XA0，就是16进制的A0加上1到87，然后低位字节是1到94，加上0XA0。所以如果你有一个是，所以0XA00XA10XA1就是相当于第一区的第一位就这么来的。然后高位字节就是相当于0XB0到0XF7，第二字节是0XA1到0XFE，然后一共有6768个马尾，然后有有一些是空的对。",
      "speaker": "发言人1"
    },
    {
      "time": "00:44:22",
      "text": "所以他这个高位字节和低位字节其实并没和那个区没关系，是没有什么关系。",
      "speaker": "发言人3"
    },
    {
      "time": "00:44:27",
      "text": "对，高位字低位节完全对应于区号加上就相当于XY。对。",
      "speaker": "发言人1"
    },
    {
      "time": "00:44:40",
      "text": "相当于XOY，就是说这两个。因为那个表我们刚才讲那个tree，它是一个方格，就是94乘以94。所以刚好如果我用两个字节来表示，就高位字节对应的是行，然后低位字节对应的是列。",
      "speaker": "发言人3"
    },
    {
      "time": "00:44:54",
      "text": "是这样是这是这个。",
      "speaker": "发言人1"
    },
    {
      "time": "00:44:55",
      "text": "意思对吧？",
      "speaker": "发言人3"
    },
    {
      "time": "00:44:56",
      "text": "就是实际上是一个87到94的长方形。",
      "speaker": "发言人1"
    },
    {
      "time": "00:45:00",
      "text": "有有几个区是没有用的对吧？",
      "speaker": "发言人3"
    },
    {
      "time": "00:45:03",
      "text": "对，就87以后到94驱就没有用。",
      "speaker": "发言人1"
    },
    {
      "time": "00:45:05",
      "text": "所以其实并不是一个方90乘以90方的格子。",
      "speaker": "发言人3"
    },
    {
      "time": "00:45:08",
      "text": "而它没有填满，有空。对他没有就有座位空着。",
      "speaker": "发言人4"
    },
    {
      "time": "00:45:12",
      "text": "但大致上可以认为高位之间表示行，然后低位字表示，中间有一些特殊的空空格的地方。对，然后这个每个都要加上这个16进制的A0，是可以转化为SK的那个就是第一位置为一的时候，就128期OK make刚才。",
      "speaker": "发言人3"
    },
    {
      "time": "00:45:31",
      "text": "说了几2312他只有六千多个汉字不够用，所以后来就又进行了扩展，后面就有什么GBK，然后后面还有GB18030。",
      "speaker": "发言人2"
    },
    {
      "time": "00:45:44",
      "text": "对，我们小时候有很多同学的那个名字就是起一个冷僻的名字，然后到时候去录什么准考证，乱七八糟就录不出来。",
      "speaker": "发言人1"
    },
    {
      "time": "00:45:52",
      "text": "就是因为这个有比如说什么两个吉祥的吉念喆。",
      "speaker": "发言人2"
    },
    {
      "time": "00:45:57",
      "text": "哼陶喆。",
      "speaker": "发言人1"
    },
    {
      "time": "00:46:01",
      "text": "对，这个字原来是作为哲学的哲的异体字废弃不用的。所以在当时的那个GB2312里面，是没有这个字的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:46:11",
      "text": "OK我当时有个同学叫什么，叫他什么立威。对他中间有一个立字，好像是木字旁，右边有一个看起来像威海的威，但是下面是个乐，就很很冷僻的一个字，每次录录准考证它就叫断空格费。",
      "speaker": "发言人1"
    },
    {
      "time": "00:46:35",
      "text": "好可怜。当时我记得就是为了解决用GV2312这个字符集不够用这种生僻字。很多人是用那个位图的方式是表示那些生僻字的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:46:47",
      "text": "就直接画个图形。还有人手写的，不是就是机器打不出来，所以后面手写不。另外一个是吧？",
      "speaker": "发言人2"
    },
    {
      "time": "00:46:54",
      "text": "对，这也是一个解方案，和那个用位图的方式差不多。那有一个问题，就是GBK和GB18030也是用两个位的吗？就是双字节GB18030本身.",
      "speaker": "发言人3"
    },
    {
      "time": "00:47:08",
      "text": "两个字结构吗？三应该要用四字节。",
      "speaker": "发言人4"
    },
    {
      "time": "00:47:11",
      "text": "还是是对GB130它是四字节。",
      "speaker": "发言人2"
    },
    {
      "time": "00:47:14",
      "text": "的那GBK，如果按照刚才那个GB2312的编码方式，那我们高位都不用，都留出来。就是就每你两个字节，其实只有一共14个位可以用。14的2的14次方应该是16384个字。然后GBK其实收入了21880 886个.",
      "speaker": "发言人3"
    },
    {
      "time": "00:47:33",
      "text": "其实肯定是不够用的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:47:36",
      "text": "所以怎么解决这个问题的？所以刚才我那个算法不对，他那个双字节它只算第一个字节的那个那个第一位是不能用的，其实是应该有15个位可以用，15个位的话其实可以用到32000多个那个那个叫什么马？",
      "speaker": "发言人3"
    },
    {
      "time": "00:47:53",
      "text": "所以GPK是双字节的，然后GB18030的话是双字节，四字节混用。对，GPK本身它不是一个正式的GB.",
      "speaker": "发言人2"
    },
    {
      "time": "00:48:04",
      "text": "GBK是微软搞的，是不是？",
      "speaker": "发言人3"
    },
    {
      "time": "00:48:06",
      "text": "对，它就是内马是扩的K是扩展的扩。但是它它本身扩展的扩，但是就是汉字内码扩展规范，但是它本身它没有号，其实因为它不是一个正式的基地。",
      "speaker": "发言人2"
    },
    {
      "time": "00:48:19",
      "text": "对，GB是国标的意思吗？",
      "speaker": "发言人3"
    },
    {
      "time": "00:48:21",
      "text": "它不是一个正式的国标文件。",
      "speaker": "发言人2"
    },
    {
      "time": "00:48:24",
      "text": "对，其实我们说GBK的时候，大多数指的是它的那个字符集标准，而不是指它的编码方式。那么GBK这个字符值，你完全可以用UIQLO的来给它编码。",
      "speaker": "发言人4"
    },
    {
      "time": "00:48:35",
      "text": "那那那那那GBK和GB2312是什么关系？",
      "speaker": "发言人3"
    },
    {
      "time": "00:48:39",
      "text": "GB2312它首先定义了一个字符集，就定义了一个字符集的标准。同时它还给了一套编码方案OK。但是同时GB2312的那个字符集，我们也可以用unicode的来给它编码。也就是说一个字符集它是可以用很多种编码方式来实现它的。同时以一种编码方式，它也是可以去编很多个不同的字符集的。就是他们并不是一个完全一一对应的关系。所以其实我们在讨论这些的时候，只要时刻的区分清楚，我们是在说一个字符集，还是在说一个编码方式的话，就不太会混淆。",
      "speaker": "发言人4"
    },
    {
      "time": "00:49:18",
      "text": "好，单从字符集的来讲的话，所以就是现在大家在买字体的时候，就经常会说这个字体显示不出来。那在做在中国的字体厂商的话，肯定他是首先是要做B2312里面的。他那个字一共是六千多个字。他是先做这个，然后就那些。",
      "speaker": "发言人2"
    },
    {
      "time": "00:49:38",
      "text": "是必一般来讲。",
      "speaker": "发言人3"
    },
    {
      "time": "00:49:40",
      "text": "这是最低的门槛。然后后面有支持GBK的的字库，然后有支持GB18030的字库。说实话GB18支持18030的字库还非常少的。现在字实在是太多了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:49:55",
      "text": "对，完整支持的非常少。对，反正是6万。",
      "speaker": "发言人4"
    },
    {
      "time": "00:49:59",
      "text": "因为那时候在做的时候，把什么少数民族兄弟兄弟民族的一些文字也一起做进去了？",
      "speaker": "发言人2"
    },
    {
      "time": "00:50:07",
      "text": "对，一个不小心可能就超过了open type单个文件的gliff的限制了。对，因为一个open type它是用一个outside shot的。所以只有6万也只有六万多个，就应该是655多少？",
      "speaker": "发言人4"
    },
    {
      "time": "00:50:23",
      "text": "655355。对对对，6536对。",
      "speaker": "发言人3"
    },
    {
      "time": "00:50:26",
      "text": "很有可能就放不下。然后再从。",
      "speaker": "发言人4"
    },
    {
      "time": "00:50:28",
      "text": "编码方式的说，刚才我们也讨论了，GB2312和GBK都是双字，都是双字节的字符集的那GB18030的是单字节双字节，四字节就是它是变长的。这个思想的话跟unico就是一样的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:50:47",
      "text": "我问一个问题，就是GB18030那个码点和UNI ode的码点是重合的吗？不一样，也不一样。后来是后面要讲那个CJK unification的关系。",
      "speaker": "发言人3"
    },
    {
      "time": "00:50:58",
      "text": "所以就是同样一个字的话，在GB里面它是这个座它是这个座位，要用这个编码。但是在在uni k的话，它是另外一个座位，要另外一个编码。",
      "speaker": "发言人2"
    },
    {
      "time": "00:51:07",
      "text": "那那GB2312，GBK和GB18030他们是一个超级的关系吗？",
      "speaker": "发言人3"
    },
    {
      "time": "00:51:12",
      "text": "还是也不一样？基本上是互相兼容的，就是向后兼容向后溶的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:51:17",
      "text": "就是GBR就GBK里面包含GB2312312那些字，并全部的在那个对应的位置上。然后GB18030是包含GBK全部的字，并且也是在那个位置上。",
      "speaker": "发言人3"
    },
    {
      "time": "00:51:30",
      "text": "对。",
      "speaker": "发言人2"
    },
    {
      "time": "00:51:31",
      "text": "是这样。",
      "speaker": "发言人4"
    },
    {
      "time": "00:51:32",
      "text": "那就是一个超级一个比一个大的概念了。",
      "speaker": "发言人3"
    },
    {
      "time": "00:51:36",
      "text": "对对对，在这个GB的这一系列字符集里面，最坑的只有GB2345这个标准，那么其他的都是一个就是越向后越往前兼容，就是说后来的肯定是兼容前来的这样的。",
      "speaker": "发言人4"
    },
    {
      "time": "00:51:50",
      "text": "所以我们在这里有机会一定要说一下GB12345.",
      "speaker": "发言人2"
    },
    {
      "time": "00:51:55",
      "text": "这个是什么？",
      "speaker": "发言人3"
    },
    {
      "time": "00:51:57",
      "text": "一个特别坑。TB12345我从来没有听过这个东西。",
      "speaker": "发言人1"
    },
    {
      "time": "00:52:00",
      "text": "对。",
      "speaker": "发言人3"
    },
    {
      "time": "00:52:02",
      "text": "GB2345是那个字体圈的一个噩梦。",
      "speaker": "发言人4"
    },
    {
      "time": "00:52:07",
      "text": "都搜不到这个东西。",
      "speaker": "发言人3"
    },
    {
      "time": "00:52:09",
      "text": "就经常说的就是那个什么繁体字字符集。它其实编码就是跟那个2312是一样的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:52:18",
      "text": "可以看成12，基本2312的繁体版本共收录有6866个汉字。",
      "speaker": "发言人1"
    },
    {
      "time": "00:52:23",
      "text": "对，但多了几个。",
      "speaker": "发言人4"
    },
    {
      "time": "00:52:25",
      "text": "因为大家知道就是樊简不是一一对应的。没错。那在汉字在简化的时候一般是多繁对，把好多个繁体字同时简化成一个简体字。所以原来他就是在GB2312是定的是简体字。那他改成12345的时候，他自他要写房地证，他就要变多。但是这个一繁多繁对一减的时候怎么办呢？他就会挑选一个简体字对应的繁体字先安上去，然后剩下的那些剩下的繁体字，他统一放到最后马位上的统一放在最后。",
      "speaker": "发言人2"
    },
    {
      "time": "00:53:04",
      "text": "就是之前那个说的那些空位的一些地方。对减繁转化这里可能要提一下，刚才说多繁对一减其实也有一点对，多繁就是多说错了。",
      "speaker": "发言人3"
    },
    {
      "time": "00:53:14",
      "text": "就是一反对多减是吧。你早说一简对多繁是非常常见的。但是一繁对多碱的话，它其实往往是一个一体字之间。对也但是的确也有的关也有。",
      "speaker": "发言人4"
    },
    {
      "time": "00:53:28",
      "text": "它它不是一个对这个这个哎数学上面怎么描述这种函数的概念来的。我想这不是函数干涉，不是一个单摄，对，不是单设的一个概念。",
      "speaker": "发言人3"
    },
    {
      "time": "00:53:39",
      "text": "一凡对多减，比如说乾坤的乾，对，在繁体字里话它可能是肝，也可能是钱，它是一个多音字。",
      "speaker": "发言人2"
    },
    {
      "time": "00:53:49",
      "text": "哼但是对照简体的就跟因为它用途不同，就把它分化成两种不同的写法了。",
      "speaker": "发言人3"
    },
    {
      "time": "00:53:54",
      "text": "对它把干的这个时候对应到另外一个字上去了，所以这个多音字就变成了一个单音字，专指乾坤的乾。",
      "speaker": "发言人2"
    },
    {
      "time": "00:54:03",
      "text": "所以其实很多很多朋友写的那种网页在线的什么简繁转换工具都是不合格的。",
      "speaker": "发言人3"
    },
    {
      "time": "00:54:10",
      "text": "对，如果你的算法很简单的话，确实会出错。",
      "speaker": "发言人4"
    },
    {
      "time": "00:54:14",
      "text": "他很多很多人都是直接拿一个map那个dictionary的表，就是一一这个换成那个就完了。但其实是要根据语境和前后文来决定的对吧？",
      "speaker": "发言人3"
    },
    {
      "time": "00:54:25",
      "text": "乾坤换成乾坤就还蛮多的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:54:29",
      "text": "然后说到这个GB12345的字体产品的话，我们也必须要说一下对吧？因为内码是一样的，所以在国内的一些大的字体厂商，他们曾经就是有到现在也有他们所谓的繁体字，汉字的字库就以换字库的形式来实现繁体，而不没有换内码。",
      "speaker": "发言人2"
    },
    {
      "time": "00:54:50",
      "text": "就是因为那个GB2345的问题。",
      "speaker": "发言人3"
    },
    {
      "time": "00:54:53",
      "text": "对，所以就是因为他们用12345来做编码。对对对，这个他只是在表面，因为到了用字库显示它，其实就是最后显示的层层级了，它码其实没变。对，这样的话这样做出来的GB12345的繁体字库就不能解决一点对多反的问题。然后就经常出错字，比如说永什么永和九年岁在葵丑，那个丑字就变成了美丑的丑了。所以我曾经在我的微博上讲，这对如果一个产品，它一个自顾产品如果会导致错字的话，我觉得这是这应该讲是一个不及格的产品。",
      "speaker": "发言人2"
    },
    {
      "time": "00:55:38",
      "text": "但是他的这种设计方式下，他没有别的解决方案了。",
      "speaker": "发言人3"
    },
    {
      "time": "00:55:41",
      "text": "对，所以就是说进就是应该废除用GB12345来分装字库。",
      "speaker": "发言人2"
    },
    {
      "time": "00:55:47",
      "text": "那个那个本来就是一个hack。",
      "speaker": "发言人3"
    },
    {
      "time": "00:55:49",
      "text": "对，那是一个固定时期的产物，而且是一个不成熟的产物。",
      "speaker": "发言人4"
    },
    {
      "time": "00:55:54",
      "text": "就过渡方案呗。你现在其实都就刚才我们说，你看我们都没有听过GB12345有规范，其实应该用的也不多了。",
      "speaker": "发言人3"
    },
    {
      "time": "00:56:03",
      "text": "对，就因为国内有几个大厂。",
      "speaker": "发言人4"
    },
    {
      "time": "00:56:05",
      "text": "就是大家现在去买繁体字字库的话，有很多就是这样的。所以又就另外一个问题，就是说繁简转换应该怎么转？就不能单纯的就是像用这个GB12345的字库，到最后只转字库而没有转码，我们应该彻头彻尾的把马换掉。",
      "speaker": "发言人2"
    },
    {
      "time": "00:56:25",
      "text": "就不能用那种dirty的hack。",
      "speaker": "发言人3"
    },
    {
      "time": "00:56:28",
      "text": "可是就是因为有大厂，中国的很多大厂的话都做了EGB112345的字库，所以导致现在街头巷尾很多错字都是这样。",
      "speaker": "发言人2"
    },
    {
      "time": "00:56:37",
      "text": "我就去砍了。",
      "speaker": "发言人3"
    },
    {
      "time": "00:56:40",
      "text": "这是名副其实的文字狱。",
      "speaker": "发言人1"
    },
    {
      "time": "00:56:46",
      "text": "好吧，我们终于可以说优衣库的问题了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:56:51",
      "text": "Windows的那个要不要先讲一下。",
      "speaker": "发言人3"
    },
    {
      "time": "00:56:53",
      "text": "就是为什么世界上会先有GBK？就是因为操作系统的发展已经远远超过了国家制定标准的发展。然后操作系统厂商微软不得不先解决了一个人们必须要解决的痛点，然后国家才跟上了，推出了GBKGBR什么18930来取代GBK。对我觉得从这个侧面其实反映出了现在处我们已经处在一个接近于那种跨国的或者怎么说呢？在这从这件事上开始，是跨国的公司取代政府来解决你的一些民生问题的一个时代。其实就是从这里从这种事情开始。",
      "speaker": "发言人1"
    },
    {
      "time": "00:57:39",
      "text": "如果你要说的话，一肯定就是政治，政治可能是落后的，永远都是经济先行的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:57:45",
      "text": "所以我的意思是我的意思是在在微软在这信息时代之前，很少会有一个公司会在这种跨国的超越政府界限这个程度上来改变我们的生活。",
      "speaker": "发言人1"
    },
    {
      "time": "00:58:03",
      "text": "大国小国其实这种事情经常发生。",
      "speaker": "发言人3"
    },
    {
      "time": "00:58:06",
      "text": "以前可能是有，但以前比如说IBM之类的，他们做的事情可能更多的也就是做制定一个国内标准，在国内工业的标准。但是在微软这件事情上，你由一个外国厂商来搞一个你国文字，这好像还是前前所未有的事情。",
      "speaker": "发言人1"
    },
    {
      "time": "00:58:24",
      "text": "我觉得不就是对于小国来说，这种事情应该经常发生。比如说什么周边那些可能人口也很少，占地面积很小的国家，他真的什么技术都是要由别人提供给他的，别人先用了他才说，我们还可以，就这样支持他了，就继承标准。",
      "speaker": "发言人3"
    },
    {
      "time": "00:58:42",
      "text": "其实类似的例子在这个CJK领域并不罕见。比如说那个字符集标准像，香港的那个字符集标准其实主要就是由华康和蒙娜两家字体公司来推动的。香港显然就是属于一个政府在这方面管制力不强的这样一个地区。对，就曾经了。对，包括像新加坡也是，新加坡早期是直接照搬了GB2312来作为他们这个文字标准的。后期uni QLE的出来之后，他们又收录了一部分号称来源是新加坡的一部分汉字。但是实际上这就是。",
      "speaker": "发言人4"
    },
    {
      "time": "00:59:22",
      "text": "为什么维基百科里面有马新简体。",
      "speaker": "发言人1"
    },
    {
      "time": "00:59:24",
      "text": "对，但实际上至今好像没有明确的来源，说这个新加坡来源的汉字是他们政府官方给的。",
      "speaker": "发言人4"
    },
    {
      "time": "00:59:33",
      "text": "不对，的确是有的，的确是有的，就是在新加坡当时它有新加坡的一些简化字，就和大陆简体不一样的，有几十个字，数量不多。",
      "speaker": "发言人2"
    },
    {
      "time": "00:59:43",
      "text": "OK这里可能要插一下历史，就中国大陆搞简化字的时候，新加坡也跟着搞了是吧？就当时他们做这个简化的背景和目的是什么？",
      "speaker": "发言人3"
    },
    {
      "time": "00:59:53",
      "text": "应该还是为了提高识字率，这个出发点都是类似。",
      "speaker": "发言人4"
    },
    {
      "time": "00:59:58",
      "text": "都是一样的。我倒觉得是为了贴合当时中华人中有一个怎么说呢？就站起来的国家，不是吗？就新加坡你不是也搞一个。不是民族认同感，而是因为新加坡本来就是一个华人建立的国家。然后他们看到这个母国非常强盛，就心向往之，或者说出是出于一种就是现在也有这种强势文化出现了。然后这个不是强势文化，而是一个有一个独立自主的国家出现了。那就采用了这样一种，就是我觉得是出于一种民族认同感来做的，不像那个不就是现因为现在大家都很讨厌中国，但那个时候中国刚出现的时候，还是比较让全球华人为之一振的。",
      "speaker": "发言人1"
    },
    {
      "time": "01:00:45",
      "text": "对，有可能有一部分这个因素。但是我的观点是认为还是因为新加坡其实在那个时期并没有这方面的专家来具体的制定一个新的标准的能力。所以他们情愿去搬一个在文化上面和在这个身份认同上都跟他们接近了国家的一个成熟标准。",
      "speaker": "发言人4"
    },
    {
      "time": "01:01:05",
      "text": "不，问题是你你你这个回避了一点，就是他们还有一个选择，就是什么也不做，继续用繁体。",
      "speaker": "发言人1"
    },
    {
      "time": "01:01:11",
      "text": "为什么一定要？你是说为什么要做简化是吗？对，OK是这样子。",
      "speaker": "发言人4"
    },
    {
      "time": "01:01:16",
      "text": "新加坡使用的汉字，他们在1969年他们颁布了新加坡的简体字表。然后这个简体字表有502个字，所以他们一般把这个称为502简体字表。然后这个简体字表和中华人民共和国汉字简呃简化方案是不一样的，然后里面有67个字是不一样的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:01:41",
      "text": "看看怎么处理。",
      "speaker": "发言人3"
    },
    {
      "time": "01:01:43",
      "text": "然后1976年的时候，新加坡又又说他们倒过来，完全采用中华人民共和国的简体字。",
      "speaker": "发言人2"
    },
    {
      "time": "01:01:51",
      "text": "就把那67个也干掉了。",
      "speaker": "发言人3"
    },
    {
      "time": "01:01:53",
      "text": "对，所以这67个字就是曾经出现过，但是现在已经不用的是，但是unicode.",
      "speaker": "发言人2"
    },
    {
      "time": "01:02:02",
      "text": "这种垃圾堆应该也装进去了。",
      "speaker": "发言人3"
    },
    {
      "time": "01:02:04",
      "text": "对，所以要装进去。",
      "speaker": "发言人2"
    },
    {
      "time": "01:02:06",
      "text": "有一些是装进去了，没全部装进去了。应该是我觉得你刚才real问说那个时候怎么处理，因为那1969年的时候，那个时候你注一页不一样的签字就可以了，那个时候没有电子化的问题。",
      "speaker": "发言人1"
    },
    {
      "time": "01:02:18",
      "text": "对，这个意思。对，就不存在麻点这个问题。",
      "speaker": "发言人3"
    },
    {
      "time": "01:02:22",
      "text": "对，对，所以我觉得他们用回GB2312，也是因为他们处理不了新的问题。他们没这个能力来做这方面新的技术规格书就不划算。",
      "speaker": "发言人4"
    },
    {
      "time": "01:02:33",
      "text": "你本来人口少的国家，你要做这种吃力不讨好的事情，何必？就像直接那个叫什么，按我们现在的话行话说叫直接来for cry use。",
      "speaker": "发言人3"
    },
    {
      "time": "01:02:46",
      "text": "对这个历史，包括在这个big five，big five也是开始照搬了这次的规范，然后自己做了一些扩展OK。",
      "speaker": "发言人4"
    },
    {
      "time": "01:02:55",
      "text": "所以现在有有个历史遗留问题，当比如说当时说微软搞了GBK，然后后来国家补了一个GB18030。那么实际上在这个微软的操作系统里面，到底是用编码的时候用GBK还是GB18030？",
      "speaker": "发言人3"
    },
    {
      "time": "01:03:15",
      "text": "Windows的内核应该是用UIQLO的对吧？",
      "speaker": "发言人2"
    },
    {
      "time": "01:03:18",
      "text": "对，那个都一样。它的内核表示它要支持多国语言，肯定是要用统一的标准。但是在默认比如说你有中文版的这个windows，你用这个记事本默认保存的时候，他选择的编码方式是啥？",
      "speaker": "发言人3"
    },
    {
      "time": "01:03:30",
      "text": "我是这么理解的，windows里面有一个默认的那个码本，就是有一个code page你得去选。然后你选什么，它默认的储存就是什么。对，如果你是中文版的windows的话，那默认就是GBR.",
      "speaker": "发言人1"
    },
    {
      "time": "01:03:45",
      "text": "18030应该是。对对对，我就这个意思就是说它等于是给某一个区域版本的windows选择了一个默认的保存的这个编码方式。",
      "speaker": "发言人3"
    },
    {
      "time": "01:03:55",
      "text": "和打开对的编码。",
      "speaker": "发言人1"
    },
    {
      "time": "01:03:56",
      "text": "对。",
      "speaker": "发言人3"
    },
    {
      "time": "01:03:57",
      "text": "打开和那个的。就好像有些人玩日文游戏，一定要先把那个code配置改成日文的。然后在玩的时候日文的游戏才不会显示乱码。但是其他系统的所有部分都是乱码了。",
      "speaker": "发言人1"
    },
    {
      "time": "01:04:06",
      "text": "没错。所以现在就windows用的那个copy到底默认是GPK还是GB？",
      "speaker": "发言人3"
    },
    {
      "time": "01:04:10",
      "text": "18030的，我记得是18030，我上一次改的时候应该还是要换一个三。",
      "speaker": "发言人1"
    },
    {
      "time": "01:04:15",
      "text": "现在已经变成18030了。",
      "speaker": "发言人2"
    },
    {
      "time": "01:04:17",
      "text": "现在已经因为那个时候没有GBK的时候，你自然就是就没有18030的时候，自然就是GBK。但是现在有的。",
      "speaker": "发言人1"
    },
    {
      "time": "01:04:25",
      "text": "所以就会牵涉到windows不同版本它有不同行为的这个结果了。",
      "speaker": "发言人3"
    },
    {
      "time": "01:04:29",
      "text": "是没错。",
      "speaker": "发言人1"
    },
    {
      "time": "01:04:31",
      "text": "那是但但然后因为刚才我们讲的那个GB2312，GBK和GB18030，它是一个逐渐超级的一个关系。所以新版本的windows它总是能兼容旧版本的那个文件的。",
      "speaker": "发言人3"
    },
    {
      "time": "01:04:47",
      "text": "理论上是这样，这个其实需要找一个windows对windows编程比较熟悉的人来解释。",
      "speaker": "发言人1"
    },
    {
      "time": "01:04:53",
      "text": "他们的编码方式是向后兼容。",
      "speaker": "发言人4"
    },
    {
      "time": "01:04:56",
      "text": "的对OK，所以就不存在说windows，比如说windows十默认是GB18030中文版。不对，他应该用我有点可得。Anyway假设他是用707B180，它存回去就还可以，也可以打得开之前windows比如说XP用GPK编码的时候存的东西。",
      "speaker": "发言人3"
    },
    {
      "time": "01:05:13",
      "text": "对，这是肯定可以的OK所以就说那个代码页这copake这个事情的话，就只有windows.",
      "speaker": "发言人2"
    },
    {
      "time": "01:05:22",
      "text": "在用了IBM的那套架构。",
      "speaker": "发言人4"
    },
    {
      "time": "01:05:25",
      "text": "对，因为在其他的像比如说麦克和links上面，它是你让你直接在叫什么就是保存的时候，文件编辑器它是。",
      "speaker": "发言人3"
    },
    {
      "time": "01:05:34",
      "text": "用那个check set的一个标志，应该对，没错，这是两种编码的标记的哲学。可以说是一个。",
      "speaker": "发言人4"
    },
    {
      "time": "01:05:44",
      "text": "是全系统的，一个是那个profile的，终于讲清楚这个windows和GB的那些东西了。现在开始。",
      "speaker": "发言人3"
    },
    {
      "time": "01:05:53",
      "text": "我不知道我们听众有没有被我们绕晕。",
      "speaker": "发言人4"
    },
    {
      "time": "01:05:57",
      "text": "我觉得其实对于很多听众来说可能并没有。",
      "speaker": "发言人1"
    },
    {
      "time": "01:06:00",
      "text": "我可能已经被。",
      "speaker": "发言人4"
    },
    {
      "time": "01:06:01",
      "text": "我们绕晕了。",
      "speaker": "发言人1"
    },
    {
      "time": "01:06:03",
      "text": "有有一种，这吴涛什么什么沙拉怎么说来着？",
      "speaker": "发言人3"
    },
    {
      "time": "01:06:07",
      "text": "猜心小篮子，对，全。",
      "speaker": "发言人1"
    },
    {
      "time": "01:06:09",
      "text": "脑子里。",
      "speaker": "发言人3"
    },
    {
      "time": "01:06:10",
      "text": "全是听的一脑的沙拉。",
      "speaker": "发言人2"
    },
    {
      "time": "01:06:13",
      "text": "以后是对，以后说你一脑浆糊，说你脑你一恼，太神经了。",
      "speaker": "发言人3"
    },
    {
      "time": "01:06:19",
      "text": "这个比较好听起来很高级猜。In salad.",
      "speaker": "发言人2"
    },
    {
      "time": "01:06:26",
      "text": "OK, 现在终于进入到了unicode的时代。其实电脑是并存的，在时间观念上是有有重叠的。",
      "speaker": "发言人3"
    },
    {
      "time": "01:06:35",
      "text": "应该说unicode的它作为一个独立的这样一个机构，他希望能推动全球文字编码和字符集的这两套标准都统一的这样一个目标。应该说，但是同时他又不能去废除那些地方性的编码方案。",
      "speaker": "发言人4"
    },
    {
      "time": "01:06:54",
      "text": "对，就只能想办法去都兼容呗。",
      "speaker": "发言人3"
    },
    {
      "time": "01:06:56",
      "text": "所以这样造成一个结果的话，他就是不可能像后兼容了。",
      "speaker": "发言人2"
    },
    {
      "time": "01:07:01",
      "text": "就必须要改改mapping了吗？",
      "speaker": "发言人3"
    },
    {
      "time": "01:07:03",
      "text": "对对对，除以及最新的那个asking.",
      "speaker": "发言人2"
    },
    {
      "time": "01:07:06",
      "text": "的马薇是B是什么美国人发明的吗？",
      "speaker": "发言人3"
    },
    {
      "time": "01:07:10",
      "text": "美国中心主义。",
      "speaker": "发言人1"
    },
    {
      "time": "01:07:11",
      "text": "应该说unicode的他用他定义字符集的时候，他创造了一个他称为叫什么unicode的什么scale scale那个叫什么scale value？就是它所谓的它这个unicode的标量值的这样一个非常规范的标记方式。那么这个值的这个数值显然跟SK和我们传统见到的一些编码的数值，就我们所谓的这个内码数值都是不一样的，它是一套完全独立的方案，但同时unicode的创造了三个主流的编码坊。Uni QLE的UTF86和32里面，十6应该是兼容SK的。但是不对，八是兼容SK的，但是那个十6和32就是完全独立的。",
      "speaker": "发言人4"
    },
    {
      "time": "01:07:57",
      "text": "因为字节宽度不一样的。",
      "speaker": "发言人3"
    },
    {
      "time": "01:07:59",
      "text": "对对对，就是32是1个固定宽度的一个编码方案。那么它的它是一个比较漂亮的编码方案，它的这个编码的数值跟unicode的scale value是一一对应的。",
      "speaker": "发言人4"
    },
    {
      "time": "01:08:14",
      "text": "因为它最宽有四个字节了。",
      "speaker": "发言人3"
    },
    {
      "time": "01:08:16",
      "text": "对，它是可以完全写出来。这个16的话就是由双字节和4字节切换的这样一个模式。8的话就是一个在单字节模式下是兼容。",
      "speaker": "发言人4"
    },
    {
      "time": "01:08:28",
      "text": "你虽然那个四个是很漂亮的，但是固定四个的话就很浪费。如果你你只存储比如说西文的话就非常浪费。哼所以后来大家就觉得还比较经济的方式，还是用变长的方式比较好。对，这样的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:08:46",
      "text": "而且还有一个问题是就是那个定仓的有解决不了的，待会会提到。",
      "speaker": "发言人3"
    },
    {
      "time": "01:08:53",
      "text": "所以刚才说的区位区有肉，然后位是sale，然后后面就开始有个平面了，就叫plan。然后好几个平面又变成一个group.",
      "speaker": "发言人2"
    },
    {
      "time": "01:09:06",
      "text": "变成一个组。这是整这是整对。",
      "speaker": "发言人3"
    },
    {
      "time": "01:09:11",
      "text": "这是整个unicode它的一个他必须要有这么多个座位，才能把所有的全世界这些字儿给安排下去。然后就会有我们常说的一个词，就是什么基本多语言平面，就是BMP basic model guo plane就是所谓的第零面。",
      "speaker": "发言人2"
    },
    {
      "time": "01:09:34",
      "text": "这个第零面应该说就是是一个双字节的，就16个bit的这样子的一个字符集的组合。这是因为早期UNIQL的，他没有想到会进来那么多的是越加越多，他就只定义了这样一个平面。对，这个平面成为了一个最基本的叫第零平面，或者叫BMP这样子。",
      "speaker": "发言人4"
    },
    {
      "time": "01:09:56",
      "text": "这是什么呢？65536个已经够用了。对。",
      "speaker": "发言人3"
    },
    {
      "time": "01:10:03",
      "text": "事实证明是不够的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:10:05",
      "text": "然后所以这里其实我们还是要把刚才那个东西再再稍微形象解释一下，我们刚才讲那个GB232，它规定了一个方格，94乘以94这么一个区间，有些空没用，但是它是一个也是一个矩阵。然后UNIOD其实我们讲的这个BMP这个基本面其实大致上可以对应为那个不过它是一个25256乘以256的1个.",
      "speaker": "发言人3"
    },
    {
      "time": "01:10:30",
      "text": "那就是乘出来就是6553665536个座位，就是这个马位。",
      "speaker": "发言人2"
    },
    {
      "time": "01:10:38",
      "text": "对，但其实这只是为了好看，它本质上还是一长串，就是一个数。就是它如果我应该想象到一个数轴上，它应该是一个一维的一个东西。",
      "speaker": "发言人3"
    },
    {
      "time": "01:10:48",
      "text": "对，然后再往里面添上各国的文字，对吧？就是刚才我们说的这个马位的事情。",
      "speaker": "发言人2"
    },
    {
      "time": "01:10:58",
      "text": "然后这个基本平面里面有些什么字是什么规定的，就是有什么讲究吗？",
      "speaker": "发言人3"
    },
    {
      "time": "01:11:04",
      "text": "就是按顺序往里填呗，这个屈屈屈位就非常多了。",
      "speaker": "发言人2"
    },
    {
      "time": "01:11:08",
      "text": "OK那那比如说我问一个问题，就是说中文字是放就大部分中文字是放在那个基本面里面的。",
      "speaker": "发言人3"
    },
    {
      "time": "01:11:17",
      "text": "常用的OK一级汉字基本都在里面。那比如说对于。",
      "speaker": "发言人4"
    },
    {
      "time": "01:11:21",
      "text": "刚刚才我们说的那些东西，就是说不是GB231里面，所有的字符都在基本面里面。",
      "speaker": "发言人3"
    },
    {
      "time": "01:11:30",
      "text": "他有在扩展面的对对，就是在后面的其他的面上的的确是有的。Ok OK明白。",
      "speaker": "发言人2"
    },
    {
      "time": "01:11:37",
      "text": "那那再问一个问题，就是说在这个uni IL de的基本面里面的那个马位的中文类，就是基本汉字。",
      "speaker": "发言人3"
    },
    {
      "time": "01:11:46",
      "text": "这个unicode里面已经有一个新的称呼，就是CJK统一表意文字了。这不仅是中文了，就是中日韩就大家全球大一统字形一样的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:11:57",
      "text": "文字全都可以塞在里面。",
      "speaker": "发言人1"
    },
    {
      "time": "01:11:59",
      "text": "OK这里就说要解释一下为什么会有这么一个事儿，就是它的逻辑是什么？",
      "speaker": "发言人3"
    },
    {
      "time": "01:12:06",
      "text": "它的逻辑就是UNILL的，是针对这个script这种东西来划分它的block的。我们刚刚说了就是说这个日语或者说日文，它作为一个书写系统，其实它用到了四种文字，就是包括拉丁平假名、片假名和汉字。Unicode的认为，你日本用的汉字、韩国用的汉字、中国用的汉字以及越南用的汉字，他们都是汉字。这一种script.",
      "speaker": "发言人4"
    },
    {
      "time": "01:12:31",
      "text": "你们都应该统一起来。",
      "speaker": "发言人3"
    },
    {
      "time": "01:12:33",
      "text": "既然明明是一个字，而且写法基本上也一样，那为什么不能就用一个码？",
      "speaker": "发言人1"
    },
    {
      "time": "01:12:37",
      "text": "比如说汉字123，各个地区大家都长得都一样，就没有必要用三个马位分别的码位。所以大致比如说汉字的一，那大家就统一起来。",
      "speaker": "发言人2"
    },
    {
      "time": "01:12:49",
      "text": "所以这里就牵涉到一个所谓的汉字的追根溯源的问题了。因为日文和韩文里面的汉字，它的来源是来自于中文的那个字，那就是说对就要问日本人民说，你们觉得你们这个汉字是对应到中国的哪一个？还要问韩国人民说，你们认为你们这个看对应中国的哪一个？那肯定说肯定。",
      "speaker": "发言人3"
    },
    {
      "time": "01:13:11",
      "text": "会出现对应到中文。",
      "speaker": "发言人1"
    },
    {
      "time": "01:13:13",
      "text": "对对对，那肯定会出现一种情况，就是说他们觉得韩国人觉得我这个字应该对应的中文那个字，然后日本人觉得这个字我应该对应的中文另外一个字。",
      "speaker": "发言人3"
    },
    {
      "time": "01:13:24",
      "text": "对吧？非常的混乱。",
      "speaker": "发言人2"
    },
    {
      "time": "01:13:27",
      "text": "对，这个怎么解决呢？但是首先。",
      "speaker": "发言人3"
    },
    {
      "time": "01:13:29",
      "text": "一个原则就是在做尤尼克的时候，大家各个国家先把各国的那个标准拿出来。日本又能拿出他的祭祀，韩国拿出他的KS，咱们中国拿出的是GB还有台台湾地区，还有他们拿出他们的大武。",
      "speaker": "发言人2"
    },
    {
      "time": "01:13:46",
      "text": "在中国拿的是GB哪个18030，还是GBK还是GB2312？",
      "speaker": "发言人3"
    },
    {
      "time": "01:13:50",
      "text": "不同的历史阶段应该拿出的是不同的文件。",
      "speaker": "发言人4"
    },
    {
      "time": "01:13:53",
      "text": "对好吧？但中国的情况比较简单，因为至少它我们是相互兼容的。对，就还不至于说乱掉。",
      "speaker": "发言人3"
    },
    {
      "time": "01:14:01",
      "text": "这种情况。对，然后对先拿出来的时候，就是各个国家拿出来它如它的一个首先一个原则就是说如果你在这些字儿，原来你在这个规，比如说在GB里面，它本来就是两个字的话，那我放到这个uni扣里面也是两个字，也就是原规则分开的话，我现在也分开，我不会给它合在一起。因为他要保证所谓的向后兼容。",
      "speaker": "发言人2"
    },
    {
      "time": "01:14:27",
      "text": "但这里有个问题，因为我理解日文的汉字和这个朝这个韩文的汉字里面应该都是对应的繁体字，不一定非常复杂。对。",
      "speaker": "发言人3"
    },
    {
      "time": "01:14:39",
      "text": "OK因为日文有日文汉字。然后刚才说吧各个国家的简化都不一样。比如说新加坡，他有新加坡的简化汉字，然后日文有日文的简化汉字，日文还有简化。对，有啊，而且还有经常会简化以后张冠李戴的字。比如说文艺的艺在日文的这个文艺的艺的简化就是草字头底下个白云的云。",
      "speaker": "发言人2"
    },
    {
      "time": "01:15:05",
      "text": "然后这个字在中文里面是有的。",
      "speaker": "发言人1"
    },
    {
      "time": "01:15:07",
      "text": "中文里面是另外一个字。",
      "speaker": "发言人2"
    },
    {
      "time": "01:15:09",
      "text": "为什么会追这种情况呢？就因为你国没有权利去管理我，去约束我国怎么简化字对吧？",
      "speaker": "发言人1"
    },
    {
      "time": "01:15:16",
      "text": "不不不，我是这个意思，就是说就是日文简化这个意义字简化成云。那时候他们没有说去看一下别人怎么做。",
      "speaker": "发言人3"
    },
    {
      "time": "01:15:24",
      "text": "是平行发展，他为什么要去看别人怎么做呢？OK就我国就在日本里面，在日本人的汉字里面没有云这个字，就没有上艹下云这个字。那他为什么不能用呢？",
      "speaker": "发言人1"
    },
    {
      "time": "01:15:35",
      "text": "做一个，如果人类历史可以改写的话，当年如果大家简化案子都商量一下就好了。",
      "speaker": "发言人2"
    },
    {
      "time": "01:15:41",
      "text": "不是如果对，如果我们黄翰早早一点统一世界的话，就没有这种。或者对从今日的角度讲，如果当年大日本建立了什么东亚共荣圈的也没有，这个就解决。",
      "speaker": "发言人1"
    },
    {
      "time": "01:15:56",
      "text": "一切问题都不成问题了是吧？",
      "speaker": "发言人3"
    },
    {
      "time": "01:15:59",
      "text": "对一这一切和一切技术问题，其实归根结底都是政治问题。",
      "speaker": "发言人1"
    },
    {
      "time": "01:16:04",
      "text": "所以最初期比如说。",
      "speaker": "发言人2"
    },
    {
      "time": "01:16:05",
      "text": "他出现这种情况怎么解决呢？就是比如说刚才说文艺的这个意志的时候，到unicode里面怎么办？",
      "speaker": "发言人3"
    },
    {
      "time": "01:16:11",
      "text": "就只能各给一个马脸吗？解现在。",
      "speaker": "发言人1"
    },
    {
      "time": "01:16:14",
      "text": "事实上是只有一个麻点，然后这个麻点是草上草字头的芸，日本人用这个字把它当成艺术的艺在用，中国人用这个字拿出当云云用。对，因为只是编码，然后用来显示，至于它是什么语义，这个是没有关系的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:16:36",
      "text": "OK这相当于一种更，你就是只规定形状。",
      "speaker": "发言人1"
    },
    {
      "time": "01:16:41",
      "text": "不规定意义。因为本来。",
      "speaker": "发言人3"
    },
    {
      "time": "01:16:44",
      "text": "你收的那个字符集的话，只是给每个字编一个座位而已。",
      "speaker": "发言人2"
    },
    {
      "time": "01:16:52",
      "text": "对。",
      "speaker": "发言人3"
    },
    {
      "time": "01:16:53",
      "text": "现在首先他们在CJK统一汉字，只是大家各自把各国选手拉出来，对吧？OK，所以最初的统一汉字有29941个字。中国国标当时就是拉出了2312和112345，然后台湾的台湾有他们的CNS，然后日本日本就是祭祀的那个0208，大概也是有11000多个字。韩国的话，韩国特别坑，汉字不是有多音字吗？韩国的他们那个KS的那个编码里面，它只是因为大家知道韩文它是发音，它发音会对一个字那多，导致于多个发音都对同一个汉字。",
      "speaker": "发言人2"
    },
    {
      "time": "01:17:46",
      "text": "那他们怎么解决？他们没有解决这个问题。",
      "speaker": "发言人3"
    },
    {
      "time": "01:17:47",
      "text": "没有没他们没有解决这个问题。在韩文的他们KS的那个编码里面，汉字有重复。",
      "speaker": "发言人2"
    },
    {
      "time": "01:17:54",
      "text": "就是它是取音的，它是取形和音，就是同一个形在不同读音的时候，比如刚才我们那个曲，歌曲和这个曲线它会把它有两个发点。",
      "speaker": "发言人3"
    },
    {
      "time": "01:18:07",
      "text": "所以在韩国的比如说KSC的那个5601里面，它有4888个字，但是其中有268个字是重复的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:18:16",
      "text": "然后转到uni这个unicode CGK的时候，都我们都给他合一了。",
      "speaker": "发言人3"
    },
    {
      "time": "01:18:20",
      "text": "没有合一，因为要保留，就是说还要相互接资源分离原则刚才说了，我们说的第一个原则就是自离分有自缘分离。原原来原来是分的话我必须要分，要不然的话你就没办法相互兼容的就所谓的向后。",
      "speaker": "发言人2"
    },
    {
      "time": "01:18:36",
      "text": "金融OKOKOK所以就说CJK这个unification其实是说中国的汉字和日本的汉字和韩国的汉字，如果如果有长得差不多的就混成一个。但是如果他们本身里面是有两个的，我们就不合。",
      "speaker": "发言人3"
    },
    {
      "time": "01:18:52",
      "text": "所以导致于这个和和分的这个规则特别的混乱，有的该合的不和，该分的不分之类的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:19:01",
      "text": "所以其实为了就为了省那么小几个麻点，我不如说直接复制过来就是划区，跟那个IP地址一样。说这一块你们中国人拿去够用了，不用再申请了，对吧？随便你怎么样，然后这一块儿韩国人你们拿去，随便你们怎么弄，然后这块日本人拿去你们随便怎么用，对吧？是不会更会更简单一点。",
      "speaker": "发言人3"
    },
    {
      "time": "01:19:20",
      "text": "但是这样就背离了unicode想要unify的这个初衷了。Unicode一开始的一个目的不就是让所有的字形如果相似的话，这就他们的意思就是如果这个世界上有这样一个符号，它在哪里的写法都是基本上是同一个事物。比如说一白云或者是可以。",
      "speaker": "发言人1"
    },
    {
      "time": "01:19:40",
      "text": "用那个Normalization来解决吗？",
      "speaker": "发言人3"
    },
    {
      "time": "01:19:45",
      "text": "比较复杂。因为后这可是。",
      "speaker": "发言人2"
    },
    {
      "time": "01:19:48",
      "text": "Normalization，最终的结果不就还是会像现在一样。",
      "speaker": "发言人1"
    },
    {
      "time": "01:19:53",
      "text": "不就是但是是一个一个是可选，一个是强加的问题，对吧？因为unification是你在制定规范的时候要选就给申请IP地址的时候，申请这个码位的时候就要先选。好说我们这个共用一个码位，但是你又要保持向后兼容的话，其实做这个事情是平白无故增加了复杂度。那如果你说the ization作为一个事后的一个东西，虽然我可以向后兼容，但是为了说得出来大家都还能够一个可比的话，我们再用一个Normalization规则把它换成一个统一的表达不就好了吗？Make .",
      "speaker": "发言人3"
    },
    {
      "time": "01:20:26",
      "text": "sense咳好吧，你可以这么说，但我觉得unicode的初衷可能是这就是unicode在unicode的制定的理念里面，兼容既有编码并不是占第一位。对，就是用Q的理想是就是从unicode之后再无别的编码了，对吧？OK那那如果你说你一定要保留原有的那个东西，那那相当于不要喝的初衷就没有了。",
      "speaker": "发言人1"
    },
    {
      "time": "01:20:54",
      "text": "他的主要诉求其实一开始的确就是为了大幅度减少这个收录的汉字的字数，尽然后就尽量去尊重各地的习惯。自行。那就是你原来是分离的，你就分离，然后能合的就合在一起。",
      "speaker": "发言人2"
    },
    {
      "time": "01:21:08",
      "text": "对，就还是统一为主兼对对。",
      "speaker": "发言人3"
    },
    {
      "time": "01:21:11",
      "text": "是比较灵活。但是就因为这个灵活的方式，就灵活就是复杂度，所以他说他的编码是针对字而不是对字形，就是对character进行编码，而不是对grief。",
      "speaker": "发言人2"
    },
    {
      "time": "01:21:25",
      "text": "OK明白，其实也不太对，刚刚才也说那个文艺的意思就不符合这个逻辑了。",
      "speaker": "发言人3"
    },
    {
      "time": "01:21:33",
      "text": "但是他们只是对字，所以就很复杂。的确像像合起来，比如说那个户口的户，中国大陆的话，户的第一笔是点儿，在台日本是一行，台湾是一瞥。",
      "speaker": "发言人2"
    },
    {
      "time": "01:21:49",
      "text": "是方向不一样吗？",
      "speaker": "发言人3"
    },
    {
      "time": "01:21:51",
      "text": "但是明白这个字，在unicode的话就认我们被当时认为是一个字，所以就只给他一个座位，就导致于各个地区如果想要他们各自的字形的话就显示不出来，就要不能通过这个就马未来来展现了。",
      "speaker": "发言人2"
    },
    {
      "time": "01:22:11",
      "text": "就只能通过字体革命来实现了。",
      "speaker": "发言人3"
    },
    {
      "time": "01:22:15",
      "text": "所以就说这不是字的区别，而是字形的区别。",
      "speaker": "发言人2"
    },
    {
      "time": "01:22:18",
      "text": "那等一下我有一个问题，如果是这样的话，我们做那种多语言文本的时候怎么办？",
      "speaker": "发言人3"
    },
    {
      "time": "01:22:25",
      "text": "所以非常痒，依靠你所用的那个字库文件。",
      "speaker": "发言人2"
    },
    {
      "time": "01:22:30",
      "text": "但字库文件不可能是啊就它会有这种对应一个码位，它有多个字符。",
      "speaker": "发言人3"
    },
    {
      "time": "01:22:38",
      "text": "比如说说汉森资源黑体。",
      "speaker": "发言人2"
    },
    {
      "time": "01:22:43",
      "text": "应该说它是唯一的一个。对，它是现存世上唯一一个能找到试图去解决刚才real提出这个问题的这样一个字体工程项目。",
      "speaker": "发言人4"
    },
    {
      "time": "01:22:54",
      "text": "对那那就如果说举个很简单例子，假设我要做这个CJK不是就是你们我们假设自弹自唱要出一个节目，然后出一个这种印刷品来说这几个字的区别。然后你们用unicode编码的时候要写出这个字，你能采取的方案就只有两个。要么找这种带有这个CJK不同字形variation的这种字体文件，一个可以搞定，然后你在那个那个编辑器里面去选择它。另外一个就是说选三个不同的字体，然后手工的去调那个字体。对，那个字应该用哪个字体？",
      "speaker": "发言人3"
    },
    {
      "time": "01:23:26",
      "text": "对的对，是的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:23:29",
      "text": "这种时候可能直接写markdown会比较简单，就你可你要么在unicode层面确保你写的每一个字是正确的，否则就只能用markdown来来来辅助。",
      "speaker": "发言人1"
    },
    {
      "time": "01:23:40",
      "text": "怎么什么。",
      "speaker": "发言人3"
    },
    {
      "time": "01:23:41",
      "text": "markdown sorry吗？就是up我指的其实就是HTML，就是你在那个时候标出说这一段文字是日文。对对对，没错，到时候再在那个4S里边指定说这一段用日文字体示。就不能直接用一个。",
      "speaker": "发言人1"
    },
    {
      "time": "01:23:54",
      "text": "很简单的那种。",
      "speaker": "发言人3"
    },
    {
      "time": "01:23:56",
      "text": "你得加人为的加入一些metadata才行。",
      "speaker": "发言人1"
    },
    {
      "time": "01:23:58",
      "text": "对对对，所以其实还是刚才那个问题，就是刚才uni QLO的这个unification，它是带来的后果就是在混排文字的时候出现这种不可指，就是不能很方便的指定的情况下，没有理想情况下。如果这三个的互字的三个国家的不同写法是没有统一的话，其实你是很可以很方便的让系统自动去fall back到对应国家的那个那个字上面去。",
      "speaker": "发言人3"
    },
    {
      "time": "01:24:19",
      "text": "但是话说回来，如果这是混排系统的话，你别说是机器了，连人都看不出来。比如说中国两个字，中国大陆的写法和日本的写法是完全一模一样的。所以如果你单写中国两个字，你不知道这是日文还是中文。",
      "speaker": "发言人2"
    },
    {
      "time": "01:24:33",
      "text": "而且你不知道他指的是中国还是日本的意思也不一样。",
      "speaker": "发言人1"
    },
    {
      "time": "01:24:36",
      "text": "对，因为日本也有中国地区。",
      "speaker": "发言人2"
    },
    {
      "time": "01:24:38",
      "text": "这什么意思？",
      "speaker": "发言人3"
    },
    {
      "time": "01:24:40",
      "text": "日本有一个地区就叫中国。",
      "speaker": "发言人4"
    },
    {
      "time": "01:24:44",
      "text": "所以这就是为什么在历史上日本管中国他们喜欢叫支那。就是因为如果说中国的话，对，他们就指的是日本的中国地区，就是广岛那那附近那叫日本，那是日本的中国地区。",
      "speaker": "发言人2"
    },
    {
      "time": "01:24:58",
      "text": "对，所以他们选择了这个法语词的发音。",
      "speaker": "发言人4"
    },
    {
      "time": "01:25:01",
      "text": "看起来比较洋气。支那不是法语。",
      "speaker": "发言人2"
    },
    {
      "time": "01:25:06",
      "text": "应该是吧？他应该是那个china的那个哪来的吗？",
      "speaker": "发言人4"
    },
    {
      "time": "01:25:10",
      "text": "就是印度就是是印度。",
      "speaker": "发言人2"
    },
    {
      "time": "01:25:13",
      "text": "那边过来的是吧？",
      "speaker": "发言人4"
    },
    {
      "time": "01:25:16",
      "text": "就是那个什么。",
      "speaker": "发言人3"
    },
    {
      "time": "01:25:17",
      "text": "final，对，现在英文也是。",
      "speaker": "发言人2"
    },
    {
      "time": "01:25:20",
      "text": "我们的派，就是同源。",
      "speaker": "发言人4"
    },
    {
      "time": "01:25:21",
      "text": "对，经常什么american relationship对吧？对。",
      "speaker": "发言人2"
    },
    {
      "time": "01:25:26",
      "text": "你就是这个词语有时候就挺就有时候看那个说说芝麻是一个什么歧视性的称呼，就觉得挺扯的。你自己翻英文的时候，你不写的什么3 al什么什么。",
      "speaker": "发言人3"
    },
    {
      "time": "01:25:36",
      "text": "所以其实支那这是一个历史上就很常用的一个词。对，就是到因为到后面打仗了以后才变成有有歧视。他原来他完全没有这个意思的，就没有歧视的。明白OK所以的话这个退回来讲，就是你如果单纯写中国这两个字的话，你更别说是机器了，连人也看不出来这到底是中文还是日文。所以还是要非常仔仔细细的去mark。",
      "speaker": "发言人2"
    },
    {
      "time": "01:26:04",
      "text": "对你需要给他一个low care的这样一个信息，他才能更加正确和精确的显示你所想要的结果。这其实是一个信息处理的一种架构或者哲学。其实大家可以去看那个小零件写的那本CJKV的这个信息处理的那本书了。他应该算是一个这方面的专家，然后他应该方方面面都会照顾到这些问题，然后告诉你在不同的层面他们分别是用什么样的技术去解决的。我们不可能依赖unicode这样一种技术方案来解决所有的问题。",
      "speaker": "发言人4"
    },
    {
      "time": "01:26:42",
      "text": "所以刚才你们说中文的中国和日文的中国在unique l里面是不同的点位。",
      "speaker": "发言人3"
    },
    {
      "time": "01:26:47",
      "text": "一样一样的一样的。",
      "speaker": "发言人4"
    },
    {
      "time": "01:26:48",
      "text": "是一模一样OK但是你写出来是一样的，就不涉及这个问题。",
      "speaker": "发言人3"
    },
    {
      "time": "01:26:53",
      "text": "写出来完全没有。对，没错，OK对。",
      "speaker": "发言人2"
    },
    {
      "time": "01:26:55",
      "text": "那就靠语境写出来完全一样，取决于你从谁的角度来看。不就是假如你是一个日本人写的中国两个字，然后你让中国来看，可能看不出来。但如果你用一个日文字体的话，你会看到中国这两个字在日文和中文字体里面有不一样的风格。所以多少还是能判断出来这是一个有可能你可以判断出来这是日本的中国。",
      "speaker": "发言人1"
    },
    {
      "time": "01:27:17",
      "text": "就是中文就看语义了，就是看那个上下文在讲什么。",
      "speaker": "发言人3"
    },
    {
      "time": "01:27:20",
      "text": "不是看语义，就看字形。",
      "speaker": "发言人1"
    },
    {
      "time": "01:27:21",
      "text": "他的意思是看design，因为看那个形状。",
      "speaker": "发言人2"
    },
    {
      "time": "01:27:26",
      "text": "每个国家的字形标准都有多少的区别。",
      "speaker": "发言人1"
    },
    {
      "time": "01:27:31",
      "text": "那是得在风格的问题，设计风格的问题。所以这个CJK统一统一汉字就捅它叫统一表意文字。一所以。",
      "speaker": "发言人2"
    },
    {
      "time": "01:27:43",
      "text": "后来一直。",
      "speaker": "发言人1"
    },
    {
      "time": "01:27:45",
      "text": "当然字数不够用，所以就一直扩展，然后后面就扩展A区，扩展B区。我们我们节大陆说扩展ABCDE，现在已经有E区了。台湾他们那边说扩展甲乙丙丁戊，这个说法不一样而已，其实东西写的东西是一样的，现在有F区了是吗？都已经到，所以这字儿是越来越多。",
      "speaker": "发言人2"
    },
    {
      "time": "01:28:07",
      "text": "好像是有这各种。",
      "speaker": "发言人1"
    },
    {
      "time": "01:28:08",
      "text": "考古挖出来一些新字儿也得加进去吗？",
      "speaker": "发言人3"
    },
    {
      "time": "01:28:12",
      "text": "对，什么而且什么传传小篆、大篆之类的都可以加进。",
      "speaker": "发言人1"
    },
    {
      "time": "01:28:17",
      "text": "对。",
      "speaker": "发言人3"
    },
    {
      "time": "01:28:19",
      "text": "所以因为本身uni KO它本身也一直都在更新，是至少优衣库的8.0的话已经有扩已经到扩展E区了，这是已经有了，就是我已经收已经收进去了。对。",
      "speaker": "发言人2"
    },
    {
      "time": "01:28:36",
      "text": "所以以后我们不能说把什么扫进故纸堆里面，我们得扫进uni KO这个垃圾坑里面。",
      "speaker": "发言人3"
    },
    {
      "time": "01:28:46",
      "text": "好，这是说到uni扣的这个字的问题，对吧？然后uni KO的编码。",
      "speaker": "发言人2"
    },
    {
      "time": "01:28:50",
      "text": "问题这个坑就大了。之前我吴涛在那一单那期单口节目里面已经大概讲过了，这里要不要再重申一遍。",
      "speaker": "发言人3"
    },
    {
      "time": "01:29:00",
      "text": "为什么你们都记得那一期我讲了什么？我现在完全不记得自己那一期讲。",
      "speaker": "发言人1"
    },
    {
      "time": "01:29:04",
      "text": "我也录这节目，我还特地翻出来听了一遍，结果听到后面居然是程序员怎么找女朋友，这什么鬼？",
      "speaker": "发言人2"
    },
    {
      "time": "01:29:12",
      "text": "其实我我我也写了一篇很简单的一个博客，去去说这个大概记录了一下我当时学习这个坑的一个结果。",
      "speaker": "发言人3"
    },
    {
      "time": "01:29:21",
      "text": "这个编码方式那个UTF8，UTF16什么什么。但是你们详细的说一下。",
      "speaker": "发言人2"
    },
    {
      "time": "01:29:29",
      "text": "其实这个坑还蛮多的。这个我可以讲一下。对，就最开始的时候其实没有UTF16的，最开始的时候叫UCS2。对，没错，这个坑也是一个历史遗留问题。对，然后UCS2其实它只是编码了，刚才讲的那个叫做BMP，就是基本平面，一共有65536个点对吧？然后就很简单，就是没有任何额外的东西。然后UUCS2和UTF16的区别是什么呢？就是UTF16里面其实是等于UCS2，然后加了那个那个叫做sega pag .",
      "speaker": "发言人3"
    },
    {
      "time": "01:30:10",
      "text": "parent，中文叫什么有代理。对，我不对，我不是一直都不知道中文叫什么。",
      "speaker": "发言人2"
    },
    {
      "time": "01:30:19",
      "text": "叫或或者或者这么理解。UCS2可以大致等同于这个GB2312对于中文的概念。因为它就是一个定长的，没有任何特殊东西的，就只是那么多个点位而已。",
      "speaker": "发言人3"
    },
    {
      "time": "01:30:31",
      "text": "然后当时但是因为当时已经突破了那个基本平面了，对吧？就是要想要要要要想办法表达65536个这个点之外的东西怎么办？想出这么一个hack，就是说在那个基本平面里面抠出了一小段，大概是我看看这个是这个十六进制编码是D800到DFFM。这几个字符是用作cerp给pair是什么意思？等于是从两个字节的一个定长编码里面make up。就是刚才讲吴涛说做标记用一个对做了一个特殊标记，说从这些字符之间的东西，你要进行一个特殊处理，使得我们可以超出基本平面65536个字符的限制。这个是UTF16.",
      "speaker": "发言人3"
    },
    {
      "time": "01:31:22",
      "text": "他当时做出这个编码方案，其实还是为了省省资源，对吧？就是节省编码不就是对。",
      "speaker": "发言人2"
    },
    {
      "time": "01:31:30",
      "text": "是因为是这样，就是说如果当时有一个就刚才讲UCS2是一个非常简单的编码方式，其实对应的还有一个叫UCS4，对，就是四个字节32位的东西。然后UCS4本质上就是UTF32.",
      "speaker": "发言人3"
    },
    {
      "time": "01:31:45",
      "text": "它它是一个它它它是一个固定的算是，对，都是定长编码，然后就很浪费。就是你一个字母A的话也要用那个三格，就特别浪费。",
      "speaker": "发言人2"
    },
    {
      "time": "01:31:57",
      "text": "对，所以后来权衡一下，我们还是用内部还是用UTF16，用UCS2这个定场的比较好。但是要为了超要解决那个超出基本面的问题，所以加了这个sergi pair这种hack，使得UCSR变成了UTF16这么一个过程。",
      "speaker": "发言人3"
    },
    {
      "time": "01:32:16",
      "text": "就看那个标记，有了这个标记以后，我就要用另外一个了，对吧？",
      "speaker": "发言人2"
    },
    {
      "time": "01:32:22",
      "text": "就是你搜搜那个UCS2里面的那个server pay，那段是没有定义意义的。那用上这就人为规定说如果你看到有这种service pair的字符，就知道你这个是UCUTF16，所以这些3d pair里面东西你要特殊处理。反正也是一个很很大很大的坑。然后说到这个定场编码，就有可定场编码就会牵涉到一个所谓的顺序的问题。",
      "speaker": "发言人3"
    },
    {
      "time": "01:32:49",
      "text": "这又是一个更大的坑。",
      "speaker": "发言人2"
    },
    {
      "time": "01:32:52",
      "text": "在深坑。对。",
      "speaker": "发言人3"
    },
    {
      "time": "01:32:54",
      "text": "这其实是非单字节编码都要牵涉。",
      "speaker": "发言人4"
    },
    {
      "time": "01:32:57",
      "text": "对，非单字节编码都有这个很明显的问题。这个不光是在字符编码上，其实在计算机的这个数字的表达上也会有这个问题。比如说我们常说计算机一个字节就最小单位是就是八个位，对吧？但是两个字节就是你表示16位整数的时候，也会牵涉到哪个是高位哪个是低，就是哪边是高位哪边是低位的问题。对，然后就会所谓的我们就会切到那个叫做indian .",
      "speaker": "发言人3"
    },
    {
      "time": "01:33:25",
      "text": "in中文翻成什么端，就翻成端一般那个就是对我们一般管那个叫端式。",
      "speaker": "发言人4"
    },
    {
      "time": "01:33:33",
      "text": "大端和大伟和小伟这个是个专有名。",
      "speaker": "发言人3"
    },
    {
      "time": "01:33:36",
      "text": "我经常说大头小。",
      "speaker": "发言人2"
    },
    {
      "time": "01:33:39",
      "text": "对他其实表示的就是。",
      "speaker": "发言人4"
    },
    {
      "time": "01:33:41",
      "text": "大头派小头派，没错的。就原作是指这个，就在格列佛游记的原作里面。",
      "speaker": "发言人1"
    },
    {
      "time": "01:33:47",
      "text": "是指小人国在打内战的时候，说吃鸡蛋要从大头开始敲，还是从小偷开始敲，然后因此还发过六次叛乱。",
      "speaker": "发言人2"
    },
    {
      "time": "01:33:58",
      "text": "对对对，恩典就是从鸡蛋的两头那个地方来的。",
      "speaker": "发言人3"
    },
    {
      "time": "01:34:01",
      "text": "好像对他用了那个典故。",
      "speaker": "发言人4"
    },
    {
      "time": "01:34:04",
      "text": "对对对，然后这个坑就比较深了。简单来讲那头就是对于一个数字来讲，比如说对于一个16位的整数来讲，你觉得D就是从左到右数，左边是高位还是右边是高位，对吧？没错，我想想。",
      "speaker": "发言人3"
    },
    {
      "time": "01:34:21",
      "text": "对对对，就是大端式的话就是左边是高位，小端是右边是高位。",
      "speaker": "发言人4"
    },
    {
      "time": "01:34:28",
      "text": "对，但是在字符集的时候，这个坑就又多了，就会牵涉到。因为我想想怎么表述这个东西。",
      "speaker": "发言人3"
    },
    {
      "time": "01:34:36",
      "text": "首先你要看它的这个字节的组合是怎样分成一个单元的。然后它在每个单元的内部会有一个端式的这个对。",
      "speaker": "发言人4"
    },
    {
      "time": "01:34:46",
      "text": "因为有有这么这个问题可能要解释一下，就是说在数字上面我们写一般是说是从左往右写，对吧？我们正常的这个书写顺序，但是在把表达那个如果是位的话，如果你是小对大端小端就某一段的时候，它是最右边那个位开始起的。",
      "speaker": "发言人3"
    },
    {
      "time": "01:35:04",
      "text": "因为你想低位高位的话，就是个位数是在右边，然后越高位的话是越往左写，越往左边的是越高位。",
      "speaker": "发言人2"
    },
    {
      "time": "01:35:15",
      "text": "对，这个也是一个很深的一个坑，就经常我搞不清楚这里面到底是哪个原理。就是你你想如果把我们把那个位作为一个图形化的方式表达在眼前的话，你会发现它其实是从右边开始增加的。明白我的意思吗？就是比如说001，然后10，然后11100110这样的方式对吧？",
      "speaker": "发言人3"
    },
    {
      "time": "01:35:43",
      "text": "我就这样就说出来，好好，大家肯定晕了。Anyway.",
      "speaker": "发言人2"
    },
    {
      "time": "01:35:48",
      "text": "对得得得在脑中把脑中画一下。对。",
      "speaker": "发言人3"
    },
    {
      "time": "01:35:51",
      "text": "对，其实我们只需要认可这个世界上事实上存在了这样两种顺序。这两种顺序实际上是由计算机这个体的硬件架构所决定的。一派架构它就是以这个小端式来保存它的数据，而另一端另一种架构就是以大端式来保存它的数据。",
      "speaker": "发言人4"
    },
    {
      "time": "01:36:09",
      "text": "对然后这个在我们常用的计算机里面，英特尔架构就是我想这是X86，它是一个小端设计的。",
      "speaker": "发言人3"
    },
    {
      "time": "01:36:17",
      "text": "对。",
      "speaker": "发言人1"
    },
    {
      "time": "01:36:18",
      "text": "但是在互联网上，我们所基本上所有的这个通讯协议以及这个网络标准，全部都是以大端来设计的。",
      "speaker": "发言人3"
    },
    {
      "time": "01:36:26",
      "text": "所以坑就从这里开始了。",
      "speaker": "发言人2"
    },
    {
      "time": "01:36:29",
      "text": "没错。",
      "speaker": "发言人3"
    },
    {
      "time": "01:36:30",
      "text": "这是不是跟早期的服务器用的那个架构有关。",
      "speaker": "发言人4"
    },
    {
      "time": "01:36:33",
      "text": "因为早期的做互联网的那些服务器都不是英特尔的处理器，都是一些其他那些现在已经销声匿迹的那些处理。",
      "speaker": "发言人3"
    },
    {
      "time": "01:36:42",
      "text": "都基于unix的。",
      "speaker": "发言人4"
    },
    {
      "time": "01:36:43",
      "text": "其实是吧啊不，那个是操作系统的，那个还没有，就跟那个没有，这个是一个硬件，就很低层的。然后就对早期的那些很多做互联网的服务器，还有包括那些开发，最开始做什么upper那的，现在用的机器，他们其实很多都是大端的，就是big ending的。所以就他们的用的那些机器变成了一个正统。然后反而现在我们做小端的英特尔的处理器，到时候就为什么你写C程序的时候，还要有一个什么，host h two NIHH two LH to l和l to h就是转换网络的端和本地的这个post to .",
      "speaker": "发言人3"
    },
    {
      "time": "01:37:20",
      "text": "local是吧？",
      "speaker": "发言人2"
    },
    {
      "time": "01:37:22",
      "text": "对对对，那个小端序是wax和英特尔的架构，大端序是摩托罗拉和sun的那个架构。",
      "speaker": "发言人4"
    },
    {
      "time": "01:37:30",
      "text": "没错，就是什么Spark那些东西。Anyway说回这个，就在这个字体，这个UTF8编码，UTF16和UTF32编码也有这个同样的问题。就是说第一个字节到底代表是小头还是大头。",
      "speaker": "发言人3"
    },
    {
      "time": "01:37:45",
      "text": "所以他要做标注，对吧？",
      "speaker": "发言人2"
    },
    {
      "time": "01:37:48",
      "text": "对，所以为了就是他们就没有说我们大家都规定一律是通用。像比如像网络上大家都规定说，因为在所有的这个RFPC的规范里面，只要涉及网络的都是用的那个大端设计。但是在文本上面其实并没有这么一个统一，就是约定俗成的一个规定。所以就两种都存在，所以说存在说叫做UTF16，就是L一和UTF16，BE大BBE对，就两种不同的表达方这个存储方式。所以你们看到很多windows上面的那个那个文本编辑器，把text I保存的时候，它会对对对，记事本儿对它会给你这个选项。然后因为存在这个B一和L一的区这个问题，就是很多人就为了解为了标志说这个文本到底是大端还是小端的。我们有一个规定，就是说用UTF16编码的文本会在它的第一个字符，应该是把前两个字符会放个放了放一个特殊的标志，叫做bone bite order mark.",
      "speaker": "发言人3"
    },
    {
      "time": "01:38:56",
      "text": "那叫什么自序？字节序列标志的标志，我这个序列是大是大头还是小头？",
      "speaker": "发言人2"
    },
    {
      "time": "01:39:06",
      "text": "对对对，然后这个boom其实是一个两个字节的特殊性特特殊位。",
      "speaker": "发言人3"
    },
    {
      "time": "01:39:11",
      "text": "它是很取巧了，因为它其实是unicode的那个FEFF这个字，但是这个字叫zero with no break space。就是林宽的一个不间断的空不可分割的空白。所以对你表面你看不出来有这个字。",
      "speaker": "发言人2"
    },
    {
      "time": "01:39:33",
      "text": "这是一个非常这是一个很容易把人坑死了。坑就是因为你看不到这个字。对你必须用一个能够看见看不到的东西的编辑器来看。",
      "speaker": "发言人1"
    },
    {
      "time": "01:39:42",
      "text": "才能看到这个东西。当时想出这个招的人也应该拖出去看。",
      "speaker": "发言人3"
    },
    {
      "time": "01:39:47",
      "text": "对的，但是他当时就是因为这个字看不见，所以才能用来做这个hack。",
      "speaker": "发言人2"
    },
    {
      "time": "01:39:53",
      "text": "对他当时觉得自己这个还得还挺挺技巧的对对。",
      "speaker": "发言人3"
    },
    {
      "time": "01:39:58",
      "text": "但是现在的这个的规范，它已经不推荐你再把这个bomb当成这个林宽的空格来用了，它只推荐你用来标记这个字节。",
      "speaker": "发言人4"
    },
    {
      "time": "01:40:08",
      "text": "是对不？现在不是应该用UTF，为什么还有人推荐UTF16？",
      "speaker": "发言人3"
    },
    {
      "time": "01:40:14",
      "text": "就是对于unico的它这个规范书来说，他认为这个字节式的标记即使是对于UTF8的编码也有一定的作用。因为他能明确的告诉你这个文本处理的软件，你这个就是用unicode的编码。",
      "speaker": "发言人4"
    },
    {
      "time": "01:40:29",
      "text": "好吧。",
      "speaker": "发言人2"
    },
    {
      "time": "01:40:30",
      "text": "不需要UTF8，不需要这个东西。",
      "speaker": "发言人3"
    },
    {
      "time": "01:40:34",
      "text": "怎么说呢？就是unicode它是这样号称的，就是说即使你用UTF8这样没有端式的编码方式来编，那么我如果看到了这个BOM的这个标记位的话，那么我可以提前就知道这些文本一定是用unna ode的某一种编码方案来编码，你就不用去考虑别的编码了。",
      "speaker": "发言人4"
    },
    {
      "time": "01:40:56",
      "text": "对，就是说那那这里就会会不会涉及一个问题，就是说在其他所有编码方案里面都没有出现过boom这个东西是吧？",
      "speaker": "发言人3"
    },
    {
      "time": "01:41:04",
      "text": "就不会在开头，如果或者说他做了一个约定，一旦在开头出现这个标记位的时候，我就认为他是那个unique编码的一个。",
      "speaker": "发言人4"
    },
    {
      "time": "01:41:12",
      "text": "他能做出这个约定，那肯定是说统计过市面上所有存现存用过的这个编码方案。不管是日本的、韩国的还是其他欧洲的也好，它的都不会出现这么一个组合。",
      "speaker": "发言人3"
    },
    {
      "time": "01:41:24",
      "text": "就是这个FEFF10位。对，那应该是因为这个字符本身作为一个非标记字符来用，它就是一个很罕见的。它是一个零宽的这样一个空格，如果你正确的使用这个空格的话，它是不会出现在一个字符串的开头的。因为它的语义决定了它一定是出现在一些字符串。",
      "speaker": "发言人4"
    },
    {
      "time": "01:41:48",
      "text": "的中间的。OK make sense anyway. 无论如何，怎么说，这还是一个bad idea。它的存在就是一个bad idea。",
      "speaker": "发言人3"
    },
    {
      "time": "01:41:57",
      "text": "所以那个windows记事本的，你在保存这个文件的时候，它有个选项叫unicode然后又有一个选项叫unique big india。然后如果大家会想什么鬼，因为它是第一个选项，unique它就是默认的说这个就是UTF的16，而且是默认是小头的。所以他还会有另外一个选项是unique的big ending，这个用大头来保存。",
      "speaker": "发言人2"
    },
    {
      "time": "01:42:23",
      "text": "所以这也是一个坑，对不对？因为你选uniq unique并不是一个编码。",
      "speaker": "发言人3"
    },
    {
      "time": "01:42:27",
      "text": "对，而且它有第三个选项是UTF8。这其实也是如果你要这样讲，这是unicode的一种编码方式而已。",
      "speaker": "发言人2"
    },
    {
      "time": "01:42:34",
      "text": "就是他把两个完全不在一个逻辑层面的概念全部放在一堆，然后揉成了一堆。是对他。",
      "speaker": "发言人3"
    },
    {
      "time": "01:42:40",
      "text": "这个菜单显示的很奇怪，就是他不应该这样表述。",
      "speaker": "发言人2"
    },
    {
      "time": "01:42:45",
      "text": "对，他的这个术语比较乱了。",
      "speaker": "发言人4"
    },
    {
      "time": "01:42:47",
      "text": "所以把什么做记事本的产品经理拖出去砍了。",
      "speaker": "发言人3"
    },
    {
      "time": "01:42:51",
      "text": "你今天要砍多少人呢？",
      "speaker": "发言人2"
    },
    {
      "time": "01:42:55",
      "text": "就不合逻辑的统统砍死了。",
      "speaker": "发言人3"
    },
    {
      "time": "01:42:59",
      "text": "所以windows记事本它它保存了以后，它这个bom大家都会有是吧？写标记了以后。",
      "speaker": "发言人2"
    },
    {
      "time": "01:43:07",
      "text": "不会只会用就在一个正常符合逻辑的编辑器里面，它应该只会用UTF16或者UTF3。等于UTF3好像是规定的N点顺序。",
      "speaker": "发言人3"
    },
    {
      "time": "01:43:19",
      "text": "它也有两种顺序可以用的，就是说16和32的时候，所以这就是为什么windows它会在那个unicode上面加一个带不带BE这个标记。",
      "speaker": "发言人4"
    },
    {
      "time": "01:43:32",
      "text": "的区分了不但是它里面不能选UTF32对。",
      "speaker": "发言人3"
    },
    {
      "time": "01:43:36",
      "text": "它的产品逻辑是说，当我标明了这个bomb的时候，它有可能是用UTF16编码，也有可能是用32编码了。所以他就用unicode的来指代这两种。然后同时，他认为UTF8是不需要这个的，所以他说UTF8的时候，只用一个标准的编码方案来指代他现在的这个文件状态。",
      "speaker": "发言人4"
    },
    {
      "time": "01:43:59",
      "text": "气死死。Anyway我们最终得出结论就是千万不要用windows记事本。如果你也要用T务必记得用UTF8编码。或者说从今天开始，所有的涉及跟文字相关的，跟编程相关的，任何是有文本的东西，一定要用UTF8来编，就可就来存就可以了，其他的都是斜角。",
      "speaker": "发言人3"
    },
    {
      "time": "01:44:23",
      "text": "Windows记事本会在UTF8的编码文件里面还会加加一串字儿，加一个字节串。",
      "speaker": "发言人2"
    },
    {
      "time": "01:44:29",
      "text": "所以这次要他。",
      "speaker": "发言人3"
    },
    {
      "time": "01:44:31",
      "text": "为什么还要画蛇添足呢？",
      "speaker": "发言人2"
    },
    {
      "time": "01:44:33",
      "text": "就刚才你说那个问题。",
      "speaker": "发言人3"
    },
    {
      "time": "01:44:35",
      "text": "虽然是UTF8.",
      "speaker": "发言人2"
    },
    {
      "time": "01:44:37",
      "text": "但是他又加了一个这东西，他还是想加一个这个东西。他觉得保险让。",
      "speaker": "发言人3"
    },
    {
      "time": "01:44:42",
      "text": "人家知道，这我这肯定是有你扣是吧。",
      "speaker": "发言人2"
    },
    {
      "time": "01:44:45",
      "text": "对吧？拖出去砍了是很正常的处理方式，好吧。",
      "speaker": "发言人3"
    },
    {
      "time": "01:44:53",
      "text": "好，windows的那个坑终于踩过了。现在我们来讲这个UTF8还没讲，UTF8需要讲吗？约定方其实挺挺好解释的，可以讲，那就说他来吧，我好累。",
      "speaker": "发言人3"
    },
    {
      "time": "01:45:05",
      "text": "我说。为什么在这个时候。",
      "speaker": "发言人1"
    },
    {
      "time": "01:45:10",
      "text": "就要把锅甩给我？因为我把该砍的人都砍掉了，剩下都是跟你讲这个很很完美的世界了。",
      "speaker": "发言人3"
    },
    {
      "time": "01:45:18",
      "text": "天好吧。UCUCF8是一个目前看来比较完美的编码方案。",
      "speaker": "发言人1"
    },
    {
      "time": "01:45:23",
      "text": "the holy grail of encoding.",
      "speaker": "发言人3"
    },
    {
      "time": "01:45:27",
      "text": "可以这么说，虽然它还是带有一些美国中心主义的色彩，但是基本上已经在占地和效率方面达到一个均衡。OTUTF8虽然叫UTF8，但是它是一种所谓的variable lengths，就是可变长度的字符编码，就是说一个字或者说一个符号。比如说我们常常见的这些AO宅之类的，有可能用一个字符一个bite就是八个bit，或者最多可以用到6个。目前是六个，六个bite以前是四个，现在是六个。最多可以用到6个字节，就是六八四十八个bit来代表一个符号。然后其中最原始的那128个SK的字符，这些就和SK一模一样，就是只需要一个字节，也就是说一个UTF8的文件，如果它只用那个SK字符来写的话，它和阿斯克编码的那个文件是一模一样。然后带有附加符号的。什么就比如说德语的语，然后什么阿拉伯语，俄罗斯用那个叫什么希利尔字母之类的，就从这些字母开始就全都需要两个字节编码，然后中文则需要3到4个字节，基本上大部分中文都是需要33到3到4个字。对，然后就是在尤其是在unicode里面，所谓叫什么BMP。BMP的全称。",
      "speaker": "发言人1"
    },
    {
      "time": "01:47:12",
      "text": "是什么multilingual .",
      "speaker": "发言人4"
    },
    {
      "time": "01:47:15",
      "text": "an基本多语言平面的那个plan。就这个位面里面基本上全都在三个字节里面。所以汉字在和和用它来编的话，基本上全都是三个字节的编码。也就是说如果你用unix 8来编一个之前是用GB2312编的文件的话，它的尺寸可能会扩大50%。这可能是它的唯一的对对于中文使用者来说，但是它唯一一个比较不好的地方。",
      "speaker": "发言人1"
    },
    {
      "time": "01:47:50",
      "text": "但其实这个问题在现代都是用压缩技术的情况下，完全没有任何区别。",
      "speaker": "发言人3"
    },
    {
      "time": "01:47:57",
      "text": "对，就是耗费的这些多余的空间，其基本上只在网络传输和磁盘比较昂贵的时代，有有是一个比较大的招牌。但是在目前带宽这样的话，就大部分时候即便不压缩，都都还好。",
      "speaker": "发言人1"
    },
    {
      "time": "01:48:14",
      "text": "都还OK了。对你你看一些文本能值多少个，你随便下个图不就没了。是对。",
      "speaker": "发言人3"
    },
    {
      "time": "01:48:22",
      "text": "然后因为TF8最开始好像是在2000年左右开始定义了，所以其应用也基本上就是2000年之后出的操作系统，才开始比较大规模使用的。",
      "speaker": "发言人1"
    },
    {
      "time": "01:48:36",
      "text": "应该不是UTF8.",
      "speaker": "发言人3"
    },
    {
      "time": "01:48:39",
      "text": "很早就有了不UTF8在这怎么说？有一个官方的定义文件应该是在2000年，就是他第一版的那个或者说最新修订版本应该是在2000年。然后它最开始的起源可能是在96年，反正早在93年就好吧。93年它其实不是一个特别老就特别古老的编码，或者说它是一个相对来说比较新的编码用方式。然后目前来讲应用还不是特别的广泛，但是我们所希望达到理想国的状态，就是全世界就只用UTF8这样一种编码。刚才说了windows内部是不是用UTF8的对吧？是用那个没有系统内部。",
      "speaker": "发言人1"
    },
    {
      "time": "01:49:26",
      "text": "会用UTF8的。因为它是变长的，变长是很不利于处理的。",
      "speaker": "发言人3"
    },
    {
      "time": "01:49:31",
      "text": "对，所以其实UTF8它的最大优势是在于不同的，就是什么跨平台的或者说可交换的这样一个场景。",
      "speaker": "发言人4"
    },
    {
      "time": "01:49:40",
      "text": "我们说到UT8F8或者UTF16的时候，其实在现实中强调的。",
      "speaker": "发言人3"
    },
    {
      "time": "01:49:45",
      "text": "都是兼容性。",
      "speaker": "发言人1"
    },
    {
      "time": "01:49:47",
      "text": "都是在它存到磁盘上就是序列化之后的一个结果了。",
      "speaker": "发言人3"
    },
    {
      "time": "01:49:54",
      "text": "互联网工程工作小组要求所有的互联网协议都必须支持。",
      "speaker": "发言人2"
    },
    {
      "time": "01:49:58",
      "text": "有就为一的这个全球认可的一个标准。",
      "speaker": "发言人3"
    },
    {
      "time": "01:50:04",
      "text": "然后互联网邮件联盟是建议所有的电子邮件的软件都支持这个邮件。F8是对邮件的话还是很复杂。",
      "speaker": "发言人2"
    },
    {
      "time": "01:50:15",
      "text": "对对对，然后UF8的编码方式其实也比较好理解。因为巴比特的那个第一个位如果是零的话，那它肯定是阿斯I的那个编码了。然后如果你怎么辨认说接下来两个比特是一个双比特的有点发的字符，就是看第一个比第一个bit的。",
      "speaker": "发言人1"
    },
    {
      "time": "01:50:34",
      "text": "Sorry, 我刚才应该说字节，就如果你怎么你怎样才能认识辨认出接下来两个字节是一个双字节的UTF8的编码就是要看第一个字节的前两位如果是一，然后第三位是零的话，那就这意味着这是一个双字节的UTF码。如果有三个一，然后一个零的话，那也就意味着它是一个三字节的UF码。然后除了第一位之外，其他的后面的几个字节，每个字节的前两位都是10。对，然后这样到如果你用如果你有六个字节来表示一个码位的话，它就是1116个1，然后接一个零。对，然后就可以把接下来的剩下的五个byte也都以10开头跟在它后面来代表一个字。差不多就这样吧。",
      "speaker": "发言人1"
    },
    {
      "time": "01:51:31",
      "text": "还有什么要介绍，所以就是撑死UTF86个字节为一个东西，为一个扣子。对，OK这个倒不一定。",
      "speaker": "发言人3"
    },
    {
      "time": "01:51:42",
      "text": "他的这个倒不一定就不能。",
      "speaker": "发言人4"
    },
    {
      "time": "01:51:45",
      "text": "再扩了吗？",
      "speaker": "发言人3"
    },
    {
      "time": "01:51:46",
      "text": "What就是说你可能不能用这一套。",
      "speaker": "发言人4"
    },
    {
      "time": "01:51:49",
      "text": "第一位完全是七个一个零是吧？",
      "speaker": "发言人1"
    },
    {
      "time": "01:51:52",
      "text": "就是说你不你可能不能在这种方式上继续扩展它的这个字符的这个亮了，但是你还用一些别的方式，比如你可以通过中间串一个什么特殊的字符来告诉他他他。",
      "speaker": "发言人4"
    },
    {
      "time": "01:52:07",
      "text": "这样设计是有有目的的。就是说这个设计它最后有一个很重要的特性，要解释一下，不然的话就很容易乱换掉。就是说因为变变长和，就是为什么刚才讲那个操作系统内部执行的时候都一定是用定长的。定长它是如果做那个叫什么跳转，计算offset，就是那个位移的话，它很简单的对，可以乘以整数就可以，没错，但是变长的话就不具备这个问题了。",
      "speaker": "发言人3"
    },
    {
      "time": "01:52:32",
      "text": "变长的话要避免的一个很大的问题就是说在一个相当长的文本里面，假设部分字符出现问题，可能是因为磁盘存储的介质的损坏，或者是网络传输的问题，导致中间部分那个字节发生变化的时候，我们能够很快的辨认出来那部分哪部分是坏的。并且在那个坏的那个字节或者那几个字节之后，立即重新的找回你的那个起点。就是你怎么因为变成你不知道接下来的那个那个字符的起点在哪里吗？",
      "speaker": "发言人3"
    },
    {
      "time": "01:53:04",
      "text": "就中间这一个码坏掉后。",
      "speaker": "发言人2"
    },
    {
      "time": "01:53:06",
      "text": "的这个是一个很危险的，就是很很不健壮的一种设计。所以但是UTF8这种设计，它可以导致说它就你能够很快的叫做self synchronizing，就是可以自己同步。因为你只用看每一个字节，因为你资源搜索就是每个字节的这样去跳。你只要看每个字的前两位，你就能够知道它这个是不是某一个一个字字就character的起点。因为如果它是一零开头的话，或者是零几开头的话，它肯定不是，它肯定肯定对它是第一位是零的话，它肯定是一个单一字节，它就是一个字符的起点对吧？然后如果它是一零开头的话，它肯定不是，它是前面一个字符的一部分。对，所以他可以跳过去，就可以直接skip，直到你又发现一个第一位是零，或者是一一这种开头的，就是根据那个前缀那个表。所以这个是一个很重要的特性。如果说一旦这个结构被破坏的话，这UTF8的健壮性就不复存在了。",
      "speaker": "发言人3"
    },
    {
      "time": "01:54:07",
      "text": "对，在编码方案的这个层面确实是这样的。我刚刚想说的意思就是说，其实我们可能不必担心用UTF8这种编码方案会导致有一天说我们想用的字符数不够用。对他其实很可以添加别的方案进去，将这个范围扩得更广。",
      "speaker": "发言人4"
    },
    {
      "time": "01:54:26",
      "text": "对，反正其实起码到目前为止，六个字节的这种非标的也已经就足够用了。对，希望我们不要再往这个unicode垃圾堆里面再塞东西了。",
      "speaker": "发言人3"
    },
    {
      "time": "01:54:38",
      "text": "可是尤妮蔻这个垃圾堆还一直都在。",
      "speaker": "发言人2"
    },
    {
      "time": "01:54:40",
      "text": "对，而且他现在有一个非常重大的缺口理论上可以无限C就是M的这个缺口。",
      "speaker": "发言人4"
    },
    {
      "time": "01:54:49",
      "text": "表情文字那个那个坑我们是这次讲还是下次讲。",
      "speaker": "发言人3"
    },
    {
      "time": "01:54:53",
      "text": "我们可以专门找一些专门来讲。",
      "speaker": "发言人4"
    },
    {
      "time": "01:54:56",
      "text": "另外可以专门找一些来讲各种各样有趣的一个坑。就是说以及有一些根本就不知道为什么要放在那儿的，有没有这个车？因为这里面有一个一个悬浮在半空中的男人，对吧？这个是到底。",
      "speaker": "发言人1"
    },
    {
      "time": "01:55:10",
      "text": "有什么意义？但就说这个是一个象形文字始终是要解决的问题。",
      "speaker": "发言人3"
    },
    {
      "time": "01:55:20",
      "text": "它是是不是一个封闭的集合？",
      "speaker": "发言人2"
    },
    {
      "time": "01:55:22",
      "text": "对对对，你你你很就很麻烦，你说不清楚。比如说你刚才你吴涛问那个问题，一个漂浮在半空中的男人表达了这么一个象形文字。一墨展他和我们考古挖出一个故事，这里面写了一个通假字，有什么区别？",
      "speaker": "发言人3"
    },
    {
      "time": "01:55:35",
      "text": "通假字至少有意义。",
      "speaker": "发言人1"
    },
    {
      "time": "01:55:37",
      "text": "你把他写错了吗？为什么他他写错了就有意义？我们要表达现代人要表达一个东西就没有意义。我觉得这种就是你。",
      "speaker": "发言人3"
    },
    {
      "time": "01:55:45",
      "text": "这是个政治问题。",
      "speaker": "发言人4"
    },
    {
      "time": "01:55:47",
      "text": "对你去考察的这个通假字。",
      "speaker": "发言人3"
    },
    {
      "time": "01:55:49",
      "text": "你至少知道它有意义。但是这个就至少你可以推测出来它代表的意义是什么。可是这个悬浮在空中中的男人这个意义是什么？都很多人不知道。",
      "speaker": "发言人1"
    },
    {
      "time": "01:56:00",
      "text": "的这我也不知道，你们要解释一下。",
      "speaker": "发言人2"
    },
    {
      "time": "01:56:03",
      "text": "不是这个意义。这个符号最开始是出现在微软的vaporings里面，然后是一个马位多少？我稍稍等我找一找。",
      "speaker": "发言人1"
    },
    {
      "time": "01:56:20",
      "text": "你怎么搜悬浮在半空中的男人吗？",
      "speaker": "发言人3"
    },
    {
      "time": "01:56:23",
      "text": "Navia man image man in business suit elevating就搜搜这个U1加5 1加U.",
      "speaker": "发言人1"
    },
    {
      "time": "01:56:35",
      "text": "加1F574伏在地面上的西装男。",
      "speaker": "发言人4"
    },
    {
      "time": "01:56:40",
      "text": "对，这是什么鬼？这个一波是最开始是出现在web ding里面，然后它的意义是一个感叹号，这个感叹号的风格就像一个rude boy logo，然后是在是一个叫做the specials的乐队所出出的一张照片里面。",
      "speaker": "发言人1"
    },
    {
      "time": "01:57:03",
      "text": "是念一模甲，还是一毛几？",
      "speaker": "发言人3"
    },
    {
      "time": "01:57:05",
      "text": "一毛几。",
      "speaker": "发言人4"
    },
    {
      "time": "01:57:07",
      "text": "你要是按日文念读音的话，就是image MG对。",
      "speaker": "发言人1"
    },
    {
      "time": "01:57:11",
      "text": "emerge OK这么说他确实有点像一个感叹号，因为他的那个人悬浮在空中，地下有个投影，正好是感叹号的那一点。",
      "speaker": "发言人4"
    },
    {
      "time": "01:57:26",
      "text": "好吧，这什么鬼？",
      "speaker": "发言人2"
    },
    {
      "time": "01:57:28",
      "text": "对，这个玩意儿在unicode 1.7.0的时候进入了unicode.",
      "speaker": "发言人1"
    },
    {
      "time": "01:57:33",
      "text": "所以吴涛在这个image这个争论里面是持保守派的。",
      "speaker": "发言人3"
    },
    {
      "time": "01:57:39",
      "text": "什么叫保守派？左派和右派的区别是什么？",
      "speaker": "发言人1"
    },
    {
      "time": "01:57:42",
      "text": "右派是应该就是unicode的那个工作组里面，就是说我们不要加这么多乱七八糟的东西进来了。",
      "speaker": "发言人3"
    },
    {
      "time": "01:57:48",
      "text": "对，这个是我觉得界限是很难界定的。你怎么区分什么叫乱七八糟？",
      "speaker": "发言人1"
    },
    {
      "time": "01:57:53",
      "text": "就是我就觉得这个就是像文字不封闭的导致的一个必然结果。",
      "speaker": "发言人3"
    },
    {
      "time": "01:57:58",
      "text": "对它主要就是它不是一个封闭的集合，退一步万步。",
      "speaker": "发言人2"
    },
    {
      "time": "01:58:02",
      "text": "那就是你这个边界随时都在扩的，就很麻烦。对，所以这个东西是一个深坑，没有办法。如果说这个unicode里面那帮人觉得不应该加image进来的话，那也不要从估值堆里面找那个生僻字进来了，是一个原理。",
      "speaker": "发言人3"
    },
    {
      "time": "01:58:18",
      "text": "对，事实上将这个MG当成一种字符，这个观念本身就是一个比较激进的观念，它本身不是一种文字。",
      "speaker": "发言人4"
    },
    {
      "time": "01:58:28",
      "text": "但是从技术上的实现来讲的话，倒是OK的。因为你从font的技术上实现来讲，我就是一个码，然后显示一个gliff，believe其实就是一个图案，对吧？从技术显示来讲，这是很正常的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:58:43",
      "text": "它是一个典型由技术来推动标准，就由技术实作来推动这个标准改变的这样一个问题了。",
      "speaker": "发言人4"
    },
    {
      "time": "01:58:51",
      "text": "好吧？穆姐咱们还是下次再说。",
      "speaker": "发言人2"
    },
    {
      "time": "01:58:53",
      "text": "对对对，没错。而且我觉得他推出来一个扩展，就是一个三维的符号应不应该算作一个emerge？",
      "speaker": "发言人1"
    },
    {
      "time": "01:59:06",
      "text": "一个三维的符号是什么意思？",
      "speaker": "发言人4"
    },
    {
      "time": "01:59:08",
      "text": "就是同样一个有一个平面的脸和一个立体的脸上算一个符号吗？这就刚才我们说的那个户的三种写法，它算一个还是算三个呢？",
      "speaker": "发言人3"
    },
    {
      "time": "01:59:21",
      "text": "对，没错，对。",
      "speaker": "发言人1"
    },
    {
      "time": "01:59:23",
      "text": "就很难去划分这个东西。所以我觉得不把那个到底是表音表意还是表型这个东西定下来，这个东西永远都是有争议的。好好吧，那那要不杀个车，然后我们下次接着讲O.",
      "speaker": "发言人3"
    },
    {
      "time": "01:59:37",
      "text": "K所以我们今天究竟有没有讲到乱码这件事情。",
      "speaker": "发言人4"
    },
    {
      "time": "01:59:41",
      "text": "我大概还是讲了，大概还是讲到了。对嗯嗯嗯。",
      "speaker": "发言人3"
    },
    {
      "time": "01:59:45",
      "text": "就是说我们讲到了一些编码的基本的原理，然后梳理了一下这个字符集规范的发展的历史。在这两个环节中，如果有一个环节出错了，其实首先就会导致乱码。然后最后我们还讲了这个字节端序的问题，它也是导致乱码的一个实践中经常遇到的因素的。",
      "speaker": "发言人4"
    },
    {
      "time": "02:00:12",
      "text": "其实大家要珍惜每天你在网页上看出来的这些字符。因为他突破千千万险，被正确的编译出来，编码编出来，然后传输过来，然后显示在你的一些浏览器里面。对它已经经过了各层的处理。",
      "speaker": "发言人2"
    },
    {
      "time": "02:00:29",
      "text": "不过实际上我们应该知道，就是说像HTML它的这个解析规则里，它的这个健壮性还是比较强的。它应该能容一定的编码错误，对吧？",
      "speaker": "发言人4"
    },
    {
      "time": "02:00:42",
      "text": "是的，那当然了，要不然的话你想在这传输过程中又是掉包又是乱，又顺序又会乱的对吧？",
      "speaker": "发言人2"
    },
    {
      "time": "02:00:50",
      "text": "各种各，我指的是就是比如说我这个浏览器把它误认成另一种与它不符合的编码，其实在不少情况下，就因为大家都对的金融比较好，那么HTML用到一些关键的标记符号都是SK里面，所以他其实还是可以正确的渲染一部分的。",
      "speaker": "发言人4"
    },
    {
      "time": "02:01:12",
      "text": "至少他那个mark是对的。好吧，那今天时间有限，那就暂时先杀到这边，我们下次再接着讲。感谢大家的收听，大家可以从各种社交网络上关注我们。自弹自唱在新浪微博、微信公众号以及twitter的账号的名字都是the type THETYPE。在facebook上面可以通过type is beautiful找到我们。也欢迎大家用邮件的方式来给我们一些反馈。我们的邮箱是podcast at the type点com，podcast拼写是PODCST，the type的拼写是THETYPE podcast at the type点com。欢迎大家给我们捐款，让我们努力把做成最好的全球最好的字体播客。",
      "speaker": "发言人2"
    },
    {
      "time": "02:02:04",
      "text": "感谢收听IPN pod卡网络旗下的IT技术主题娱乐节目内核恐慌。我们号称哈利core，但是也没有干货，想听就听，不想听你就别听。你可以为本节目捐款，地址是kino panic doctor family flash donate。捐款金额随意，只要是八的正整数倍就可以捐款不会给你带什么，不捐也不会让你失去什么。我们的口号是no hot feelings。如果你有任何反馈，可以发邮件到kernel panic at IPN dot LI。同时也欢迎你收听real主持的风投圈以及ITN旗下的其他几档节目。未知道太一来的流行通信，high story映影像，吴思源博物志选美陛下关一天世界时尚怪物。我们下期节目再会，拜拜。",
      "speaker": "发言人1"
    }
  ],
  "lab_info": {
    "summary": "本期播客由四位主播共同参与，深入探讨了字符编码在多语言文本处理中的应用和挑战。讨论着重于Unicode、UTF8和UTF16等编码方案，指出Unicode的建立初衷是为了统一解决全球不同语言和字符集的兼容问题，而UTF8因其高兼容性和跨平台特性，成为当前理想的编码选择。对话还涉及了字符集的端序问题，强调正确选择和应用编码方案的重要性，以及通过技术手段如Unicode Normalization解决乱码问题的方法。此外，播客还回顾了节目历史，讨论了繁简汉字的转换问题，并分析了GB2312、GBK、GB18030等字符集和编码标准的应用。主播们分享了对技术与语言文化的见解，以及对下一代技术发展的期待，内容既专业又深入浅出，为听众提供了丰富的知识和视角。",
    "qa_pairs": [
      {
        "question": "在第一期自弹自唱节目中，有听众反馈纠正了“曲线”的读音，能具体说一下吗？",
        "answer": "是的，有位叫虎虎萨（普萨）的听众给我们发邮件纠正了“曲线”的读音。他指出我们在节目中把“曲线”的“曲”念错了，应该念成“九曲十八弯”的“曲”，而并非“歌曲”的“曲”。",
        "time": "00:02:07"
      },
      {
        "question": "“曲”这个字原本是指什么？后来为什么会有多种含义？",
        "answer": "“曲”字本意是指弯曲，是从“九曲十八弯”这个词汇中的“曲”字来的，表示拐弯的意思。后来由于语言的发展和词义的引申，“曲”字逐渐有了更多含义，比如形容词和名词等。",
        "time": "00:03:27"
      },
      {
        "question": "中文里对于手机和掌机的区别如何理解？",
        "answer": "手机是指手持的一台设备，用于打电话；而掌机是一种游戏机，主要是在手上玩的游戏设备。虽然现在两者都可能被简称为“手机”，但在早期，“手机”和“掌上游戏机”是两个不同的概念，只是现在它们的界限变得模糊。",
        "time": "00:05:32"
      },
      {
        "question": "对于九宫格键盘（turkey），它与输入法之间有何关联？",
        "answer": "九宫格键盘相当于含了一层输入法，如果不仅仅输入数字，而是包含英文字符，那么每个按键对应多个字母，用户可以通过按压按键来输入不同的字母组合，实现便捷的文本输入。",
        "time": "00:09:20"
      },
      {
        "question": "对于英文中的“key code”（键码）概念，在触屏手机上是否存在类似的概念？",
        "answer": "在触屏手机上，通常没有明确的“key code”概念，因为触屏输入法主要依赖于触摸操作而非物理键盘。但在早期模拟信号的电话机上，确实存在类似键码的概念，通过声音长短来区分不同的按键。",
        "time": "00:08:55"
      },
      {
        "question": "是否所有国家拨打电话时都会像中国一样，先念区号再念座机号？",
        "answer": "不同国家拨打电话的习惯有所不同，例如法国和德国在拨打电话时，区号通常会放在座机号码之前，而在中国则是相反。不过，随着国际长途拨号规则的变化，许多国家都在逐渐统一拨号方式。",
        "time": "00:11:12"
      },
      {
        "question": "在拨打中国深圳的电话时，外国朋友是否会拨008686，然后在后面跟着区号？",
        "answer": "是的，从外国打到深圳时，通常会拨008686作为中国的国际长途代码，接着再拨区号755，其中0086是可选的，而755则是特定于深圳的区号。",
        "time": "00:15:13"
      },
      {
        "question": "每个国家打电话到外国时，是否都可以省略零（0）？",
        "answer": "大多数情况下，像中国这样的国家，区号前的零是可以省略的，但意大利是个例外，因为他们的号码本身就有零开头，所以零不能省略。",
        "time": "00:15:48"
      },
      {
        "question": "电话号码中的零是否可选以及能否省略，是否遵循某种国际标准？",
        "answer": "是的，国际电信联盟（ITU）制定的通信相关国际标准中，对于电话号码的注记格式包括零是否放在括号内等细节都有明确规定，这与各国电话制式密切相关。",
        "time": "00:16:14"
      },
      {
        "question": "反斜杠在tag中的作用是什么？",
        "answer": "反斜杠在tag中作为转义符使用，以反斜杠开头的一个标志符，后面可以跟随花括号或方括号内的参数。",
        "time": "00:19:06"
      },
      {
        "question": "中文里如何表示“或者A或者B”这样的选项？",
        "answer": "中文里可以用斜杠来表示选项，例如“A或者B”，但在现实生活中混用左斜杠和右斜杠的情况较为少见，且可能造成阅读上的困扰。",
        "time": "00:20:01"
      },
      {
        "question": "阿拉伯文等右向左书写系统的文字如何处理引号和括号？",
        "answer": "阿拉伯文等右向左文字中，逗号、问号等符号往往采用镜面对称，引号也可能是右下左上的方向，这与中文竖排时从左上角开始书写的习惯不同。",
        "time": "00:20:51"
      },
      {
        "question": "是否汉字的运笔默认是从左往右？",
        "answer": "汉字的运笔默认是从左往右，不存在从右往左的笔画，这是基于中文竖排时书写笔顺的习惯决定的。",
        "time": "00:22:37"
      },
      {
        "question": "我们将在节目中讨论什么主题？",
        "answer": "我们将从键盘开始，讲述汉字在屏幕上显示的过程，并探讨乱码是如何产生的，包括编码、字库显示等问题。",
        "time": "00:23:34"
      },
      {
        "question": "英文里是否有类似“乱码”的概念或称呼？",
        "answer": "英文里通常不叫“乱码”，而是将无法正确解码显示的文字称为“ decoding error”或“garbage text”，但在日本则称为“魔机8K”。",
        "time": "00:24:21"
      },
      {
        "question": "日本为何早期就有较完善的文字编码系统？",
        "answer": "日本是东亚最早开始电子化的国家，他们通过GS0201单字节编码实现了片假名的本地化使用，并逐渐发展出一套适应计算机环境的字符编码标准。",
        "time": "00:27:15"
      },
      {
        "question": "假名有反义词吗？",
        "answer": "假名的反义词是真名，即汉字。",
        "time": "00:30:06"
      },
      {
        "question": "日本在编码过程中为何要做两套假名系统？",
        "answer": "最初由于半角假名在显示时宽度与英文字母一致，为了与全宽度汉字对齐，避免视觉上的不协调，所以设计了一套全宽度的假名加密。随着技术发展，尤其是图形界面时代的到来，为了美观和对齐需求，进一步区分了半角假名和全角假名。",
        "time": "00:32:52"
      },
      {
        "question": "编码表中，半角假名和全角假名对应的是不是同一个码点？",
        "answer": "不一样，在Unicode中为了向后兼容，它们对应的码点是不同的。",
        "time": "00:35:42"
      },
      {
        "question": "日本早期的区位码设计和GB2312编码规范有何关联？",
        "answer": "GB2312沿袭了日本的区位码技术，并根据汉字使用频率将汉字分成了常用字和次常用字，同时规定了汉字的编码方法。GB2312正式名称为信息交换用汉字编码字符集，它不仅规定了收录的汉字数量和分类，还规定了如何进行编码索引。",
        "time": "00:38:37"
      },
      {
        "question": "GB2312编码方案中，如何通过高位字节和低位字节表示汉字？",
        "answer": "在GB2312编码方案中，每个汉字和符号需要两个字节来表示，高位字节对应于一个固定的范围（0x10000到0x1E0FF），而低位字节则根据汉字所在的区位码（按94x94矩阵排列）进行编码，其中高位字节代表行，低位字节代表列。通过将高位字节加上0x10000以及低位字节作为偏移量，可以生成唯一的编码点，实现了汉字的编码。",
        "time": "00:43:04"
      },
      {
        "question": "GB2312字符集为何扩展为GBK和GB18030？",
        "answer": "因为GB2312字符集只有六千多个汉字，无法满足大量生僻字的需求。在当时，许多人的名字中的冷僻字无法正常录入，例如“喆”字是作为哲学哲的异体字废弃不用的，在GB2312中并未包含。为了解决这个问题，出现了GBK和GB18030等扩展字符集。",
        "time": "00:46:01"
      },
      {
        "question": "GBK编码方式具体是如何解决生僻字问题的？",
        "answer": "GBK编码在GB2312编码方式基础上进行扩展，实际上使用了双字节结构，但高位的每一位实际上都可利用，这样就大大增加了可编码汉字的数量。GBK编码收入了超过21880个汉字，相较于GB2312有了显著提升。",
        "time": "00:47:14"
      },
      {
        "question": "GB12345这个字符集有何问题？",
        "answer": "GB12345是一个特别坑的字符集，主要是由于它在处理繁简转换时存在问题，比如对多简对一繁的处理不当，导致生成的繁体字库会出现错字。这个字符集本质上是GB2312的一种繁体版本，但由于编码和简繁转换方法的问题，无法有效解决繁简转换中的错位问题。",
        "time": "00:48:39"
      },
      {
        "question": "GB18030与UNICODE编码有何关联？",
        "answer": "GB18030与UNICODE编码虽然码点不完全重合，但其变长编码思想与UNICODE相似。同样一个汉字在GB18030和UNICODE下的编码可能不同，而在GB2312和GBK中又是另外一套编码。",
        "time": "00:48:39"
      },
      {
        "question": "GBK与GB2312的关系是什么？GB2312、GBK和GB18030在编码方式上有什么区别？",
        "answer": "GBK是对GB2312的一个扩展，它包含并继承了GB2312中的字符集，并在此基础上增加了更多的汉字编码。同时，GBK并不是正式的GB标准文件，而是微软提出的汉字内码扩展规范。GB2312是一个字符集标准，配合一套编码方案；GBK是基于GB2312进行的汉字内码扩展，采用双字节结构，但只用了其中15位来编码，总共支持约32000多个汉字；而GB18030则采用了双字节和四字节混用的方式，支持更多的汉字和少数民族文字，码点与UNICODE编码并不完全重合。",
        "time": "00:51:07"
      },
      {
        "question": "GB2312、GBK和GB18030在兼容性方面的关系是怎样的？",
        "answer": "这三种编码方式基本互相兼容，即GBK包含GB2312的所有字符，并且GB18030也包含GBK的所有字符，但都各自有其特定的字符集范围和编码规则。",
        "time": "00:51:17"
      },
      {
        "question": "新加坡在汉字简化方面是怎么处理的？为什么新加坡没有继续使用那67个特定汉字？",
        "answer": "新加坡在1969年颁布了502简体字表，包含502个字，与中华人民共和国的汉字简体字方案不同，其中67个字不一致。1976年，新加坡决定完全采用中华人民共和国的简体字，这67个不一致的字不再使用。新加坡可能由于技术、政策或资源限制，无法处理新增的编码问题，所以最终选择采用中国的简体字标准。",
        "time": "01:01:16"
      },
      {
        "question": "Windows系统中默认保存文件的编码方式是如何设定的？",
        "answer": "在Windows系统中，用户可以选择不同的编码方式，对于中文版Windows，记事本默认保存时采用GB18030编码，而非GBK编码。微软早期推出的GBK编码与后来的GB18030编码存在一定的兼容关系，新版本的Windows理论上能够兼容旧版本的文件。",
        "time": "01:07:59"
      },
      {
        "question": "Unicode的目标是什么？",
        "answer": "Unicode作为一个独立机构，其目标是推动全球文字编码和字符集标准的统一，同时保持对地方性编码方案的兼容性，通过创造一系列主流编码方案（如UTF-8、UTF-16和UTF-32）来实现这一目标。",
        "time": "01:06:35"
      },
      {
        "question": "Unicode的基本多语言平面（BMP）是如何划分和组织字符的？",
        "answer": "Unicode的基本多语言平面是一个双字节（16位）字符集的组合，大约有65536个字符位置。各国的文字按照一定的顺序填充到这些位置中，例如汉字主要位于这一基本平面内，而日文、韩文等其他语言的汉字则分散在其他平面中。Unicode在制定编码时，并非完全按照各国原有汉字简化规则，而是根据字符本身的统一性进行分类和编码，以实现跨语言的统一性和兼容性。",
        "time": "01:09:34"
      },
      {
        "question": "在Unicode编码中，对于像“艺”这样在不同语言中可能有不同含义和读音的字符，该如何处理？Unicode统一汉字编码的原则是什么？",
        "answer": "Unicode编码并不规定字符的具体意义，只规定形状。对于这类字符，在CJK统一汉字编码时，各国或地区会各自把本国的汉字字符拉出来，如中国国标中有2312个字符，台湾有CNS编码，日本有JIS编码等。在韩国的KS编码中，由于韩文发音多，同一个汉字可能对应多个读音，导致有重复的编码。CJK统一汉字编码遵循“自离分有自缘分离”的原则，即对字形相似但意义不同的字符进行合并，而保持原有编码的差异性以保留各地的习惯用法。",
        "time": "01:16:53"
      },
      {
        "question": "是否存在解决这种混乱情况的方法？",
        "answer": "试图通过Normalization（规范化）规则来统一表达，但这会增加复杂度，且可能背离Unicode让所有符号在全球范围内尽可能统一的初衷。",
        "time": "01:19:53"
      },
      {
        "question": "对于多语言文本，在Unicode编码时如何区分不同地区的汉字写法？",
        "answer": "在Unicode编码层面很难做到这一点，通常需要依赖特定字体，例如带有CJK不同字形Variation的字体文件，或者通过HTML或Markdown等辅助工具标记文字语言及字体样式。",
        "time": "01:22:54"
      },
      {
        "question": "如果混排系统中无法方便地指定不同地区汉字的显示方式，会有什么问题？",
        "answer": "混排系统在处理不同地区汉字时，如果无法准确区分，会导致无论是机器还是人都难以分辨文字是中文还是日文，甚至同一个汉字在不同地区可能有完全不同的含义，这就需要人为添加元数据以确保正确精确地显示所需结果。",
        "time": "01:23:58"
      },
      {
        "question": "在UTF16编码中，如何解决超出基本平面65536个字符的限制？",
        "answer": "在UTF16编码中，通过在基本平面内抠出一小段（十六进制编码D800到DFFM）作为特殊标记，即sergi pair，对字符间进行特殊处理，从而能够表达超过基本平面的65536个字符范围。",
        "time": "01:30:31"
      },
      {
        "question": "早期为何选择UCS2而非更高效的UCS4编码方式？",
        "answer": "选择UCS2是因为它相对节省资源，而UCS4（UTF32）是固定长度的定长编码，对于单个字符A也会占用四个字节，较为浪费。",
        "time": "01:31:30"
      },
      {
        "question": "大端和小端的概念是如何产生的？",
        "answer": "大端和小端问题源于计算机内部数据的存储顺序，在非单字节编码中，不同架构对数据高位和低位的处理方式不同。例如，在16位整数中，大端式下左边是高位，小端式则右边是高位。",
        "time": "01:34:21"
      },
      {
        "question": "字符编码如UTF8、UTF16等是否也存在类似大端和小端的问题？",
        "answer": "是的，字符编码中也存在同样的问题，尤其是在编码的存储单元划分及内部顺序上，不同的编码方案可能采用不同的处理方式，如UTF16就有L和BE两种不同的存储方式，以适应不同的大端或小端系统。",
        "time": "01:37:30"
      },
      {
        "question": "BOM（Byte Order Mark）在UTF16编码中的作用是什么？",
        "answer": "BOM在UTF16编码中用于标志文本的字节序，即大端还是小端。在UTF8编码中，虽然规范不推荐将BOM作为标记使用，但在某些情况下，它可以明确指示文本是用Unicode的哪一种编码方案进行编码。",
        "time": "01:40:34"
      },
      {
        "question": "Windows记事本在保存文本时对于UTF8编码为何也会添加额外的字节串？",
        "answer": "Windows记事本在保存文件时，对于UTF8编码除了添加BOM标识符外，还会加上一个特定的字节串，虽然理论上UTF8不需要额外的标记，但记事本产品逻辑上将“UNICODE”与“UTF16”或“UTF32”的标记混淆在一起，因此在处理UTF8文件时也会添加一些不必要的标记。",
        "time": "01:43:07"
      },
      {
        "question": "OTUTF8是什么，它的编码方式是怎样的？",
        "answer": "OTUTF8虽然被称为UTF8，但是一种variable lengths（可变长度）的字符编码方式。这意味着一个符号或字符可能只需要一个字节（8个bit），最多可以使用6个字节来表示。原始的128个ASCII字符在UTF8中与ASCII编码相同，只需一个字节。而对于德语、阿拉伯语、俄语等非ASCII字符以及中文字符，需要2到4个字节进行编码。例如，大部分中文字符在UTF8中需要3到4个字节。",
        "time": "01:45:27"
      },
      {
        "question": "BMP是什么？",
        "answer": "BMP是Basic Multilingual Plane，即基本多语言平面，是Unicode中一个包含大量字符的平面，其中大部分汉字在此平面内，通常需要3个字节编码。",
        "time": "01:47:15"
      },
      {
        "question": "UTF8在早期的应用情况是怎样的？",
        "answer": "UTF8最早在2000年左右被定义，并在操作系统的更新中开始广泛应用，尤其在2000年之后的操作系统中得到大规模使用。其实在90年代就已经有官方定义文件存在，但真正广泛应用是在2000年后。",
        "time": "01:48:22"
      },
      {
        "question": "UTF8的优势体现在哪里？",
        "answer": "UTF8最大的优势在于跨平台和可交换性场景，因为它是变长编码，尽管对于内部处理可能较难处理，但在不同语言字符之间能够灵活适应，减少冗余编码，特别是在网络传输和磁盘存储时代，虽然早期可能存在空间占用大的问题，但在现代带宽充足的环境下，即使不使用压缩技术，也基本没有明显区别。",
        "time": "01:49:31"
      },
      {
        "question": "如何识别双字节和三字节的UTF8编码？",
        "answer": "在UTF8编码中，通过查看每个字节的前两位来判断是否为多字节字符。如果第一个字节的前两位是0，它就是一个单字节字符；如果前两位是10，则它是一个双字节字符；若前三位都是1，则表示这是一个三字节字符。其他字节的前两位除了第一位外，其余都为10，以此来标识连续的多字节字符。",
        "time": "01:50:34"
      },
      {
        "question": "为什么说变长编码如UTF8具有健壮性？",
        "answer": "变长编码如UTF8具有很强的健壮性，因为它能自我同步。即使在一个长文本中部分字符出现问题，也能通过查看每个字节的前缀来快速定位到字符的起点，并跳过损坏的部分，继续解析后续字符，从而保证了数据的正确解析和显示。",
        "time": "01:52:32"
      }
    ],
    "chapters": [
      {
        "time": "00:00:00",
        "title": "自弹自唱与内核恐慌播客节目",
        "summary": "本期节目中，主播们以轻松幽默的方式与听众分享了自弹自唱第26期以及内核恐慌的第41或42期的内容。节目涵盖了对播客制作的反思、听众反馈的讨论，以及对未来节目的期待。通过有趣的对话和对IT技术主题的探讨，节目呈现了一种独特的娱乐与信息结合的风格，展现了主播们与听众之间良好的互动关系。"
      },
      {
        "time": "00:02:06",
        "title": "探讨中文多音字的复杂性及手机与掌机的区别",
        "summary": "讨论了中文中多音字的复杂性，特别是'曲'字的不同读音及其在不同语境下的意义，包括其作为姓氏时的读音。此外，还提出了一个关于手机和掌机区别的问题。"
      },
      {
        "time": "00:05:30",
        "title": "掌机与手机的区分与语言中的上下文依赖",
        "summary": "讨论集中在如何区分掌上游戏机（掌机）和手持电话机（手机）的中文表述上，突出了语言学习中上下文的重要性。指出在中文和英文中，特定缩写或术语可能有多重含义，需要根据语境来确定具体意思。此外，也提到了德语中的相关表达，以及PDA的历史称呼。最终强调了在没有明确上下文时，语言理解的复杂性和挑战。"
      },
      {
        "time": "00:07:32",
        "title": "探讨键盘布局及电话号码记忆方法",
        "summary": "留言者john提到九键键盘布局未在讨论中提及，引发了对不同地区键盘布局的讨论。特别是在讨论了九宫格键盘的英文名称以及在不同文化中电话号码记忆方法的差异，包括利用字母组合记忆电话号码的技巧，以及数字在不同语言中的表达方式。还提到了算术基本定理与电话号码记忆之间的关联。"
      },
      {
        "time": "00:13:28",
        "title": "国际电话号码规则和拨号习惯",
        "summary": "讨论了国际电话号码的拨打规则和习惯，特别强调了中国手机号码和座机号码的区别，以及拨打国际电话时的区号和国家代码使用。中国手机号统一为11位，座机号码长度不一，区号通常为三位或四位。此外，还提及了国际长途电话的拨打方式，如中国使用'00'作为国际长途前缀，以及不同国家对于区号前'0'的省略规则。最后，讨论了国际电信联盟(ITU)对电话号码注记格式的规范，以及这些规则与通信原理的关系。"
      },
      {
        "time": "00:17:03",
        "title": "理工科背景主持人与文科生的对话",
        "summary": "在这段对话中，四位主持人都拥有理工科背景，这出乎了一些听众的预料，因为他们认为其中两位主持人应该是文科生。讨论中提到了对文科生的刻板印象，特别是认为他们特别文艺。同时，也提及了一位名为rex的人，他之前学习哲学，拥有社科背景，但不愿意参加节目。最后，主持人表示对于即将登场的主编大人，已经准备好了话题，期待大家的关注。"
      },
      {
        "time": "00:18:42",
        "title": "探讨反斜杠的多面应用及其文化差异",
        "summary": "对话中讨论了反斜杠在不同语境下的功能，包括作为转移符的用途、在数学中表示选项、以及在不同文字体系中的使用习惯。提到了在泰和中反斜杠用于转义特殊字符，以及在现实生活中人们使用反斜杠表示选项的现象。此外，还比较了阿拉伯文和德文中符号的使用习惯，探讨了中文竖排书写时的符号布局逻辑，强调了不同文化和语言环境下符号使用习惯的差异。"
      },
      {
        "time": "00:23:02",
        "title": "探讨乱码问题及其多语言背景",
        "summary": "本次讨论重点在于解释乱码现象及其背后的复杂原因，包括字符编码、字库显示等问题。乱码不仅限于特定语言，英语中也会出现乱码，尽管英文系统大多基于ASCII编码，相对兼容性强。日语中乱码被称为“魔机8K”，德语中则被称为“符号沙拉”，而英语则直译日语的表述为“磨叽8K”，反映出了不同文化对同一现象的不同理解和称呼。此外，讨论还提到了字符集和编码的基础知识，暗示了解决乱码问题需从字符集和编码开始探讨。"
      },
      {
        "time": "00:26:39",
        "title": "日本文字编码及书写系统的发展历程",
        "summary": "日本作为东亚地区最早实现电子化的国家，其文字编码的发展具有里程碑意义。最初的日本文字编码系统GS 0201基于单字节，通过扩展ASCII实现了对片假名的支持，并在特定代码位置替换了原有符号以适应日元符号和上划线的需要。片假名的选择主要是出于通信方便的考虑。日本的书写系统包含了罗马字、片假名、平假名和汉字四种字符，体现了其文字的多样性。历史上，日本虽有废除汉字的想法，但最终保留了汉字，并逐步在文字编码中加入更多字符以满足需求。随着时间的推移，编码系统不断更新，以容纳更多的字符，确保了日本文字在数字化时代的有效使用。"
      },
      {
        "time": "00:31:02",
        "title": "半角假名与全角假名的区别及历史演变",
        "summary": "讨论了半角假名和全角假名的概念，它们的区别不仅仅在于字符的宽度，还涉及到编码的问题。早期，半角假名占用单字节，全角假名占用双字节，这种区别主要是为了满足排版和显示上的需求。随着技术的发展，为了美观和对齐的需要，产生了全角的假名。同时，讨论还涉及到了Unicode编码中对这些字符的处理，指出为了向后兼容，Unicode中半角和全角假名的码点是不同的。"
      },
      {
        "time": "00:35:58",
        "title": "汉字编码发展及GB2312标准解析",
        "summary": "对话中讨论了汉字编码的历史发展，特别是GB2312标准的制定背景、结构和应用。GB2312标准遵循了日本汉字编码的先例，通过双字节编码和区位码来组织汉字，区分常用字和次常用字。该标准规定了94个区，共容纳6763个汉字及图形符号，其中汉字按照音序和部首排列，旨在促进信息交换的标准化。此外，还提到了向后兼容性问题和编码解码过程，强调了字符集和编码的重要性。"
      },
      {
        "time": "00:41:51",
        "title": "GB2312编码方式解析",
        "summary": "GB2312编码方式涉及编码字符集标准和编码规则，它与Unicode的code point相对应，但排列方式不同。作为编码方式，GB2312类似UTF16，每个汉字和符号需要两个字节表示，涉及高位和低位字节。具体编码方法使用87个区，通过特定的16进制加法对应汉字和特殊符号，形成一个不完全填充的94x94的表格。"
      },
      {
        "time": "00:45:31",
        "title": "汉字编码的发展及应用",
        "summary": "汉字编码经历了GB2312、GBK到GB18030的演变，以适应不断增加的汉字需求。早期GB2312因字符量不足导致生僻字无法录入，解决方法包括使用位图或手写代替。GBK和GB18030扩展了字符集，支持更多汉字，其中GBK由微软开发，不是正式国标，而GB18030支持双字节和四字节混用。编码方式与字符集之间并非一一对应关系，同一种字符集可通过不同编码方式实现。"
      },
      {
        "time": "00:49:16",
        "title": "中文字体编码与兼容性探讨",
        "summary": "在字体设计和编码中，GB2312作为最基本的编码标准，覆盖六千多个汉字，是字体制作的起点。随后，GBK编码扩大了字符集，而GB18030则进一步增加了支持的字符数量，包含少数民族文字，总字符数达到六万以上。然而，完全支持GB18030的字体较少，部分原因在于字符数量庞大和OpenType字体格式的限制。讨论还涉及了编码方式的演变，GB2312和GBK均为双字节编码，而GB18030支持单字节、双字节和四字节编码，展现了与Unicode编码思想的相似性。尽管GB18030和Unicode的码点不完全重合，但存在对CJK统一字符的支持。字符集之间的关系基本上是向后兼容的，GB18030包含GBK和GB2312的所有字符，体现了字符集之间的继承和扩展关系。"
      },
      {
        "time": "00:51:50",
        "title": "探讨GB12345编码及其对繁简转换的影响",
        "summary": "GB12345编码被视为一个不成熟且存在问题的过渡方案，尤其是在处理繁简体字转换时。该编码试图作为GB2312的繁体版本，收录了6866个汉字，但因为繁简转换并非一一对应，导致在实际应用中出现诸多问题，比如多繁对一简或一繁对多简的情况，使得简单的字库替换无法满足准确转换的需求。此外，许多在线简繁转换工具因未考虑到语境和前后文，经常产生错误。这一问题也影响到了字体产品的质量，导致市场上存在不少因为使用GB12345编码而出现错字的产品。因此，呼吁废除使用GB12345编码来封装字库的做法，提倡彻头彻尾地进行编码和字库的转换，以解决繁简转换的准确性问题。"
      },
      {
        "time": "00:56:49",
        "title": "操作系统与字符编码标准的发展历程",
        "summary": "对话内容涉及了操作系统，特别是微软Windows在字符编码标准发展中的作用，以及国家制定标准与跨国公司角色的转变。讨论从GBK编码的出现开始，讨论了其为解决中文支持痛点而诞生的背景，接着转向国家后续推出的GB18030编码标准，以取代GBK。此外，讨论还涉及了跨国公司在解决民生问题上的角色变化，以及技术发展如何超越政治与经济，强调了经济的先行作用。还提到了新加坡采用简体字的历史背景与原因，以及Windows操作系统中字符编码的演变，包括默认编码从GBK到GB18030的转变，以及Windows对旧版文件的兼容性。最后，引入了Unicode时代的讨论，指出电脑系统在字符编码支持上的进步和变化。"
      },
      {
        "time": "01:06:34",
        "title": "Unicode编码系统的原理与应用",
        "summary": "Unicode作为一个独立机构，旨在推动全球文字编码和字符集的标准化，同时也必须兼容地方性编码方案，导致无法实现完全的后兼容性。Unicode创建了基于标量值的规范标记方式，以及三个主流的编码方案（UTF-8、UTF-16、UTF-32），其中UTF-8和UTF-16在兼容性方面有所区别。Unicode的编码设计考虑到不同语言文字的特性，通过定义多个平面（包括基本多语言平面BMP）来容纳全球的文字，确保了全球语言的广泛支持。此外，还提到了CJK统一表意文字的概念，体现了Unicode在整合不同文化文字方面的努力。"
      },
      {
        "time": "01:12:05",
        "title": "Unicode编码中的CJK统一汉字问题探讨",
        "summary": "在Unicode编码系统中，针对中文、日文和韩文中汉字的处理存在复杂性和挑战。由于这些语言中使用的汉字在写法和意义上存在相似性和差异性，Unicode采取了统一编码的方法来简化处理，但这也导致了一系列的问题，如汉字的追根溯源问题、不同地区对同一汉字的不同简化处理，以及编码的兼容性问题。尽管Unicode的初衷是简化和统一编码，但实践中需要在保持编码系统的兼容性和简洁性之间找到平衡点。"
      },
      {
        "time": "01:20:53",
        "title": "Unicode编码与多语言文本处理的挑战",
        "summary": "讨论集中于Unicode编码在处理多语言文本时遇到的问题，特别是如何处理不同地区对同一汉字的不同写法。Unicode试图统一字符编码，但这种统一性导致了各地区特有字形显示问题，需要通过字体革命来解决。在使用Unicode编码进行多语言文本处理时，存在识别和正确显示不同语言字形的挑战，需要依赖特定的字体文件或进行复杂的手工调整。此外，讨论还触及了由于语言和地区的文化差异导致的词汇理解问题，强调了在多语言环境中精确标记文本的重要性。为应对这些挑战，提出了依赖于技术方案和仔细标记信息的方法。"
      },
      {
        "time": "01:26:40",
        "title": "中日文版'中国'的字形差异及Unicode扩展区域讨论",
        "summary": "对话集中讨论了中文和日文中'中国'两个字在Unicode编码系统中被视为不同点位的问题，尽管书写形式相同。指出当使用不同字体时，可以观察到字形风格的差异，这使得能够从字形设计的角度辨识出文本可能是源自日本还是中国。进一步地，讨论了Unicode系统为适应更多字符需求而进行的区域扩展，包括扩展ABCDE区以及台湾地区使用的甲乙丙丁戊的命名方式，并提到了新的扩展区域F。此外，还提及了Unicode系统的持续更新，以容纳考古发现的新字形以及古代书体如小篆、大篆等，强调了Unicode在保持文字多样性方面的重要性。"
      },
      {
        "time": "01:28:50",
        "title": "深入探讨UTF-16编码的由来与发展",
        "summary": "对话中讨论了UTF-16编码方式的历史背景，最初并没有UTF-16，而是使用UCS2。UCS2编码了基本多文种平面（BMP）内的65536个字符点位，但随着需求的增长，出现了超出台面的需求，因此引入了特殊的编码技巧（即代理项对）来扩展字符表示能力。此外，还提到了为了资源节省而选择使用UTF-16而非UCS4（UTF-32），因为UCS4对字符的固定长度编码较为浪费。整个讨论揭示了UTF-16编码在支持更多字符的同时，通过巧妙的代理项对解决方案，保持了编码效率和资源的节约。"
      },
      {
        "time": "01:32:16",
        "title": "字符编码和端序问题深入探讨",
        "summary": "讨论集中在字符编码（特别是UTF-16）以及大端和小端编码方式的区别上。叙述者解释了在处理非单字节编码时遇到的挑战，包括如何特殊处理特定编码格式（如UCS2与UTF-16）中的数据对，以及在字符编码中端序（大端与小端）问题的重要性。此外，还提到了计算机硬件架构对数据存储方式（大端式与小端式）的影响，以及这如何影响了网络标准和计算机编程实践，包括C语言中网络字节序与本地字节序的转换。最后，讨论了在文本编辑和保存过程中，如何通过字节序标记（BOM）来识别文本的编码方式。"
      },
      {
        "time": "01:38:56",
        "title": "深入探讨字节序列标志（BOM）及其在Unicode编码中的应用",
        "summary": "对话中讨论了字节序列标志（BOM）在Unicode编码中的使用，特别提到了Unicode字符FEFF（zero width no-break space）的特殊用途。BOM的使用被认为是一个技巧但也可能引发问题，因为它在文本中是不可见的，需要特定的编辑器才能看到。此外，讨论还涉及了Windows记事本在保存文件时对于Unicode和UTF-8编码选项的混淆，以及推荐使用UTF-8来避免编码问题。总结强调了在处理文本和编程相关工作时，应避免使用可能引入混乱的工具和编码方式，建议一律采用UTF-8编码以确保兼容性和减少潜在错误。"
      },
      {
        "time": "01:44:48",
        "title": "UTF8编码方案解析",
        "summary": "UTF8是一种高效的字符编码方案，被称为编码中的圣杯，尽管带有美国中心主义色彩，但已在占地和效率上达到平衡。作为可变长度的编码，它可以使用1到6个字节来表示一个字符，对于常见的ASCII字符仅需一个字节，而其他如德语特殊字符、阿拉伯语、俄语的西里尔字母及中文需2到4个字节。此编码在2000年左右开始被广泛使用，尽管对于中文用户可能导致文件大小增加50%，但现代压缩技术已使这一问题不复存在。UTF8的目标是实现全球统一的编码标准，虽然其应用尚未十分普及，但已在许多2000年后发布操作系统中大规模使用。"
      },
      {
        "time": "01:49:30",
        "title": "UTF8编码的特点及其在互联网协议中的应用",
        "summary": "UTF8编码的主要优点在于其跨平台性和兼容性，能够支持不同的互联网协议，被互联网工程工作小组要求所有互联网协议必须支持，并被互联网邮件联盟推荐为电子邮件软件的标准。UTF8通过变长编码方式，支持从单字节到最多六个字节的字符表示，通过观察字节的前几位来判断其编码长度。这种设计简化了操作系统的内部处理，但在实现上存在不能无限扩展字符长度的限制。"
      },
      {
        "time": "01:52:32",
        "title": "探讨UTF-8编码的自我同步与Unicode字符集扩展",
        "summary": "讨论集中在UTF-8编码的自我同步特性上，强调了即使在部分字符损坏的情况下，也能迅速识别并重新定位文本起点的能力。此外，还探讨了Unicode字符集的扩展问题，指出不断增加新字符可能导致的混乱，并通过具体的表情符号例子讨论了Unicode收录标准的争议。最后，提到了技术实现对标准推动的影响，以及字符编码在实际应用中可能遇到的问题。"
      }
    ],
    "mindmap": {
      "children": [
        {
          "children": [
            {
              "children": [
                {
                  "children": [],
                  "content": "中国国家标准，基于单字节编码"
                },
                {
                  "children": [],
                  "content": "收录了6763个汉字"
                }
              ],
              "content": "GB2312"
            },
            {
              "children": [
                {
                  "children": [],
                  "content": "兼容GB2312，增加生僻字和符号"
                },
                {
                  "children": [],
                  "content": "双字节编码"
                }
              ],
              "content": "GBK"
            },
            {
              "children": [
                {
                  "children": [],
                  "content": "兼容GBK，支持少数民族文字和符号"
                },
                {
                  "children": [],
                  "content": "双字节和四字节编码"
                }
              ],
              "content": "GB18030"
            },
            {
              "children": [
                {
                  "children": [],
                  "content": "全球字符编码标准"
                },
                {
                  "children": [],
                  "content": "支持多语言文字和符号"
                }
              ],
              "content": "Unicode (尤妮蔻)"
            },
            {
              "children": [
                {
                  "children": [],
                  "content": "变长编码，兼容ASCII"
                },
                {
                  "children": [],
                  "content": "最多使用六个字节表示一个字符"
                }
              ],
              "content": "UTF-8"
            },
            {
              "children": [
                {
                  "children": [],
                  "content": "双字节编码，部分字符使用四字节"
                },
                {
                  "children": [],
                  "content": "支持基本多语言平面(BMP)和补充平面"
                }
              ],
              "content": "UTF-16"
            },
            {
              "children": [
                {
                  "children": [],
                  "content": "固定长度编码，每个字符用四个字节表示"
                }
              ],
              "content": "UTF-32"
            }
          ],
          "content": "编码标准与技术"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [],
                  "content": "文件编码与系统或应用期望的编码不符"
                }
              ],
              "content": "编码不匹配"
            },
            {
              "children": [
                {
                  "children": [],
                  "content": "字体缺少对某些字符的支持"
                }
              ],
              "content": "字体支持"
            },
            {
              "children": [
                {
                  "children": [],
                  "content": "数据在网络传输过程中受损"
                }
              ],
              "content": "传输错误"
            },
            {
              "children": [
                {
                  "children": [],
                  "content": "不正确的编码转换导致显示错误"
                }
              ],
              "content": "编码转换错误"
            }
          ],
          "content": "乱码原因"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [],
                  "content": "通用性强，兼容ASCII，便于处理多语言文本"
                }
              ],
              "content": "使用UTF-8编码"
            },
            {
              "children": [
                {
                  "children": [],
                  "content": "使用支持广泛字符集的字体，如Noto Sans、Arial Unicode MS"
                }
              ],
              "content": "字体选择"
            },
            {
              "children": [
                {
                  "children": [],
                  "content": "确保服务器和客户端使用相同的字符编码"
                }
              ],
              "content": "服务器与客户端编码一致"
            },
            {
              "children": [
                {
                  "children": [],
                  "content": "使用兼容多种编码的软件和编辑器"
                }
              ],
              "content": "软件兼容性"
            }
          ],
          "content": "解决方案与建议"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [],
                  "content": "向Unicode统一编码标准发展"
                }
              ],
              "content": "编码统一趋势"
            },
            {
              "children": [
                {
                  "children": [],
                  "content": "更多支持广泛字符集的字体出现"
                }
              ],
              "content": "字体技术进步"
            },
            {
              "children": [
                {
                  "children": [],
                  "content": "网络协议和传输技术优化，减少乱码出现"
                }
              ],
              "content": "网络传输优化"
            },
            {
              "children": [
                {
                  "children": [],
                  "content": "用户对编码和乱码问题的认识增强"
                }
              ],
              "content": "用户意识提升"
            }
          ],
          "content": "行业影响与展望"
        }
      ],
      "content": "乱码与编码讨论脑图摘要"
    }
  }
}