{
  "pid": "5e284e0c418a84a0462693e4",
  "eid": "5e84c3ac418a84a0462df95b",
  "title": "28. In the Beginning was the Command Line",
  "task_id": "3vl8qg4jzkgkqpr2",
  "transcription": [
    {
      "time": "00:00:00",
      "text": "欢迎收听IPM podcast网络旗下的IT技术主题娱乐节目内核恐慌。我们号称哈克了，但是也没有干货，想听的人听，不想听的人就别听。本节目的网址是kernel panic dot FM，我们推荐大家使用podcast客户端订阅我们的节目，详情请访问IP dot LS ash FAQ。",
      "speaker": "发言人1"
    },
    {
      "time": "00:00:17",
      "text": "欢迎你为本节目捐款，捐款地址是kernal panic dot FM flash donate。捐款金额随意，只要是八的正整数倍就可以。捐款不会为你带来什么，不捐也不会让你失去什么。",
      "speaker": "发言人1"
    },
    {
      "time": "00:00:29",
      "text": "这句话很好像成了一个密码。你们上期IT工作，你们为什么要插入一句话？非常突兀，我觉得。Anyway, 我们的口号是it's easier to porter shell than a shell script from liver。",
      "speaker": "发言人1"
    },
    {
      "time": "00:00:47",
      "text": "对，所以我们这一期又有主题了。不过在进入主题之前，我们先来做一下上一期的听众反馈。首先是我们的热心听众切普罗先生，远远在加远在澳大利亚为我们写来的，听众反馈说二位前辈好，第27期提到了用QQ发代码的问题，二位似乎在疑惑什么场景需要这么做？一个典型的例子就是group assignment。虽然我本科不在国内，不了解国内院校的细节，不过如果不用git而且没有退而求其次使用丢丢盒等同步盘的话，主人。",
      "speaker": "发言人1"
    },
    {
      "time": "00:01:25",
      "text": "过去是什么东西？",
      "speaker": "发言人2"
    },
    {
      "time": "00:01:28",
      "text": "这是婉莹教会我使用的job box的昵称丢丢。对对对，组员共享代码就只有使用QQ这种门槛较低的方式。然而即使在国外，效果情况也不能说理想。我校虽然有顶级大牛，本科毕设就是给GHC的添加LVLMVM。后端也还是有人不会用git做group assignment的时候，把代码从自己的eclipse拷贝到bucket的网页编辑器，不经意间就三番五次覆盖掉别人的成果。以我一届本科生的浅见，这大概与计算机课程覆盖面太广，与其他学科相比欠烧线系统性也有关系。如果以理工划分工，计算机是既有理又有工。除了计算理论，PLT这种非常形式化非常形式化理论化的东西也有。例如gitty这样乍一看非常的脏，但是考虑了很多因素的best practice。当然指望学校覆盖这么多内容也不现实，毕竟这是一个非常依赖个人修行的行业。这本节目有没有？",
      "speaker": "发言人1"
    },
    {
      "time": "00:02:37",
      "text": "所以这让我想起今天我们后面要提到一个小插曲，就是为什么说码农，我觉得什么不能把码农称为软件工程师的一个原因。",
      "speaker": "发言人2"
    },
    {
      "time": "00:02:49",
      "text": "Programmer, stop calling yourself engineers.",
      "speaker": "发言人1"
    },
    {
      "time": "00:02:52",
      "text": "这是一篇。如果说你对这些工具流程都没有一个很或者说其实这怎么说也可能要反过来讲。就是像那种就是你叫computer science的学校，他可能很多人会觉得这种工具层面的东西跟这个science其实并没有什么太多的关系，对吧？然后他会觉得会或多或少的会在这个层面上轻视这个东西。因为觉得过去的对他就他不是就是那非核心的东西，那就是属于叫什么来着？技校教的东西，不应该是大学教的东西。",
      "speaker": "发言人2"
    },
    {
      "time": "00:03:26",
      "text": "但其实我觉得这个就不太对你如果说你真的是想作为工程的话，你真的要做software engineer的话，你很难想象一个什么传统建筑行业的，或者建筑工程师。因为他说他不会用那些什么那些工具，比如说什么仪器，还有那个梁那种价值什么测绘用的那些东西，对吧？你肯定是要学这些基本的操作的。所以说我还记得像哪怕是学物理的话，你还要学会用各种各样的这个叫什么来着？游标卡尺，或者这些更高级的一些工具，对吧？",
      "speaker": "发言人2"
    },
    {
      "time": "00:04:00",
      "text": "是高中物理，我觉得其实物理学的分野已经很明显了。有些理论物理学家真的是完全不做实验的。你看那个TBBT里面Shelly不是也一直。",
      "speaker": "发言人1"
    },
    {
      "time": "00:04:10",
      "text": "在嘲笑那做动手做实验。",
      "speaker": "发言人2"
    },
    {
      "time": "00:04:12",
      "text": "对，我觉得其实就是有这个理论和实践的分野的，学科可能都会有这种多多少少的做纯理论的人会轻视需要动手做实践的人，因为其有理论就够了。但你刚才说的那个建筑又是完全一个比较不一样的东西了。因为建筑本身就是从实践而来的，建筑没有什么纯理论的东西的，或者说有但没有那么脱离现实的纯利润。他他他不会研究他不会研究真空中的纯球形建筑，对吧？",
      "speaker": "发言人1"
    },
    {
      "time": "00:04:49",
      "text": "以后我们造那个spaceship的时候就需要考虑这个问题了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:04:52",
      "text": "真空中的球形针不就是水滴吗？不是水滴，是那个。",
      "speaker": "发言人1"
    },
    {
      "time": "00:04:56",
      "text": "dance star .",
      "speaker": "发言人2"
    },
    {
      "time": "00:04:59",
      "text": "4星和荣耀赛。",
      "speaker": "发言人1"
    },
    {
      "time": "00:05:02",
      "text": "对，所以我的我的观点其实很简单，就是很多现在有很多学校也在分这个东西。它分这个计算机科学系和计算机工程系，或者说就是软件工程游戏。所以如果你们这个里面带有工程，但是又又不去对这个学生进行系统化的这种像这种代码管理工具的培训，编辑器的培训，ID的使用培训。你不去教这些best practices，我觉得你是不配去教自己是一个工程系的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:05:31",
      "text": "对，这是肯定的。但是如果你做纯理论的话，又会觉得说学那些系统而为的工具的时间还是挺好像有点浪费。我觉得我三号有这种印象，就是有些学计算机的人，他之所以不懂那些具体的工具，乃至于学计算机科学的人不会修计算机，也是因为它是工具，太太这耗时间了。",
      "speaker": "发言人1"
    },
    {
      "time": "00:05:57",
      "text": "主要是对，所以我觉得纯理论的也theoretical的研究也好，培训research这点完全没有问题。但是如果说你还是指望你的毕业生有能够在就业市场上起码本科，你说这个博士研究生，你说他你不指望他，你不去管他们的就业，不在那个职场，就是做码农这个方向的去，其实我觉得情有可原。但是如果说你是一个本科的一个教学目标，然后你说把这些完全就剔掉，不看我觉得是其实是有问题的。就是从务实的角度来讲，还是从对这些人的未来的就业的情况来讲，我觉得这个是有有欠考虑。",
      "speaker": "发言人2"
    },
    {
      "time": "00:06:39",
      "text": "没错。",
      "speaker": "发言人1"
    },
    {
      "time": "00:06:40",
      "text": "然后如果你真的这么干了，就不要叫自己的毕业生是soft ener这种title好了。对，下一个听这种反馈，这个虾仙究了我们一个错。上次上期我们提到那个那个叫做let's encysted，一个叫SSL的这么一个服务。它的founder机的university and ichigan是密歇根大学，不是密歇根州立大学，这个应该是我说错了。意识最快。所以美国这个学校也是挺搞挺有意思的，它会有michigan state或者university michigan两种比较坑的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:07:20",
      "text": "对你看武武汉大学和湖北大学就是两所大学，对吧？没有人搞混。但是为什么不这个是。",
      "speaker": "发言人1"
    },
    {
      "time": "00:07:29",
      "text": "不这个是如果可以比的，应该是湖北大学和湖北省立大学的区别。",
      "speaker": "发言人2"
    },
    {
      "time": "00:07:36",
      "text": "OK，对，因为没有一个城市叫做midian。对。",
      "speaker": "发言人1"
    },
    {
      "time": "00:07:42",
      "text": "就是接着念这则听众反馈本来只想随手回复一下这个小小的口误，反正也要发邮件，不多说几句感想或废话。内核恐慌是我是从第一期开始听的，追的热情不亚于追翻很美剧。这么高的评价好像是不是很惶恐。早晨上班单位和公寓之间commute很久，经常在路上笑话各种pocard节目，埃及公论和内核恐慌真是一集不落来面对了有时候听到有意思的片段，都是一个人戴着耳机坐在车上傻笑。这种随身便携还只能独享的愉悦，真是迷人自豪。这位同学，你这个中毒男生的真的不用怀疑，不用考虑一下邻座的感受吗？OK大家你好，我是从事交互设计行业的，所以对设计、产品、MVP相关的话题更感兴趣，其他片开放的内容也能接受，之前是从CS转行过来的。心里多少有点没能继续坚持走马的阳关大道不动摇的遗憾。不对，你这选对方向了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:09:00",
      "text": "我觉得于是。",
      "speaker": "发言人1"
    },
    {
      "time": "00:09:01",
      "text": "靠听播客了解大家都在干嘛，讨论什么维系。你看我还是很积极关注技术的安全感，特别喜欢邀请了嘉宾的几期肖吉姐、沐瑶老师、韦楼，还有最近的L达，改联系各位爹，然后提供厦门学生客户的那段小说。虽是不一样的领域，但都会对自己思考问题解决问题的方式有启发，对我来说已经很可贵了，这个我还是蛮蛮欣慰的。就是你李如意这个文件有时候会把IT公论的气氛弄成辩论会，我隔着wifi都觉得这是要剑拔弩张了，可能是我多虑了结果要插话确实是多虑了。相较而言，内核恐慌就和谐得多。果然程序员是天底下最可爱无害的神般存在，有进有退，有分寸，还特自然。不管怎样，我还是爱你们所有人，包括很有逼格，括号就是褒义的李如意。",
      "speaker": "发言人2"
    },
    {
      "time": "00:10:07",
      "text": "最后我其实我本来想说，要是有靠谱湾区南马龙愿意每周末出来泡个咖啡店、图书馆，做做自己想做的side project。觉得有个设计师一起也不赖，请联系我。不过我觉得这样被解误解成HR的概率太大，而且听上去总有总是不像好人，有种无耻的猥琐感。于是算了吧，这挺好的，我觉得挺好的，你们这个自己组合。",
      "speaker": "发言人2"
    },
    {
      "time": "00:10:36",
      "text": "对他强调这个弯曲南马龙。",
      "speaker": "发言人1"
    },
    {
      "time": "00:10:38",
      "text": "所以这应该是个妹子。对，为什么要一定是男是个女生？",
      "speaker": "发言人2"
    },
    {
      "time": "00:10:42",
      "text": "可能好吧？",
      "speaker": "发言人1"
    },
    {
      "time": "00:10:46",
      "text": "对，还是说助内和恐慌越做越棒，达到新闻联播的进步。嘣嘣是指蜂蜜，当然是指风雨无阻的韧性和权威性了。又没有你们写固定排比句模板，报喜不报忧。我家还蛮开心的，其实这个节目能够给大家带来一点点快乐的时光，然后觉得还有所启发。这个其实对我就个人觉得是个挺高的评价，听起来好像对，然后我还是这个叫什么，很纠结于这个为什么只限男码农呢？就没有女码农吗？",
      "speaker": "发言人2"
    },
    {
      "time": "00:11:28",
      "text": "你们这是要要前两天我好像昨天我女朋友跟我说，维密有一个模特申了纽约大学去学编程了，然后他还成立一个基金会。",
      "speaker": "发言人1"
    },
    {
      "time": "00:11:39",
      "text": "那个是是黑人女孩子。",
      "speaker": "发言人2"
    },
    {
      "time": "00:11:44",
      "text": "我我我没有看，说什么长得超正，然后毅然解约去学编程，还要每年支持N个女生去学编程之类的一个。",
      "speaker": "发言人1"
    },
    {
      "time": "00:11:53",
      "text": "我知道他他是他是哪个学校？他是做那个IOS开发的，然后业余做一下这个维多利亚的这个秘密的模特身材超赞。然后节目就录完节目去看一下码，码农女神好不好？这个是之前什么知乎上也有一个那也有一个模特女孩子，后来就学牌坊了，我记得。然后后来还搞了一个创业项目，是做一个什么订阅器来着。",
      "speaker": "发言人2"
    },
    {
      "time": "00:12:26",
      "text": "我忘了OK，找那个链接加到首脑资料，那就我们只有这两期，只有这两封反馈了，应该是，对，其实还有一个比较简短的，就是有一位听众给我们写信来说，推荐了一篇文章叫做programmer should stop called the themselves engineers。是来自于telegram，but the atlantic, sorry，报纸网站上面的一篇文章。这篇文章其实我前两周也看过了，他因为他曾经在hacker news上出现，然后其大意就是说这个工程师是一个非常高大上的title。其实他就是按照这篇文章的这个调子来说，工程师是一个非常庄严，一个让人可以信赖，然后门槛非常高的这么一个title。而这些tech industry，就是我们这些搞搞电脑这帮人，总是会总是希望把自己总是会使用什么software engineer这种title。然后这样的title实际上是在给engineer抹黑，因为很多software是非常不可靠的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:13:42",
      "text": "就他原句里面有句话我就记得，就是许多软件服务在今天其实已经成了infrastructure，但是他们却远远不如传统的infrastructure可靠。比如说对，我我其实我可以理解这种像他的这种说法。比如说facebook，对于很多人来说，facebook或者i message已经全都是非常每天离不开的东西了。但是就今天明天什么时候，莫名其妙facebook就outrage一下子，什么outrage，outage twitter也是对吧？你很难想象在一个发达国家会一天到晚停电，但早就至少推特有一个阶段就是这样。",
      "speaker": "发言人1"
    },
    {
      "time": "00:14:25",
      "text": "但现在的像facebook、google这些的out就基本上很少了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:14:30",
      "text": "对，是相对来说是。",
      "speaker": "发言人1"
    },
    {
      "time": "00:14:31",
      "text": "它也不是大面积。",
      "speaker": "发言人2"
    },
    {
      "time": "00:14:33",
      "text": "的对对的。但我的意思就是从统计学的角度来看，他们还是要比这个传统的infrastructure要来的那么频繁一点。",
      "speaker": "发言人1"
    },
    {
      "time": "00:14:46",
      "text": "那倒不一定，我觉得这个看你怎么去，你要考虑一个叫什么量级的问题。比如说你见过哪一栋楼每天有10亿人在同时使用它，没有吧？好吧？对，所以我觉得你如果要考虑这个可靠性的话，得考虑它的这个使用频次，还有那些问题。还有像这些建筑的豆腐渣豆腐渣工程也不好，那些也不是工程师干出来的，对吧？说的可以也不尽然，好吧。",
      "speaker": "发言人2"
    },
    {
      "time": "00:15:19",
      "text": "反正是一个论调。然后大家可以去看一看这篇文章，我觉得还行，挺有意思的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:15:25",
      "text": "OK现在进入我们这个新闻环节。对，其实就两条新闻。",
      "speaker": "发言人2"
    },
    {
      "time": "00:15:31",
      "text": "对，因为我们两个最近都没有怎么看新闻。你忙什么？我反正是在忙着打boss.",
      "speaker": "发言人1"
    },
    {
      "time": "00:15:38",
      "text": "你打什么。",
      "speaker": "发言人2"
    },
    {
      "time": "00:15:40",
      "text": "辐射四刚出来的好吧。",
      "speaker": "发言人1"
    },
    {
      "time": "00:15:43",
      "text": "那个是一个什么射击游戏吗？",
      "speaker": "发言人2"
    },
    {
      "time": "00:15:47",
      "text": "射击游戏是个反乌托邦的这大灾难之后的RPGRPG的史诗。",
      "speaker": "发言人1"
    },
    {
      "time": "00:15:56",
      "text": "般的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:15:57",
      "text": "史诗般游戏。",
      "speaker": "发言人1"
    },
    {
      "time": "00:15:59",
      "text": "的对，都出到4了，应该差不多是这样的，不是14应该.",
      "speaker": "发言人2"
    },
    {
      "time": "00:16:04",
      "text": "不会出到4对对，所以我就只看了两则新闻。",
      "speaker": "发言人1"
    },
    {
      "time": "00:16:09",
      "text": "等一下你只打负号是负，你没有打那个我，那legacy the void.",
      "speaker": "发言人2"
    },
    {
      "time": "00:16:17",
      "text": "他们是从头一天出来的，但是迄今为止我刚刚只把那个legs of the void第一关玩了大概两分钟，然后就一直在打方头。",
      "speaker": "发言人1"
    },
    {
      "time": "00:16:27",
      "text": "好吧，你这个叛徒。",
      "speaker": "发言人2"
    },
    {
      "time": "00:16:30",
      "text": "sorry.",
      "speaker": "发言人1"
    },
    {
      "time": "00:16:31",
      "text": "好吧，你有啊，我还没买，因为最近比较忙，然后也没空去玩游戏。OK讲新闻，第一个是什么？其实这个是旧闻了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:16:41",
      "text": "这个应该就是两周之前的事情。一周多之前的事情不止我。",
      "speaker": "发言人1"
    },
    {
      "time": "00:16:46",
      "text": "我觉得这个东西我好像好几个月前就已经看到过了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:16:51",
      "text": "What I .",
      "speaker": "发言人1"
    },
    {
      "time": "00:16:53",
      "text": "think难道。",
      "speaker": "发言人2"
    },
    {
      "time": "00:16:54",
      "text": "那anyway，反正这个东西也许是两一周之前才正式有了。自己的网站会有发ICQ什么的。OK对，总之它是一个来自于google的移动编程框架，名字叫做flutter FLUTTER。哼它最大的特点大概就是使用dark language来写，可以支持你是用dark large来写这个。",
      "speaker": "发言人1"
    },
    {
      "time": "00:17:23",
      "text": "移动端领域。所以这样做有什么好处呢？",
      "speaker": "发言人2"
    },
    {
      "time": "00:17:29",
      "text": "如果你开发android的话，以后也许不用写叉了。",
      "speaker": "发言人1"
    },
    {
      "time": "00:17:32",
      "text": "但是当然是自己加，好吗？",
      "speaker": "发言人2"
    },
    {
      "time": "00:17:36",
      "text": "我觉得还是好一些的，因为有什么语言能比java还长？",
      "speaker": "发言人1"
    },
    {
      "time": "00:17:43",
      "text": "C plus plus PH.",
      "speaker": "发言人2"
    },
    {
      "time": "00:17:44",
      "text": "PPH javascript. 对，但dark跟javascript，可能dark可以compile into javascript，但语言不是我们的重点。但我的意思是它最大的卖点就是使用可以使用java之外的语言来写。按照而且它的它其实是本质上是一个跨平台的框架。它可以把写出来的程序编译成OS ten的不IOS的程序，然后也可以在android上跑。Windows phone我目前还没有印象的，应该将来可能也会支持。",
      "speaker": "发言人1"
    },
    {
      "time": "00:18:25",
      "text": "其实说到那个android，其实用scala也可以写开发这个android应用。",
      "speaker": "发言人2"
    },
    {
      "time": "00:18:33",
      "text": "理论上是可以的，而且好像是有框架的。对，只是是我反正你不关注。",
      "speaker": "发言人1"
    },
    {
      "time": "00:18:38",
      "text": "我也更不关注，不是太流行好像。",
      "speaker": "发言人2"
    },
    {
      "time": "00:18:41",
      "text": "对，然后flutter也采用了一些类似于那个facebook的，叫什么来着reactive的相似的设计模式，然后可以支持你比较使用这种类似于functional reactive的方式来。",
      "speaker": "发言人1"
    },
    {
      "time": "00:19:00",
      "text": "写它的界面。所以这个flatter算什么？算是google的亲儿子了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:19:08",
      "text": "应该是吧？看这个意思。",
      "speaker": "发言人1"
    },
    {
      "time": "00:19:09",
      "text": "但是dart其实一直搞不懂他们是到底是要主推这个还是怎么样。因为之前说是要把这个大做进chrome里面，就直接支持这个语言了。但后来好像这个计划就取消了，所以给人给外界的信心好像不是很足的样子。",
      "speaker": "发言人2"
    },
    {
      "time": "00:19:27",
      "text": "对我觉得google可能如果go language是钦定的这个后端语言的话，那前端或者是更比较没那么工业级别的使用的这种脚，类似于脚本的更快的更易于执行的语言应该是大。但总觉得背后的推力不够，他没有在努力的去PR这件事情。",
      "speaker": "发言人1"
    },
    {
      "time": "00:19:53",
      "text": "对，所以我觉得很可能因为姑姑经常出这种觉得听起来还不错，挺酷的一个项目，然后他过一段时间就不推，然后这个项目就又又死翘翘了这种这也不是第一次了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:20:05",
      "text": "我觉得在google这边有一个魔咒，就是他们努力推的东西一般都不会成功。比如说比如google plus或者是对或者是什么那个东西之前胎死腹中的那个一出来，哇哦所有人都惊呆了。然后最后死掉的那个东西叫什么？",
      "speaker": "发言人1"
    },
    {
      "time": "00:20:21",
      "text": "是干嘛用的？",
      "speaker": "发言人2"
    },
    {
      "time": "00:20:23",
      "text": "号称要代替电子邮件的那个东西，google way OK对google wave不也是一顿狂推，然后就完蛋了。所以他们可能也学会了闷声发大财的这个不行，我觉得最近这个节目里面那个梗太多了，应该介意。然后不推的东西反而会慢慢火起来。",
      "speaker": "发言人1"
    },
    {
      "time": "00:20:44",
      "text": "所以你看好这个吗？这个flatter.",
      "speaker": "发言人2"
    },
    {
      "time": "00:20:49",
      "text": "我也不查，我现在已经不没有再写过移动端的东西了。所以那你已经。",
      "speaker": "发言人1"
    },
    {
      "time": "00:20:54",
      "text": "放弃作为移动开发者了吗？",
      "speaker": "发言人2"
    },
    {
      "time": "00:20:57",
      "text": "没有我还是在看swift.",
      "speaker": "发言人1"
    },
    {
      "time": "00:21:00",
      "text": "放弃安卓开发者了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:21:03",
      "text": "对，好吧，是阵营不同，屁股决定脑袋。所以我对他没有意见，只是让大家知道。",
      "speaker": "发言人1"
    },
    {
      "time": "00:21:10",
      "text": "一下有这么一个东西是吧？然后是不是坑明年再说，你们可以先跳进去。",
      "speaker": "发言人2"
    },
    {
      "time": "00:21:15",
      "text": "是不是坑你跳了告诉我。",
      "speaker": "发言人1"
    },
    {
      "time": "00:21:19",
      "text": "OK这个不错。对，然后这条新闻就是比较有意思的一个网站，数字零点就是。",
      "speaker": "发言人2"
    },
    {
      "time": "00:21:31",
      "text": "0.3.",
      "speaker": "发言人1"
    },
    {
      "time": "00:21:32",
      "text": "然后有15个数字零。",
      "speaker": "发言人2"
    },
    {
      "time": "00:21:35",
      "text": "是想对。",
      "speaker": "发言人1"
    },
    {
      "time": "00:21:36",
      "text": "这个理论上就是你看名字其实也大概猜得到。这个是讲了一个floating point浮点数的一个网站。",
      "speaker": "发言人2"
    },
    {
      "time": "00:21:45",
      "text": "对，如果你遇到了这个问题的话，你一定会立刻明白这到底是一个什么梗。如果你不知道的话，欢迎你。如果你朋友有电手边有电脑的话，不妨去看一看。它是一个讲解浮点运算的网站。就是在有些语言里面，有些非常坑爹的语言里面，如果你去计算0.1加0.2的话，结果将会是0.3跟着10 00000。然后四对就是它不是一个你理想中的的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:22:18",
      "text": "然后究其原因是为什么？就是这篇这个网站想要告诉你的，它来自于一个对他们工这是他们工程界的作用的。他们工程界定了这么一个IEE754标准，然后这个标准里面的规定了计算机应该怎样用二进制来表达浮点数，就是表达带小数点数的非整数。然后这个标准如果你严格去按照它实施的话，那你最终就会得出0点35个0，然后一个四这种诡异的0.1加0.2的大。",
      "speaker": "发言人1"
    },
    {
      "time": "00:22:50",
      "text": "这是一个近近0.3的近似值，而非确切值。因为你们没有办法在二进制的里面表示，就没办法在二进制里面精确表示0.3。",
      "speaker": "发言人2"
    },
    {
      "time": "00:23:03",
      "text": "对，在二进制里面在其实这是一个增长的问题。就是在你采用什么样的数字就会产生什么样的问题。比如说如果我们采用11进制的话，那11分之1就是一个可以被表达出来的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:23:16",
      "text": "等一下如果你采用11进制，只能表达11分之1精确的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:23:22",
      "text": "对，如果你用11进制的话，你就可以表达11分之1，11分之2之类的。这种数字非常精确对吧？0.102。但如果你用十进制的话，那11分之1和11分之2就是一个无限循环小数。",
      "speaker": "发言人1"
    },
    {
      "time": "00:23:33",
      "text": "对吧？对对对，你连11分之2你也没法表达。",
      "speaker": "发言人2"
    },
    {
      "time": "00:23:37",
      "text": "为什么不能0.2不就是11分之2吗？0.1是十进制的，不对，十进制的0.1是10分之1.",
      "speaker": "发言人1"
    },
    {
      "time": "00:23:45",
      "text": "我明白你我明白你的意思。",
      "speaker": "发言人2"
    },
    {
      "time": "00:23:48",
      "text": "0点11进制下面0.1不就是十进制下面的11分之1吗？",
      "speaker": "发言人1"
    },
    {
      "time": "00:23:55",
      "text": "对，没错。对对对，理解你。",
      "speaker": "发言人2"
    },
    {
      "time": "00:23:57",
      "text": "你说的是这个意思OK对，没错。对，所以在二进制下面就有很多十进制的数字，是没有办法表达为一个二进制下面的整数的。整的这个分数听着有点绕，但you get point就是0.1可以带，可以表达0.5，但是0.6就没办法表达了，就大概这个意思。",
      "speaker": "发言人1"
    },
    {
      "time": "00:24:21",
      "text": "所以在实际的一些编程语言里面怎么处理？然后这个网页上就给了一个相对来说比较详细的列表，会出现什么样的状况？",
      "speaker": "发言人2"
    },
    {
      "time": "00:24:33",
      "text": "然后就你可以使用什么样的，你在遇到什么样的语言的时候，可能会得到什么样的结果，以及你怎样解决这些问题。比如说有些语言里面像sit h hop类的都是什么dash库，就是专门用来解决这个任意精度的十进制数的问题。你可能会问为什么不把这个任意十进制精度的数字做成一个默认的数字的实现？有些原是这样的，但另外一些语言不是这样的。因为根据使用场景，这个库可能会非常的慢，而有些时候你是不需要这个功能。",
      "speaker": "发言人1"
    },
    {
      "time": "00:25:07",
      "text": "就一般是这样，这个金融的系统里面要算涉及到钱的，都会有那种任意金度的十进制的，任意精度的十进制，一个包去处理这些钱的数目，对吧？没错。再然后其他的一些就为了追求效率，就是用这个浮点型来表示。然后浮点型在现在的计算机上一般有两种长度。一种是叫做float，是32位长的。然后另外一种是叫做double，是64位。Double精度的话，double应该有53位的精度，53个bit的精度。对，50 555 13个digital的，53个digit的精度，应该是。",
      "speaker": "发言人2"
    },
    {
      "time": "00:25:50",
      "text": "你是说小数点是后面。",
      "speaker": "发言人1"
    },
    {
      "time": "00:25:53",
      "text": "不管是小数点前，是因为它的浮点数那个点小数点是可以浮动的，它精度只是代表它有效数字那一部分。对，没错，是这样。然后float的话应该只有。",
      "speaker": "发言人2"
    },
    {
      "time": "00:26:05",
      "text": "好像只有多少28这个.",
      "speaker": "发言人1"
    },
    {
      "time": "00:26:07",
      "text": "72 28.",
      "speaker": "发言人2"
    },
    {
      "time": "00:26:08",
      "text": "位27应该一位我想想一位的符号。",
      "speaker": "发言人1"
    },
    {
      "time": "00:26:12",
      "text": "它有27个bit，但是它的实际的表示成叫做。",
      "speaker": "发言人2"
    },
    {
      "time": "00:26:17",
      "text": "对，你是说range.",
      "speaker": "发言人1"
    },
    {
      "time": "00:26:19",
      "text": "对它的那个它表达出来的那个有效的数字好像只有八位还是九位，就是八个有效数字，九个有效数字，很小的一个数字。反正对对对，然后在实际语言就会就这个跟编程其实会有点关系。就是说如果你要做一个浮点数的加减乘除的话，你要特别小心这一点。特别是你用float这种32位的精度的32位这种窄的浮点数的时候，很容易用着用着发现你累。",
      "speaker": "发言人2"
    },
    {
      "time": "00:26:46",
      "text": "比如说你做一个累加对吧？你加完之后发现这个跟预想的这个出入怎么那么大，就是因为浮点数这个精度在作怪。你设想一下，你加一个特别大的一个数字，加上一个特别小的一个数字，两加起来因为精度的问题可能直接就无效了。但是如果说你有很多很多特别小的数字累加起来，你再加到一个特别大的数上面去，你这个物质精度的牺牲导致的误差会它是会逐渐累积的。所以这里面是有很多坑爹的事情。",
      "speaker": "发言人2"
    },
    {
      "time": "00:27:19",
      "text": "所以有一个rule of some，就是如果能够不使用时浮点数的话，尽量不要使用浮点。就是在早期学编程的时候应该学到一点。",
      "speaker": "发言人1"
    },
    {
      "time": "00:27:28",
      "text": "刚刚才说除了这个解决方案，除了说用一个叫做D10进制的这个无限无限精度的一个库去表达一个任意精度的数字。还有一个方法就是用一个叫做rational，就是分数的形式或者是fraction。他这个原理就比较简单了，他说我没有办法，通过这个我没办法除尽，那我干脆不除，直接就是按分子分母。大家还记得小学学那个吗？怎么去对两个分数相乘的时候，那个方法就是在程序上实现同样的原理，最后得出来的结果还是一个分数，就是几分之多少分之多少。当然那个多少和就分子和分母都可能会比较大。那你可以通过消减什么公因数、公约数的方法，去把它尽量缩成。",
      "speaker": "发言人2"
    },
    {
      "time": "00:28:13",
      "text": "一个最大功率。我已经至少两次一听到你在IT攻略里面试图说什么最大公约数。对我每次都记不住。",
      "speaker": "发言人1"
    },
    {
      "time": "00:28:21",
      "text": "到底是哪个。",
      "speaker": "发言人2"
    },
    {
      "time": "00:28:24",
      "text": "对，应该是最大公约数和最小公倍数，最小公倍数。",
      "speaker": "发言人1"
    },
    {
      "time": "00:28:29",
      "text": "对，差不多这个意思。然后具体是哪个我也忘了。这些想法。",
      "speaker": "发言人2"
    },
    {
      "time": "00:28:34",
      "text": "比较有意思的是在有些我们常见的语言里面，它实现还有点奇怪。比如说这个CC可能还比较简，为什么PHP里面0.1加0.2是出来是0.3呢？然后发现PHP这门世界上最强大的语言，他偷偷的把这个0点30 000004这么一个浮点数转化成了一个字符串，然后把它变为0.3。太强大了。然后我不知道这个mysql里面是怎么做的，它这个原理是什么？应该还是用的这种折中的办法，就是四舍不是四舍五入的方法。",
      "speaker": "发言人2"
    },
    {
      "time": "00:29:16",
      "text": "要看SQL是怎么实现的。因为SQL那C.",
      "speaker": "发言人1"
    },
    {
      "time": "00:29:20",
      "text": "口规范肯定是没有定义。",
      "speaker": "发言人2"
    },
    {
      "time": "00:29:23",
      "text": "这些规范没有说，那就实现了0.3.",
      "speaker": "发言人1"
    },
    {
      "time": "00:29:27",
      "text": "对是个。",
      "speaker": "发言人2"
    },
    {
      "time": "00:29:28",
      "text": "好问题。",
      "speaker": "发言人1"
    },
    {
      "time": "00:29:29",
      "text": "然后在python里面有点意思，python里面是如果你把它打印出来，它是一个0.3对吧？对，但是实际上那个数值应该还是0.3000004的。所以会有一个算法去告诉说你要打印的这个值，它是一个某一个更短的分数，小小数的近似值，然后它会默认去把它近似。这个判断的方法也是用跟PHP1样的，就是通过转换成串的形式去做这个事儿。",
      "speaker": "发言人2"
    },
    {
      "time": "00:30:02",
      "text": "然后在排名三里面这一点被会这一点被纠正，就是不要做这些莫名其妙优化。因为其实如果一个用户看到的值和他的实际的值不一样的话，是有可能充满。",
      "speaker": "发言人1"
    },
    {
      "time": "00:30:14",
      "text": "对所以在实际使用中，比如说你们做一些什么？举个简单例子，你要做一个工业的一个什么测量，它读出来的这个数值，它可能是一个浮点数的时候，他们是怎么去判断？就是比如说你要判断这个值是不是大于或者小于某个值的时候，是要算上一个在合适的精度范围内吗？还是怎么样？",
      "speaker": "发言人2"
    },
    {
      "time": "00:30:39",
      "text": "工业上面一般会有一个指定的精确范围，但不同工业不一样。有，但不过大部分都是小数点之后三位，应该就是你我。",
      "speaker": "发言人1"
    },
    {
      "time": "00:30:49",
      "text": "就是说你在编程的时候，你要判断两个浮点数的大小的时候，你怎么办？",
      "speaker": "发言人2"
    },
    {
      "time": "00:30:55",
      "text": "是你说要判断两个浮点数的相等于与否，还是大小不同。",
      "speaker": "发言人1"
    },
    {
      "time": "00:31:04",
      "text": "其实我觉得用判断两个浮点数是否相等这件事情本身就是跟你的初衷是有这个常识是有有相悖的。除非你特别理解这个I1754到怎么一回事。",
      "speaker": "发言人2"
    },
    {
      "time": "00:31:16",
      "text": "对，在一般新的世界里面，浮点数是非常棘手的一个东西。反正对所以。",
      "speaker": "发言人1"
    },
    {
      "time": "00:31:20",
      "text": "一般的说法应该是两个数A要判断两个数是否近相近，应该是用A减B然后算它的差值是不是在某一个。",
      "speaker": "发言人2"
    },
    {
      "time": "00:31:28",
      "text": "然后看它差值是不是在一个，对，就有点像那个工工工业里面造阳零件，然后看0两0件是不是合乎要求，就要看它的偏差是不是在一个可接受范围之内。",
      "speaker": "发言人1"
    },
    {
      "time": "00:31:41",
      "text": "范围内的。对，这个还是蛮坑的，反正没错，万万能的忽略。你看这就是计算机科学和计算机工程学的差工程的区。",
      "speaker": "发言人2"
    },
    {
      "time": "00:31:52",
      "text": "OK in theory, there's no difference in practical. 我想那句话怎么说来着？In there there's no difference theory and practical. In practical there is不是不是叫做in .",
      "speaker": "发言人1"
    },
    {
      "time": "00:32:04",
      "text": "theory there is no difference between .",
      "speaker": "发言人2"
    },
    {
      "time": "00:32:08",
      "text": "syria and practice in。那今天的主题就是比较in practice一个东西，主题是命令行。哼对，这是我们上期提到的吗？还是上期提到的一个主题。",
      "speaker": "发言人1"
    },
    {
      "time": "00:32:27",
      "text": "反正某一期你承诺过你就要讲。",
      "speaker": "发言人2"
    },
    {
      "time": "00:32:31",
      "text": "对，然后其实这个主题也的确是挺挺值得说的，因为尤其是对于初学者来说，或者对于正在朝这条路上越走越远的人来说，命运好像是一个绕不开的话题。",
      "speaker": "发言人1"
    },
    {
      "time": "00:32:50",
      "text": "基本上其实我我觉得我要先问一个问题，现在很多这种新就是新人们好像他们学电脑都不用，就直接开到命令行了，或者很多用windows的人都基本不用命令行了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:33:04",
      "text": "但是我觉得将来还是会早晚有一天你会撞上。",
      "speaker": "发言人1"
    },
    {
      "time": "00:33:08",
      "text": "所以你觉得他们还是会把这课给补上。",
      "speaker": "发言人2"
    },
    {
      "time": "00:33:11",
      "text": "是吧？对，其实这也是一个值得讨论的话题。就是在在我们小时候在大家就至少然后在windows或者是dos微软的操作系统用户的早期的童年童年记忆里面，计算机开机是不会自动进入图形界面的。同学们就是像我们这些饱受溺爱的迈克用户，一开机就可以看到一个闪闪发光的大苹果，然后一进去就有鼠标用，这种事情在至少90年代的中国是不可想象的，对吧？",
      "speaker": "发言人1"
    },
    {
      "time": "00:33:48",
      "text": "在温开局先选一个bio spring对吧？对，然后进到那个C然后听到。",
      "speaker": "发言人2"
    },
    {
      "time": "00:33:53",
      "text": "那个熟悉的磁盘自检的声音。我们应该把磁盘自检的声音拿来当我们的开头曲用的。我就像。",
      "speaker": "发言人1"
    },
    {
      "time": "00:34:00",
      "text": "怎么形成一个开头。",
      "speaker": "发言人2"
    },
    {
      "time": "00:34:02",
      "text": "就像atp 1样，他们用那个调制解调器的声音，我们可以用那个磁盘自检的声音。来。",
      "speaker": "发言人1"
    },
    {
      "time": "00:34:13",
      "text": "咱们开始好吧，终于找到一个符合本节目主旨的这么一个对呃声音的特质了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:34:22",
      "text": "我是在那个辐射四里面，因为辐射四里面经常需要去黑一些那个terminal，然后那个terminal有个特别的声音，我是听那个声音的时候想到OK。对，然后我们在90年代的时候需要开机看到一个boss BIOS自检，然后屏幕清零，左上角出现一个闪烁的C冒号反斜杠大于号。",
      "speaker": "发言人1"
    },
    {
      "time": "00:34:46",
      "text": "然后一个闪。等一下90年代你就看到C了吗？应该是A或者是B。",
      "speaker": "发言人2"
    },
    {
      "time": "00:34:53",
      "text": "对，A冒号反斜杠大一个没错。C没有，我没有那么没有那么好了。我觉得我小时候就在我的那个。",
      "speaker": "发言人1"
    },
    {
      "time": "00:35:04",
      "text": "你来磁盘就硬盘。",
      "speaker": "发言人2"
    },
    {
      "time": "00:35:06",
      "text": "学习机之后的电脑，其实我遇到的已经大部分都是带磁盘的了。",
      "speaker": "发言人1"
    },
    {
      "time": "00:35:12",
      "text": "我想想对你没用过那种叫做无盘工作站吗？",
      "speaker": "发言人2"
    },
    {
      "time": "00:35:18",
      "text": "无盘工作站是那个时候。",
      "speaker": "发言人1"
    },
    {
      "time": "00:35:21",
      "text": "磁盘很贵。",
      "speaker": "发言人2"
    },
    {
      "time": "00:35:23",
      "text": "联网了之后才有的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:35:26",
      "text": "不对，我知道有些那种以前那种叫做什么来着，这不叫叫机房。对它不是每台电脑都有磁盘的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:35:34",
      "text": "我知道，但我的意思是我第一次接触计算机就接触IBMPC兼容机，应该是在我爸单位的一个秘书室里类似的这么一个地方。然后你看那个电脑不仅有磁盘，还有游戏在上面，所以我第一次接触到C冒号反斜杠大银行应该是在那边。",
      "speaker": "发言人1"
    },
    {
      "time": "00:35:54",
      "text": "老师那你那个还你运气还是蛮好的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:35:57",
      "text": "对，在此之前我只能在中华学习上用一个录音带的那个读取的东西。但是中华学习反正没有apple two，反正没有磁盘的概念，就没有那个盘符的概念OK对。",
      "speaker": "发言人1"
    },
    {
      "time": "00:36:11",
      "text": "所以进到C之后要怎么进图形界面，还要插个win，是不是？",
      "speaker": "发言人2"
    },
    {
      "time": "00:36:15",
      "text": "对你要打win回车，然后才可以进windows。",
      "speaker": "发言人1"
    },
    {
      "time": "00:36:19",
      "text": "所以我问的是。",
      "speaker": "发言人2"
    },
    {
      "time": "00:36:21",
      "text": "3133.33.3，我的3.2是减体重的吗？Winter 3.1只有像对，在世界其他版本特别短命。对，windows 3.1或者windows 13.2是windows 95之前，世界上最流行的windows 8。",
      "speaker": "发言人1"
    },
    {
      "time": "00:36:39",
      "text": "施瓦辛格演过一部电影叫什么来着？谎言与真实谎言。真实的谎言里面他潜入一个反正是阿拉伯语的这么一个机构里面，然后那个windows的那个3.2的上面显示的是阿拉伯那个windows挺惊讶的对，印象很深刻。所以在那个时代是开机不默认进图形界面的，所以那是一个非常。",
      "speaker": "发言人1"
    },
    {
      "time": "00:37:07",
      "text": "记得我还记得有一个就是当时图形界面还没有完全普及，或者说有些机器太古老，它跑那个图形界面会比较慢。但是还有一个叫做命令行的文件管理软件，叫什么来着？什么commander，total commander.",
      "speaker": "发言人2"
    },
    {
      "time": "00:37:24",
      "text": "total commander. 对，PC tools，total commander, 还有好多东西都是命令行下面的一个命令行界面，就是命令叫什么？有一个专门名字来形容这种东西。CUI就是command line，use this就是它它虽然不是图形界面的，但是它是用各种各样的符号来组成一个可以点的窗口。对。",
      "speaker": "发言人1"
    },
    {
      "time": "00:37:44",
      "text": "可以用，有鼠标可以用。对，然后鼠标就是一个一一大块字符，一个字符它的应该是一个80乘以24个字符的一个窗口。对，然后鼠标就刚好占一格一个字符的位置。",
      "speaker": "发言人2"
    },
    {
      "time": "00:38:00",
      "text": "对，然后挪动鼠标的时候，屏幕上就有一个大黑块在挪动。其实在好多linux安装界面里面还是可以看到这个东西。我想看。",
      "speaker": "发言人1"
    },
    {
      "time": "00:38:13",
      "text": "然后其实这AI就是linux上面的这种工具，一般是基于很多是基于应该叫NKRRN是吧？对，是这个包来写的。然后还挺长，就还算常用。至少是在我们在节目最后会介绍一些类似这种工具，那这里就先放一放对扯远了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:38:33",
      "text": "反正在那个时候你可能你打开电脑会你有一个明确的想法，说今天我要干什么。然后根据你要干什么，你要决定说是在这个dos的命令行提命令提示符下面打入打，比如说PAL或者是CMC还是w win。因为如果你要玩游戏的话，你可能不需要那个图形界面的操作，只需要打入那个游戏的名字，然后游戏就会独占整台计算机。然后把所有。",
      "speaker": "发言人1"
    },
    {
      "time": "00:39:04",
      "text": "大富翁的那个名启动名是不是rich？我记得。",
      "speaker": "发言人2"
    },
    {
      "time": "00:39:08",
      "text": "对，没错，还有三国，什么战国群英传之类的，你就是你都对对对，需要在那个盘符下面输入这个。",
      "speaker": "发言人1"
    },
    {
      "time": "00:39:18",
      "text": "金庸群侠传。行，也是这样。",
      "speaker": "发言人2"
    },
    {
      "time": "00:39:21",
      "text": "对，金庸侠传也是。就在那个时候很多人都记仙剑。",
      "speaker": "发言人1"
    },
    {
      "time": "00:39:25",
      "text": "仙剑不要忘了这个刚刚说完。",
      "speaker": "发言人2"
    },
    {
      "time": "00:39:28",
      "text": "对，对，然后那个拍片是什么来着？帕拉丁就是这个游戏的英文名，很奇怪的，叫做帕拉林之类的，就是十字军的那个词。还是我记错了，为什么会这样？对，我也不知道，我觉得很奇怪。然后反正在那个时代后，很多人不学电脑，或者说没有那么taxi，乃至于很多小孩子可能打开电脑唯一会做的一件事情就是在那个命令后面输入这个游戏的名字，然后按回车，这就已经算是懂了。表现对，这大概就是相当于在windows下面你会按开始菜单，就是这种感觉。",
      "speaker": "发言人1"
    },
    {
      "time": "00:40:07",
      "text": "对，后来1995年有了windows 95，整个世界才进入一个开机默认进图形界面的时代。当然苹果用户意外了，但我们至少我们我们小时候都不是苹果。对。",
      "speaker": "发言人1"
    },
    {
      "time": "00:40:21",
      "text": "你是吧？你不是从苹果肌开始起家。",
      "speaker": "发言人2"
    },
    {
      "time": "00:40:26",
      "text": "但是但是apple two开机也不是进图形界面的。对，apple two还是就除非我的意思是除非你是macintosh或者是你是apple lisa的用户，你小时候是apple lisa的用户，那那你那你肯定不会跟我们是同一个阶级的人，好吗？所以我的意思是对在普通人的童年里面，在中国普通人的童年里面，很少有人会接触到以及开机就进入图形界面的电脑。当然这是我们那个时代，现在很多人可能你我相信我们的听众里面，很多人已经在windows 95发布会之后出生的了。所以。OK .",
      "speaker": "发言人1"
    },
    {
      "time": "00:41:06",
      "text": "come go on .",
      "speaker": "发言人2"
    },
    {
      "time": "00:41:08",
      "text": "the hard cold .",
      "speaker": "发言人1"
    },
    {
      "time": "00:41:11",
      "text": "truth是吧，那接着讲历史，这个命令行的历史要追根溯源，其实还蛮久远的对。",
      "speaker": "发言人2"
    },
    {
      "time": "00:41:18",
      "text": "其实这是一个非常自然的事情，就是在早期，早到什么时候，就是在50年，在60年代，根本世界上根本没有人想过要在要要能够实时的在屏幕上画出一个图形，然后你去操作它这种事情。虽然那个时候电视已经问世了，哼等等，电视是什么时候问世的？一九五几年位置。对，然后或者是一九五几年开始普及了。但是一九五几年的计算机却没有采用电视来做他们的显示终端，而是采用一种叫做telly type的东西。",
      "speaker": "发言人1"
    },
    {
      "time": "00:41:56",
      "text": "我们现在一般翻译成电传打字机。他顾名思义就是可以用电，可以用可以远程传输数据的打字机。打字机的意思就是你按一个键，然后你前面有一个纸纸辊，然后这个纸辊这个滚动的纸纸卷上面会显示出你打的字符。然后这个电传打字机是teletype，就是由telly type公司所制造的。然后teletype公司所制造的这些机器在50年代末60年代初的时候，是基本上是遍布整个西方世界。尤其是美国，基本上每一个每个大学，每一个机构都会有。因为这个东西真的是非常的在那个时候就像一个像什么呢？像有可以类比为今天的什么东西呢？",
      "speaker": "发言人1"
    },
    {
      "time": "00:42:50",
      "text": "这点折键其实。",
      "speaker": "发言人2"
    },
    {
      "time": "00:42:51",
      "text": "就是有点像今天的笔记本电脑，基本上可以用到的地方非常多，然后有点稍微有点尊严的地方都会弄弄上来。",
      "speaker": "发言人1"
    },
    {
      "time": "00:43:06",
      "text": "其实你有用过这个电传打字机这种实体吗？",
      "speaker": "发言人2"
    },
    {
      "time": "00:43:09",
      "text": "我还没有老到这个地步，我只在德意志博物馆里面见过。你用过我也只是。",
      "speaker": "发言人1"
    },
    {
      "time": "00:43:14",
      "text": "在电影或者是这个博物馆里面见过，其实并没有用过这个东西。对，然后我印象最深刻的应该是用这个那个船，那个叫做stock tick，就是股票的。因为这以前的那种股票交易所，他开始就使用这种电商打字机。他用一个很长的纸袋打出来那个股票的对价钱，实时报价。那只只见过这种用例，就是其他用例还真的蛮少见。",
      "speaker": "发言人2"
    },
    {
      "time": "00:43:40",
      "text": "然后在我记得我是在以前读一篇讲操作系统的历史文章里面说那个作者当时他还是一个中学生。然后他们学编程的方法是，先在一张纸上仔细写一下自己想要写的程序，好像是fortune还是pascal这个程序。然后第二天拿着这张纸去学校的图书馆的一间房子里面，然后把自己的这个程序输入到一个打孔机上。打孔机会根据你按下的键来把一个打孔纸带打上孔，然后把这些打孔打好孔的卡片放到一个电传打字机的输入槽里面。然后这个电传打字机可以把这些打孔的卡，就是打了孔的卡片，利用这个电传打字机的调制解调器连上电话，然后输入到远端的一台计算机上，然后计算机帮你输入执行你的程序，然后再把这个结果传回来。",
      "speaker": "发言人1"
    },
    {
      "time": "00:44:46",
      "text": "对整个过程我还是觉得读的就是觉得非常的惊悚。因为你会很难想象说我靠写这么一个程序，比如说是print hello work，在那个时候可能是需要两天的这么一件事情。对，而且刚才提到一个细节，就是它一个电商打字机会需要跟远端的一台电脑联络，对吧？但是这有一个问题，就是在在贝尔实验室，不是贝尔实验室，就电话是由贝尔公司发明的，是由贝尔发明的对吧？但是有些人会说他是爱迪生发明的。但是如果你没有被这个中学课文骗过，骗到的话，那电的话电话其实贝尔发明的。然后贝尔成立了贝尔公司，贝尔公司到1981年还是哪一年为止，一直都是美国的一个独占垄断的这么一个电话公司。如果你在美国使用电话的话，那你使用的一定是贝尔从服务。",
      "speaker": "发言人1"
    },
    {
      "time": "00:45:43",
      "text": "然后就是90年代的中国电信，没错。",
      "speaker": "发言人2"
    },
    {
      "time": "00:45:46",
      "text": "就是那种感觉。所以我们通过读历史就知道这个电信公司永远是邪恶的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:45:52",
      "text": "Anyway, 在60年的时候，贝尔公司有这么一条，规定，就是我的电话线路只能用来打电话，你不能在上面传输其他电讯号。这就意味着你不能说我把电话拆了，然后把它连到电脑打字机上，然后让这台电电车打字机和另外一台电动车打字机联络。那怎么办呢？人们有这么一个方法，就是用一个用一个小盒子，然后这小盒子上面有两个圆形的，用这个皮人造革包起来的这么一个两个基座。然后你可以把电话拿起来拨一个号，然后把这个电话放在这个基座上，这样电话两个听筒一边对着一个麦克风，就是听筒对着麦克风，然后电话的听筒，则对着那个小盒子上面的扬声器，这样小盒子可以把电传打字机的电信号转化为声音信号。如果你用过拨号上网的话，就是那种滴滴滴滋滋那种声音，然后这个信号被电话用声音信号，用模拟的声音信号传到远端，然后远端再把它转化为二进制信号，是这么一个过程。这也是一个非常有意思的东西。然后这个东西一直使用到70年代初，贝尔公司减就是去除了这个限制，人们才渐渐的可以不再用这种非常原始古老的，用声音来传递二进制发二进制信息的。",
      "speaker": "发言人1"
    },
    {
      "time": "00:47:25",
      "text": "这东西叫什么？Acoustic coupler。对，acoustic coupler, 声音acoustic acoustic coupler，那叫什么呢？声音连接器对。",
      "speaker": "发言人1"
    },
    {
      "time": "00:47:41",
      "text": "其实这个其实现在讲的还是蛮酷的。感觉刚好今天我看到一则一个一则新闻，就是说现在有些因为广告做那个追踪的add tracking，他就是说现在有一种很很暗黑的科技，就是电视的广告里面，它会植入一种高频的声波，就是这个人耳是听不见的。然后这个高频的声波是可以被手机的麦克风捕捉到。然后它上面手机上会跑一个应用去监听麦克风，听到这个声音，它从而知道你是否在看到哪个电视节目。",
      "speaker": "发言人2"
    },
    {
      "time": "00:48:13",
      "text": "天哪，简直是1984。",
      "speaker": "发言人1"
    },
    {
      "time": "00:48:17",
      "text": "但是你想想这个原理其实就跟刚才讲的这个acoustic couple其实是差不多的，就是叫声学连接。我们现在有wifi通过无线电的信号去传输这个信息的。它这个玩意儿是用一个声波的信号去传输这个信息的。然后只是说因为为了这个传输的效果好，他把这个扬声就是收发就收发端。简单来讲就麦克风是一个收端，然后这个扬声器是一个发送端，然后它是因为你这个电话机是有麦克风和扬声器，它可以发可以收。你那个acoustic couple也是有这个扬声器和麦克风也是收和发。两个反转对接不就刚好形成了一个联通的回路了吗？没错，这听起来还是蛮帅的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:49:00",
      "text": "没错，太帅了。",
      "speaker": "发言人1"
    },
    {
      "time": "00:49:04",
      "text": "然后后来就说那可以直接接电了，就意思是说从无线变有线了呗，直接插管子对吧？插线插插线。",
      "speaker": "发言人2"
    },
    {
      "time": "00:49:12",
      "text": "就对后来后来的这个调制解调器就可以自己去进行拨号，然后直接把音频信号转化为这个直接把电信号转化为音频电信号。",
      "speaker": "发言人1"
    },
    {
      "time": "00:49:22",
      "text": "然后再，所以其实这个acoustic for和我们理解的modern，其实本质上是以做同样的事情的对吧？只是说他们接入方式不一样。",
      "speaker": "发言人2"
    },
    {
      "time": "00:49:31",
      "text": "应该是modem.",
      "speaker": "发言人1"
    },
    {
      "time": "00:49:33",
      "text": "的一个部件对，就是代替这个导线的那个部件。对。",
      "speaker": "发言人2"
    },
    {
      "time": "00:49:37",
      "text": "就是后来的modem可以直接通过一个分线头插在电话线上。Modem其实本身就是电话的线路的一个意思。",
      "speaker": "发言人1"
    },
    {
      "time": "00:49:44",
      "text": "RRJ32这个标准，RJ多少？",
      "speaker": "发言人2"
    },
    {
      "time": "00:49:47",
      "text": "RJ45是网线对吧？对，R450网线RJ32是应该是多少？是电话小的电话接头。这叫什么来查一下，你查。",
      "speaker": "发言人1"
    },
    {
      "time": "00:49:58",
      "text": "Hey.",
      "speaker": "发言人2"
    },
    {
      "time": "00:49:58",
      "text": "phone like水晶头。",
      "speaker": "发言人1"
    },
    {
      "time": "00:50:04",
      "text": "But arms just a register jack. 然后。RJ11对，RJ11。OK对，这个是我们RJ32有这个东西吗？可能没有记错了，有RJ11、RJ14、RJ25，然后对，就这么一些。然后RJ45就是我们常说的这个双绞线，就是网线的标准投了，它会宽一些，应该是有多少帧来的？里面四个四个针网线是八个帧。对，网线四对嘛？对，然后这个应该是四个，真，2 71，具体也不太懂。",
      "speaker": "发言人2"
    },
    {
      "time": "00:50:46",
      "text": "其实现在我看也有很多这个那个RJ45，因为它那个线头多，它其实可以当电话线用的，然后还可以留几个来做一个百兆的头。所以很多这种写字楼或者是家里装修的时候，他就说为了方便，就不单独布这个电话线的槽，而且直接走一个网线就好了。对，但是如果你现在要装修房子，我强烈不建议这么干。首先第一个你不需要，真的需要电话机了，对吧？现在都是用手机。第二个就是如果你干了之后，你那个网线，哪怕是你说什么超无聊的线，那也最后最终也只能跑百兆的这个速度来。",
      "speaker": "发言人2"
    },
    {
      "time": "00:51:20",
      "text": "我现在租房子，就是我现在和女朋友租房子，就是有每一间房子里面都有三两个网线的接口好鸡肋。",
      "speaker": "发言人1"
    },
    {
      "time": "00:51:30",
      "text": "就一个是电话。",
      "speaker": "发言人2"
    },
    {
      "time": "00:51:31",
      "text": "一个是走网。没有两个都是来就有一个在在储藏室里面有一个装电话线的槽，然后那个槽上面有一个等等于房间有自己的一个号，这个号分了8根线，到每个屋子里有两根。",
      "speaker": "发言人1"
    },
    {
      "time": "00:51:49",
      "text": "所以其实并没有什么用，就是说你还是用的wifi是吧？",
      "speaker": "发言人2"
    },
    {
      "time": "00:51:52",
      "text": "对，没错。",
      "speaker": "发言人1"
    },
    {
      "time": "00:51:54",
      "text": "淘汰掉技术。其实像我们现在在我在那个装修办公室，然后发现了一个新的办公室，也是要布线，那些其实都准备完全不走网线，都是走路线。对，纯wifi网络。扯远了，就接着说围绕电脑打字机。",
      "speaker": "发言人2"
    },
    {
      "time": "00:52:12",
      "text": "我们一下子越过了50年的历史，好跳。对，总之这个电传打字机的模样非常50年代。就是欢迎各位听众去点开这个show note里面的链接，看一看电池厂打字机到底是一个什么样的一个什么样子。但是最大我们这跟这一期节目有关的重点就是这个电子打字机通常只会在一行上面工作。就是不管你输入还是输出，你得到的结果一般都只有一行。当然输出有可能有很多行，那输入基本上就是一行一一行。",
      "speaker": "发言人1"
    },
    {
      "time": "00:52:44",
      "text": "是什么意思？",
      "speaker": "发言人2"
    },
    {
      "time": "00:52:46",
      "text": "一行就是这个电传打字机上面，你最长只能输入固定字符1 30 80个。对，然后如果你输到这儿还没完的话，你要么要告诉电子打磨机，我还要输再输入一行，然后你要输入一个特别的符号，这个时候你要按一个什么，按一个就相当于back slash的键，反正是上面的一个实体键OK。要不然你就得按回车，回车就是你把这一行当前行的东西输出出去。",
      "speaker": "发言人1"
    },
    {
      "time": "00:53:19",
      "text": "但这个时候你是告诉的是电传打字机，是我要输入多入一行？还是说告诉那个远端你要输入多余一行。",
      "speaker": "发言人2"
    },
    {
      "time": "00:53:26",
      "text": "而是告诉电商打字，就是电商杂机会把你当前整个行，就是它有一个buff份，你可以理解为它会把当前行8份里面的东西传输出去。但是这个buff er有多长是buffer，应该是要比一行的长度长的。但是不管怎么说，它的具体表现就是通常大部分情况下你只会输入一行。",
      "speaker": "发言人1"
    },
    {
      "time": "00:53:49",
      "text": "你想想那个场景还是蛮搞笑的，你打打一个mini超过一行的女孩子说。",
      "speaker": "发言人2"
    },
    {
      "time": "00:53:56",
      "text": "觉得我也打一下绝对没错，就是这种感觉。然后这个特征也就造就了我们接下来60年的这个计算机历史里面，几乎所有人，就至少所有需要学写程序的人都会面临的一个问题。就是什么是命令行？就是common line，line这个东西就来自于此。就是因为早期一点上打的机场就只允许你针对当前行来操作。",
      "speaker": "发言人1"
    },
    {
      "time": "00:54:29",
      "text": "所以不是命令行，是命令一行的对。",
      "speaker": "发言人2"
    },
    {
      "time": "00:54:31",
      "text": "就是一个命令行。我就有时候你会好奇说，为什么写写程序不能是从屏幕上的任何地方开始？为什么一定要是在左上角或者左下角或者然后输入一行命令，然后按回车呢？乃至于回车键到底是怎么来的？为什么会回车键而不是一个这种东西，而不是一个什么比如说开始输入或者开始执行这样的键，那其实也是从这儿来的。对呃，然后telling type这个词对于我们一直延续到今天的影响。",
      "speaker": "发言人1"
    },
    {
      "time": "00:55:06",
      "text": "还有一个就是TTY，我不知道你，但是我在开始接触linux的时候，经常会好奇说这个TTY到底是一个什么东西的缩写，这很难猜出来对吧？它其实teletype的缩写一直延续到今天。包括你面对的这台mac电脑，或者是你手上的android或者是你你你的iphone，其实都有TTY这个东西，对吧？就是在第device slash dty，哪怕你开打开你的item，上面就会显示说last logging。11月11号18点46分，然后MTTYS000。",
      "speaker": "发言人1"
    },
    {
      "time": "00:55:45",
      "text": "所以其实你要解释一下我们现在操作系统里面这个DVSTTY到底是它的一个作用是什么？",
      "speaker": "发言人2"
    },
    {
      "time": "00:55:52",
      "text": "Slash TT slash DY slash dty其实是一个用软件模拟出来的一个电传打字机的终端。",
      "speaker": "发言人1"
    },
    {
      "time": "00:56:00",
      "text": "就是你可以叫它其实它其实应该叫做PTTY对吧？",
      "speaker": "发言人2"
    },
    {
      "time": "00:56:03",
      "text": "Sudi DOTTY对，就是一个伪终端。它不是一个真正的电传打字机的实体，而是你的计算机想象出来的，它的它可以支配的诸多电传打字机之一。",
      "speaker": "发言人1"
    },
    {
      "time": "00:56:20",
      "text": "但它的作用是它的实际作用是什么呢？",
      "speaker": "发言人2"
    },
    {
      "time": "00:56:22",
      "text": "在现在的输出就是说。",
      "speaker": "发言人1"
    },
    {
      "time": "00:56:24",
      "text": "你打的键盘是通过这个TTY这个设备进入到cornel的。然后对我给你print回来的东西也是通过这个TTY设备传回来的。",
      "speaker": "发言人2"
    },
    {
      "time": "00:56:36",
      "text": "是就是你可以这么理解为你可以这么理解，比如说我是一台may frame，然后我有输入standard out和standard error和standard input。然后同时与此同时我有很多个dty，我连接了很多实体的机械的、电子的电传感器。然后我现在说好，我要把我的standard in a standard input连接到TTY1上。那么此时TTY1上输入什么，我就会把它接到我的standard input上。然后我说我的standard的output需要输入到TTY4上面。那我比如说DTIE，刚才说几DTIE告诉我说print hello，然后我说三个output子在TNI4上，那么TNI4这台电脑打电传打字机上就会输出hello world。对就相当于一个标准的输入输出设备，然后只不过是用软件来模拟。",
      "speaker": "发言人1"
    },
    {
      "time": "00:57:31",
      "text": "然后这个键盘的这个世界被操作系统的一个驱动捕捉到，也是转化到这个TTY的一个输入上面去，再传给内核。",
      "speaker": "发言人2"
    },
    {
      "time": "00:57:39",
      "text": "对，如果你要使用这个terminal similar emulate，就是是你如果你使用这个终端模拟器的话，但是其他的一些东西不是这样，比如说游戏肯定不是这样，游戏就是直接扫描那个影业键盘产生的中断或者是whatever work，但是跟DDY没有关系OK。对，然后到一九八几年的时候，DEC是DEC的全名叫什么来着？",
      "speaker": "发言人1"
    },
    {
      "time": "00:58:13",
      "text": "Digital .",
      "speaker": "发言人2"
    },
    {
      "time": "00:58:15",
      "text": "equation对数字设备公司研发出的这种就是用二级用阴极射线显示管做成了这个所谓的单色显示器，the terminal。我们才渐渐淘汰了人类，才渐渐淘汰了TTY这种东西。",
      "speaker": "发言人1"
    },
    {
      "time": "00:58:36",
      "text": "但是就是打纸砸到纸袋上的那种TTY.",
      "speaker": "发言人2"
    },
    {
      "time": "00:58:40",
      "text": "终于你有了一个就相当于玻璃做的这么一个电传打印机。",
      "speaker": "发言人1"
    },
    {
      "time": "00:58:46",
      "text": "所以其实他们之前那个还是挺废纸的，是吧？",
      "speaker": "发言人2"
    },
    {
      "time": "00:58:49",
      "text": "对，相当废纸。",
      "speaker": "发言人1"
    },
    {
      "time": "00:58:52",
      "text": "宅男废纸。",
      "speaker": "发言人2"
    },
    {
      "time": "00:58:54",
      "text": "你为什么也想到了这个？我刚才也想说宅男废纸。",
      "speaker": "发言人1"
    },
    {
      "time": "00:58:58",
      "text": "我那个时代已经过去了。",
      "speaker": "发言人2"
    },
    {
      "time": "00:59:02",
      "text": "对，然后玻这个。",
      "speaker": "发言人1"
    },
    {
      "time": "00:59:03",
      "text": "玻璃的TTY其实就简单来说替代了一个打印机的作用。",
      "speaker": "发言人2"
    },
    {
      "time": "00:59:09",
      "text": "对吧？错，是替代了打打印打印机带的输出。然后输入的话最大的一个优点就是你终于可以改自己的输入。早期的电传打字机，你要打错一个字符你是改不了的。输错了怎么办？这也是一个我的问题，我也不知道那个时候输错了到底是怎么办。你也许有一个建议，允许你说这钱这一行废料你回退到某个地方，然后你再重新。",
      "speaker": "发言人1"
    },
    {
      "time": "00:59:35",
      "text": "那control k对。",
      "speaker": "发言人2"
    },
    {
      "time": "00:59:41",
      "text": "我相信电传打字机上应该还是有backspace。对，back space按下去的话，到底会具体做什么呢？它不可能抹掉一个已经打好的字符，对吧？",
      "speaker": "发言人1"
    },
    {
      "time": "00:59:50",
      "text": "那我觉得应该是把内行是kill掉，然后再起一行新的重新来过。那是湘这是唯一合理的方式。",
      "speaker": "发言人2"
    },
    {
      "time": "01:00:01",
      "text": "对，看见没？这也不是重点，但最大的一个要点就是这个玻璃的terminal。虽然表面上看它是可以改的，然后可以多行显示的。但它本质上在它最底端，它还是在模拟电传打字机和这个主机交互信息的方式。也就是说电视打字机连接到了主机，并不知道它自己连接到的是一个屏幕还是一个电视打。对。",
      "speaker": "发言人1"
    },
    {
      "time": "01:00:33",
      "text": "然后最广为流行的电传打字机的型号叫做teletype model three thirty three that model 33ASR，然后我们熟知并且爱戴的账单大门先生。他就是在这台电脑上开始了他的第一次编程之旅。然后第一台电传打字机的所使用的，我们刚才提到这个奥choc copy的速率是300 beats per second。这各位可以想象一下这个速度。",
      "speaker": "发言人1"
    },
    {
      "time": "01:01:12",
      "text": "300 beats除以8，我想想不对。Beats除以8得到by没有2 38 200 43算一下。",
      "speaker": "发言人2"
    },
    {
      "time": "01:01:27",
      "text": "300除以.",
      "speaker": "发言人1"
    },
    {
      "time": "01:01:28",
      "text": "8是37.5。Bite person 30每秒钟可以打33加差不多38个字符的速率。对。",
      "speaker": "发言人2"
    },
    {
      "time": "01:01:37",
      "text": "就是我们这我们今天的show note，如果用这个30BPS的这个model来传输的话。",
      "speaker": "发言人1"
    },
    {
      "time": "01:01:47",
      "text": "大概一两小时。",
      "speaker": "发言人2"
    },
    {
      "time": "01:01:49",
      "text": "真是太不可思议。对，这种感觉就像在那个辐射里面看那个Turner一行一行往外蹦字的感觉。",
      "speaker": "发言人1"
    },
    {
      "time": "01:01:59",
      "text": "对，这个也是一个科幻片常用的一个梗，就是那个字是一行一行就是一个字出现的。这个一定是从当年他们那个电传打字机里获得灵感，看着那个字一个一个莫名其冒出来，觉得很有一种科技感是吧？其实根本就是技术限制类的对，就下次求这种什么这个科幻片，再也不要用这种特效了。",
      "speaker": "发言人2"
    },
    {
      "time": "01:02:25",
      "text": "真的实在是太low了。我的第一台猫，是我的第一只猫是28.8K的，14.4 28.8K是KK对，然后这个只有三台猫是没有case，0.3K的那种，你看就这样的吗？对。",
      "speaker": "发言人1"
    },
    {
      "time": "01:02:47",
      "text": "上BBS都嫌卡。",
      "speaker": "发言人2"
    },
    {
      "time": "01:02:49",
      "text": "上BBS那个那个时候真的是BBS没有什么，我相信那个时候的BBS.",
      "speaker": "发言人1"
    },
    {
      "time": "01:02:55",
      "text": "根本不存没网络吗？还没有网络。对。",
      "speaker": "发言人2"
    },
    {
      "time": "01:03:00",
      "text": "早期的BBS根本就是转进站。就是你你在离线的状态下写好信，读好信，然后连线把所有需要收和发的信一次性收和发，然后再立现在读你刚才收到了什么，然后写你要写的这其实是很离散的一种状态，像现在这种instant messenger真是不可想象的东西。对。",
      "speaker": "发言人1"
    },
    {
      "time": "01:03:24",
      "text": "Anyway, 然后时光光阴荏苒，我们来到了unix时代，在贝尔实验室和MIT和这个通用电器里面的通用电器的实验室里面出现了一种操作系统叫做multis，应该是multiple time，就什么多用户分时系统这么一个东西。然后它的后对，在那个时代还是使用这个电子打字机的。但是到unix的时代，基本上已经全都切换到了，带显示器的terminal。然后在terminal时代terminal出现的时代，人们延续了这个multis里面的一个概念，就是这个shell的概念。要不你来解释一下什么是shell。Shell跟kernel的关系我们的节目叫做kernel panic，但是我们今天这一期在讲shell，然后两者的关系可对。",
      "speaker": "发言人1"
    },
    {
      "time": "01:04:23",
      "text": "因为这样有内核有核儿的话，就会有一个可吧核是执行那些实际的程序的。可以这么说，然后需要其实是就是给用户用于要用于用户和这个内核交互的一个工具，对吧？对，就有点。然后笑着你说。",
      "speaker": "发言人2"
    },
    {
      "time": "01:04:41",
      "text": "然后笑着。",
      "speaker": "发言人1"
    },
    {
      "time": "01:04:42",
      "text": "主要的功能就是什么呢？就是让用户输入命令，然后传给科尔去执行，然后再把这个执行的结果再再展示给用户，就通过这个TTY这个电传打字机接口。",
      "speaker": "发言人2"
    },
    {
      "time": "01:04:58",
      "text": "对呃那我觉得shell这个名字其实最开始的时候我接触会觉得它有点迷惑性。因为shell在它的所指上面，其实是专门指用跟用户输入输出的执行脚本的一这么一个小工具。然后这个工具它跑起来的时候，会让你可以通过命令行来跟内核打交道。但实际上如果你去专门追究他这个名字的话，那kernel跑在这个核心层，但并不是所有跑在外层的都是shell，对吧？",
      "speaker": "发言人1"
    },
    {
      "time": "01:05:37",
      "text": "对，因为还有那个users.",
      "speaker": "发言人2"
    },
    {
      "time": "01:05:39",
      "text": "还有其他一些程序。这些程序可能不会直接跟你打交道，也可能会跟你打交道。但是他们在跟你打交道的时候，并不会被被称为shell。如果早期比较迷惑这件事情。",
      "speaker": "发言人1"
    },
    {
      "time": "01:05:52",
      "text": "但是所以shell类比于图形层的话，应该是属于哪一层？应该是属于这个故意的那些那些这些组件。",
      "speaker": "发言人2"
    },
    {
      "time": "01:06:02",
      "text": "那一层应该是，对，应该可以理解。",
      "speaker": "发言人1"
    },
    {
      "time": "01:06:05",
      "text": "大致可以这么对应起来。",
      "speaker": "发言人2"
    },
    {
      "time": "01:06:07",
      "text": "但是当然这个故意的层层级乃至于抽象的复杂程度都要比这要高的多。",
      "speaker": "发言人1"
    },
    {
      "time": "01:06:16",
      "text": "对。",
      "speaker": "发言人2"
    },
    {
      "time": "01:06:17",
      "text": "然后这个早期的shell也是面向行的。因为shell的一个功用就是让你在terminal上可以跟这个远程机交互。而所有的交互都因为早期电商打击的影响，被限制为一行。所以在早期的shell里面，你也是大部分时候你是通过一行来输入命令行。",
      "speaker": "发言人1"
    },
    {
      "time": "01:06:37",
      "text": "Unix早期作者之一，就是我们上一期提到这个大名鼎鼎的conomo son。他在写unix的时候也沿用了这个shell的这个称呼。但是conomo所写的shell要比mult shell多很多特征。比如说一个最早期的最最重要的特征之一就是所谓的输入输出重定向，对吧？我们不管是dos用户还是类似用户应该都很熟悉。如果你用命令行的话，你一定会知道，你可以把一个文件的内容当做某一个命令的输入，传给这个命令，或者把这个命令的输出转化为一个文件，对吧？然后这个特征是通过大于号小于号来实现。",
      "speaker": "发言人1"
    },
    {
      "time": "01:07:21",
      "text": "然后这个功能在最开始的时候就是肯thomson所写的第一代的unix shell一个功能。这是1971年的视频。可能所以你每一次在做输入重定向的时候，你就在使用一个1971年就有的一个功能，想想还是挺特别的。然后后期kinder person的shell也多了，就是type这个功能。就是我们今天会管道服，对，会经常说另命令行最强大的功能之一就是管道服务，对吗？你可以把员工你可以把一个命令的输出重新也是重零相对通过管道符重定向到另外一个程序的输入。然后这个特征也是在confirmation所写的他所写的shell里面就已经出现了。",
      "speaker": "发言人1"
    },
    {
      "time": "01:08:11",
      "text": "然后1979年的时候，unix的version 7简称V7发布了，然后再随着V71同搭载。这个share叫做ball shell，作者是应该是艾薇委员的作者之一，叫做Stephen born。为什么这个share没有都没有被叫做b shell呢？就是他直接就在延续了condonation所写的这个shell的名字，叫做SH然后因为他是。",
      "speaker": "发言人1"
    },
    {
      "time": "01:08:44",
      "text": "向后兼容的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:08:47",
      "text": "但是也是往前走的。但可能在这个时候，这个给sham重命名的风气还没有流行起来。我觉得所以直到今天，这个born shell一直也是世界最为广泛使用的share之一，因为45V7是一个非常成功的unix版本，很多后世的unix变种也都是一个V7微月蓝本。",
      "speaker": "发言人1"
    },
    {
      "time": "01:09:11",
      "text": "直到今天包括你的包括你的你手上的麦克，你你面前的麦克，你手上的iphone，还有你你的android，全都有slash bin slash SH这个东西。这个东西是从1979年开始就已经存在于很多很多计算机系统里。对，然后从system v7开始，我们有了这个posting标准。然后poses标准也定义说shell必须存在于flash in flash SH下面，然后所有符合这个标准的shell也会被叫做SH所以也就是说当某个人说这个shell是SH compatible的时候，它会它所指的意思实际上就是指跟我们上刚才提到这三种shell是互相兼容的。但如果你一定要非常精确的说一个shell是符合pox的所有标准的话，你应该说它是posix shell。",
      "speaker": "发言人1"
    },
    {
      "time": "01:10:15",
      "text": "然后在1978年的时候，又开始了另外一个shell的研发工作。这个作者是另外一位，我们之前也提到过的Billy joy。然后他Billy joy写过什么呢？快速问答毕业照也写过什么？其实VII就不是VI，是VI就是最早期的那个V编辑器，他还写了一个shell叫做c shell。然后c shell的一个卖点就是shell这个东西，就是我们如果你不用c shell的话，你我我说你会感觉到shell的这个语法跟CE离得很远。",
      "speaker": "发言人1"
    },
    {
      "time": "01:10:59",
      "text": "但是在c shell诞生那个年代，unix基本上全都是用C来写的。Unix不管是用户程序还是unix x本身都是用C来写的。所以CCL的一个设计的理念，就是希望能够让shell的语法尽量接近于C的语法。当然我们在今天来看，可能CHL的语法并不那么接近适应。但是在80年代你会觉得我靠这个东西真的是跟写字语言太接近了。",
      "speaker": "发言人1"
    },
    {
      "time": "01:11:29",
      "text": "但是我which is the good which was a good thing。",
      "speaker": "发言人2"
    },
    {
      "time": "01:11:32",
      "text": "但是今天我们会觉得说，我靠为什么一个语言一个shell script，是不是要写的跟C一样？这不是自寻烦恼。但是那个时代如果你的电脑上只有C你也只会你也只学过C的话，你会觉得可以用像写资源一样来写shell crept，这是很爽的一件事情。",
      "speaker": "发言人1"
    },
    {
      "time": "01:11:50",
      "text": "然后CCL的有很多非常多的创新，比如说history，就是你现在在命令行下面打history，你会看到自己输入过的所有的命令，以及你比如说你打刀知道吗？感叹号你会重复前一条命令，乃至于你打比如说门刀的下划线，会把刚才上一条命令的那个所以最后的参数argument重新用过来。这一切都源自于CHL，是CHL创造history这个东西。",
      "speaker": "发言人1"
    },
    {
      "time": "01:12:28",
      "text": "然后也是从C上开始，人们有了job control。就是你在dot下面可能没有遇到过这种东西。就是dos早期不是多任务的，你不可能。",
      "speaker": "发言人1"
    },
    {
      "time": "01:12:40",
      "text": "再到不是整的那个可以把它。",
      "speaker": "发言人2"
    },
    {
      "time": "01:12:44",
      "text": "但是在u linux unit下面，你从很早的时候就可以开始。比如说你正在压缩一个什么东西，然后它需要一段时间，你可以按control加Z让它进入后台，然后用BGM让他在后台继续执行，然后因为在前台做一些别的什么东西，因为同时进行很多这样的工作。比如说我现在用vim的一个习惯，就是写到一半，然后control加Z1，然后去干点别的，然后在FG把那个弄回来，对吧？然后这个功能也是在CCL里面被比例状态实现的。",
      "speaker": "发言人1"
    },
    {
      "time": "01:13:18",
      "text": "我一直有点好奇刚才那个场景，我一般是说再开一个新的窗口或者tap来实现，就是用那个就放入后台，这个我还真的挺少用，OK我还蛮常用的。但如果说你的这个系统是一个单，如果你是一个远程系统的话，比如说然后你只能就你再开一个窗口也可以，但你再开一个SSH连接可能会要等一下。",
      "speaker": "发言人2"
    },
    {
      "time": "01:13:43",
      "text": "对这个问题的解法其实就是三种，一多任务，2t mos就是所谓的multiplexing，就是终端应用，可以在一个终端里面开很多小终端的窗口。这是一个比较重要的奇技淫巧，就一定要学起来。然后在第三个方式就是你再再建立一个连接好，然后对个人是比较倾向于这个第一种，因为一个时间只做一件事情。",
      "speaker": "发言人1"
    },
    {
      "time": "01:14:09",
      "text": "就会比较好一些。OK这个事我也养成这个习惯会比较顺畅一些。",
      "speaker": "发言人2"
    },
    {
      "time": "01:14:15",
      "text": "对，而且其实就是早期有很多我也曾经试图把vm配置成一个IE因为什么在wam里面就直接执行程序或者是什么。",
      "speaker": "发言人1"
    },
    {
      "time": "01:14:25",
      "text": "其实都是徒劳。",
      "speaker": "发言人2"
    },
    {
      "time": "01:14:26",
      "text": "对那你为什么你不直接干脆把命卦起来，然后在命令行下面做你该做的事情，然后该回去的时候回去了，对吧？扯远又扯远了，然后回到我们的历史课，这次的历史真的要讲好久。哼刚才说CCL，CCL还有一些别的一些新的创新。比如说two notation，就是你在你的home进入。",
      "speaker": "发言人1"
    },
    {
      "time": "01:14:52",
      "text": "夹目录。",
      "speaker": "发言人2"
    },
    {
      "time": "01:14:53",
      "text": "你的比如说你的home，你的目录是slash home flash TWTAW，然后我可以一个波浪号来代替这个目录。诸如此类的还有什么drawne，就是比如说你要在同一行上面运行两个程序，你可以用一个分号把它们分开说，运行第一个，再运行第二个，或者你可以用两个m percent把它们连起来，就是说如果第一个成功了才运行第二，或者你可以用两个用一个pipe，比如说就只有第一个失败了才会运行第二个之类。这些都是代表or对，这些都是在c shell里面的发明。这个跟C很像，对吧？",
      "speaker": "发言人1"
    },
    {
      "time": "01:15:33",
      "text": "M percent m percent排排都是来源这个C对，然后到了1980年的时候，我们有了k shell，corn shell是在这个时候应该是把贝尔实验室在专门为unix发行。然后这个时候恰逢所谓的unix great war，是在unix的史上历史上曾出现过一系列的。因为版权法和商业化的引发了一系列诉讼和口水仗，因此也是因也是因此这个一片形势一片大好，unix分裂了，给了这些什么微软这种公司的可乘之机。",
      "speaker": "发言人1"
    },
    {
      "time": "01:16:19",
      "text": "在这个时代出现了KHL，就是corn shall。他的作者叫做作者叫什么人？对。",
      "speaker": "发言人1"
    },
    {
      "time": "01:16:27",
      "text": "他是David day cn .",
      "speaker": "发言人2"
    },
    {
      "time": "01:16:29",
      "text": "OK以科尔来命名的。然后科尔也有一些新的，也有一些创新，但是没有C上那么多。而且KHL永远从来没有流行起来，只有这个和unix的一些官方版本还在用。那个时候BSDE就专门避免使用它，因为这个KHL的源码当时是没有自然发放的。然后当linux兴起的时候，KCL更是没有人理，他们直接就用了这个geno bash。对，然后当这个linux兴起的时候，自由软件基金会也专门把SH重新开发了一遍，可以理解为然后把它命名为born shell，就专门凑bash这个词。Bash的英语名是厮打还是说之类的一个词。我是也是在接受拜事很久之后才意识到它居然是一个英语名词，而不是一个一个命令之类的那我们来看。",
      "speaker": "发言人1"
    },
    {
      "time": "01:17:33",
      "text": "一下他的这个官方示意是什么？Bash strike hard and violent.",
      "speaker": "发言人2"
    },
    {
      "time": "01:17:41",
      "text": "凶狠的厮打。",
      "speaker": "发言人1"
    },
    {
      "time": "01:17:43",
      "text": "凶狠的击打，就是叫有两个字叫暴奏OK。",
      "speaker": "发言人2"
    },
    {
      "time": "01:17:47",
      "text": "各位使用这个暴揍暴揍暴揍和暴揍外壳暴揍外壳。暴揍外壳是我们目前计算世界里面最常常见的一个外壳。如果你是用OS ten的话，或者是你你是用一个linux的话，那你很有可能是在用你是在用bash。当然不一定。对，因为五本土在前一阵子把它的默认是要改成了dash。我也是又改回来了。没有，是这样的，不是我们，但是debian对，debian把这个脚本执行的shell转化成了dash。但是用户所那个slash .",
      "speaker": "发言人1"
    },
    {
      "time": "01:18:27",
      "text": "bin slash shell的实际是dash提供的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:18:31",
      "text": "对，但是用户所使用的这个love in shell还是dash，应该是这样。对，但是说但是集中了原有的b shout，然后CCL和CCL的优点。这也就是为什么。",
      "speaker": "发言人1"
    },
    {
      "time": "01:18:46",
      "text": "我们刚才提到一个家的之所长。",
      "speaker": "发言人2"
    },
    {
      "time": "01:18:48",
      "text": "这也就是为什么我们刚才提到的大部分功能，你会说我的shal里面也有，就是你不需要使用CHL才有job control。为什么？就是因为bash把job control也挪移移移过来，对吧？对，但是大部分这些shell在如果是一个脚本，你写一个share脚本，然后你在之前就写说了hash bang，然后slash bin slash essays的话，他们还是会默认去伪装，把自己伪装成一个shell，然后只提供摄像，能够提供。",
      "speaker": "发言人1"
    },
    {
      "time": "01:19:21",
      "text": "那些对基本功能，就不提供一些比如说bash的一些特定的语法这样的对。",
      "speaker": "发言人2"
    },
    {
      "time": "01:19:27",
      "text": "然后在这个system 5 release 4也是unix的历史上一个非常重要的版本。里面又出现了一个叫做on quest shell，然后它的缩写就是ash。然后它的的设计理念是说要把这个shell做的非常精巧简单。后来这个on quest ARM quest shell也被进一步改进，就形成了dash。我们刚才提到的dash这个东西，它是一个比较经典版的share，专门拿来运行脚本程序。",
      "speaker": "发言人1"
    },
    {
      "time": "01:20:07",
      "text": "那个dash那个D是debian吗？",
      "speaker": "发言人2"
    },
    {
      "time": "01:20:09",
      "text": "Deby ash.",
      "speaker": "发言人1"
    },
    {
      "time": "01:20:11",
      "text": "应该是这么来的对，我记得应该是这样的，就是有前面有那个ash ASH，然后是dash叫devan van。",
      "speaker": "发言人2"
    },
    {
      "time": "01:20:22",
      "text": "对，行，他也是为了凑这个，也是为了凑dash。这个dash是一个冲快速前冲小跑。对，小跑外壳刚才我们介绍了猛鸡外壳，然后又小跑外壳。",
      "speaker": "发言人1"
    },
    {
      "time": "01:20:37",
      "text": "把把我揍了。",
      "speaker": "发言人2"
    },
    {
      "time": "01:20:39",
      "text": "抱住那个。",
      "speaker": "发言人1"
    },
    {
      "time": "01:20:41",
      "text": "小胖。",
      "speaker": "发言人2"
    },
    {
      "time": "01:20:43",
      "text": "来OK。",
      "speaker": "发言人1"
    },
    {
      "time": "01:20:46",
      "text": "还有其实还有一些比较不常见，比较诡异的需要来着提一下。",
      "speaker": "发言人2"
    },
    {
      "time": "01:20:50",
      "text": "可能比如说PSH pro shell，就是你可以在shell里面使用perl这种奇怪的语言来完成一些普通SH做不到的事情，或者是哼样式。",
      "speaker": "发言人1"
    },
    {
      "time": "01:21:06",
      "text": "就鸭跟鸭一样。",
      "speaker": "发言人2"
    },
    {
      "time": "01:21:07",
      "text": "Another shell is a positive component command line shell written by ventana bear. UK一个日本人，然后他的实现的初衷是教大家用C语言来写一个sap本来是一个教学项目，但是后来又被哼后来又重新改写了。目的是要成为最basic兼容的一个shell，世界上最positive eline a complained shell in the .",
      "speaker": "发言人1"
    },
    {
      "time": "01:21:36",
      "text": "world都不知道这照片是好事还是坏事。",
      "speaker": "发言人2"
    },
    {
      "time": "01:21:38",
      "text": "What's the point? 所以这就是为什么没有人用雅视的原因。对，刚才提到一个重要概念就是说SH compatible。就是你会说。",
      "speaker": "发言人1"
    },
    {
      "time": "01:21:50",
      "text": "兼容shell，你会说这个shell是特指，不是一泛指的一个笑，是特指最开始那个那个最早版本那个笑没错。兼容那个是什么意思？",
      "speaker": "发言人2"
    },
    {
      "time": "01:22:02",
      "text": "这也是我们推荐在在这有没有推荐这个stack exchange的unix的板块上面的一个答案，写的非常好。然后这个答案里面还顺带的介绍了在不同系统里面这个BNSH所指向的东西是什么。比如他说在30里面，那可能这个bin SH就是默认的original born shell。然后你可能在这个linux里面可能会是GU bash，然后你在open BS里面可能会所使用的是一个KSH93。With positive extensions，whatever me这个答案也是推荐大家读一读。好了，大概历史就讲到这儿。然后你讲。",
      "speaker": "发言人1"
    },
    {
      "time": "01:22:53",
      "text": "现状了吗？",
      "speaker": "发言人2"
    },
    {
      "time": "01:22:55",
      "text": "时光机且快进到2010年，或者说21世纪的第一个十年已经过去了，我们还是在使用CL只不过今天我不知道real你，但是我所使用的shell是一个叫做z shell的东西。我也是OK.",
      "speaker": "发言人1"
    },
    {
      "time": "01:23:15",
      "text": "我这里可能要说一下刚才提的各种刚才提了各种各样的乱七八糟的效率好几种。但其实经过这么多年这个系统变迁，对，现在剩下来的也就那么几个了。一个算是绝大多数的linux发行版和像OS也是默认使用的这个bash，然后有一小撮需要死忠粉在坚持用的一个ZZSZ这怎么念ZH呢？还有就是在一些精简系统上或者是嵌入式系统上。像这样一个busy box里面自带的那个应该是那个应该是H对。",
      "speaker": "发言人2"
    },
    {
      "time": "01:23:57",
      "text": "那个是H就是你在比较简普通的或者说功能比较低下的不需要经常交互的操作系统里面，基本上就提供一个ash就够了。对。",
      "speaker": "发言人1"
    },
    {
      "time": "01:24:07",
      "text": "就复杂度比较那个的复杂度也比较低，适合在那种资源比较有限的系统上实现。先说这个western，因为我们这个常用的主机都是这个western现在版本里面起码是是是自带两个需要的，一个是dash，一个是这个ZZH。对，有一个什么问题呢？因为bash从4.0开始，对AOSN自带的版本，bash的版本特别老，原因是因为bash 4.0开始，他们切换到GPLV3，应该是的这个授权协议。然后这个跟OSN这个商业不开源产品是有冲突的。所以他们没指的就是OSSN搭载的这个bash可能永远只能停留在三点，就是大版本号是三的这个版本系列没有办法再进步到这个四了。对，但是SN还自带了一个zh。Zeh使用的应该是BSD协议。",
      "speaker": "发言人2"
    },
    {
      "time": "01:25:05",
      "text": "这是BSD协议。",
      "speaker": "发言人1"
    },
    {
      "time": "01:25:07",
      "text": "确认一下，确认一下，我记得是BSD协议。对，不是ZZH是MZH是MIT协议的，而且类MIT协议的它更灵活一些。所以S3还是可以继续搭载它最新版本，基本上OSN搭载的最新版本都离大家的版本，离最新版本一般都只差一两个小版本。好，挺好，而且认识也更新不是那么勤，所以还好。",
      "speaker": "发言人2"
    },
    {
      "time": "01:25:41",
      "text": "对，最新一版的ZH是5.1，2015年8月30，两个月前了，所以就还好。如果你还是坚持要用bash的话，那基本上推非常推荐你的一点是可以home不如再装，赶紧用home，不如装一个新版的bh如果你是一个初学者的话，然后你可能暂时说我要保守一点，先从一个源流比较古早的东西开入手的话，因为我相信大部分的linux的这个教程上面也会用bash作为主要的教学工具。那你可以。",
      "speaker": "发言人1"
    },
    {
      "time": "01:26:15",
      "text": "对，因为默认是那个，所以最好是先zh的来历是怎么样子？",
      "speaker": "发言人2"
    },
    {
      "time": "01:26:21",
      "text": "这是是1990年是1990年的时候的一个叫做l Fosters。Sorry，faster是那个。",
      "speaker": "发言人1"
    },
    {
      "time": "01:26:32",
      "text": "你为什么要笑？",
      "speaker": "发言人2"
    },
    {
      "time": "01:26:34",
      "text": "Here of the storm里面一个骑士队的哥们儿，他是他在魔术师界面，应该是在hinton and辛特兰的那个施救城堡里面的大的主管就叫Foster OK抛Foster写脑中想，脑中浮现出了一个矮人骑在狮鹫上打电脑的场景。然后他在1990年的时候读普林斯顿，他是一个学生，然后他的导师叫做邵中中，一个华人是一个好是个华人。然后邵中的登录名叫做ZSH中少对吧？就是先名后姓。然后他觉得这个名字很屌，就用z shell来当作自己写的这个shell的名字，ZSH来当做自己写的这个shell名字。但是ZZ shell和c shall也是押韵的对吧？对，是这么来的。然后他出于某种原因把它做的非常的复杂又强大。我觉得肯定是就觉得已经到了90年代了，我们应该给这个古老的。",
      "speaker": "发言人1"
    },
    {
      "time": "01:27:45",
      "text": "与时俱进就做。",
      "speaker": "发言人2"
    },
    {
      "time": "01:27:47",
      "text": "所以做了非常多的优化。比如说它提供了extensive的输入提示，就是你在输入命令的话，你在办事下面按tab，你可能只会得到tab就是OK在bh下面输入一个命令的一半，按tab它会补全到什么地方位置补全到他能够第一个字符。",
      "speaker": "发言人1"
    },
    {
      "time": "01:28:18",
      "text": "就是有有歧义的第一个。",
      "speaker": "发言人2"
    },
    {
      "time": "01:28:20",
      "text": "字符会补全到第一个歧义为止。然后z shell则会列出所有可能命令，在你那个那个当前行下面列出所有可能命令。然后z shell还会就像那个google一样，会问你说，如果你输错那个命令的话，他会问你说你是不是是想要执行另外一个命令。但有时候这个挺讨厌的，但是就还带了一个auto correction的correction功能，但是我们现在都用fuck了。",
      "speaker": "发言人1"
    },
    {
      "time": "01:28:48",
      "text": "如果我们待会儿提到法这个东西，然后他还可以做一些比较神的事情。比如说你要SSCP到一个远端的服务器上，在bash里面你必须记住远端的服务器的命令，那个路径是什么路径。但是在z shell里面你只要不停的按tab，它会帮你补全远程服务器上的路径。这也是很屌的，很实用又很屌，非常的黑魔法。另外就是我个人最喜欢的一点就是它可以在屏幕的右侧显示一个promote，在右侧有一个提示符，这个还对标准状态。",
      "speaker": "发言人1"
    },
    {
      "time": "01:29:26",
      "text": "下一般都只有在左侧提示。因为那个那个字符串的这个就补齐的方式是这样子。然后如果你要在右端，你要做一些额外的事情，要rejoin之类的对吧？对。",
      "speaker": "发言人2"
    },
    {
      "time": "01:29:39",
      "text": "这个还就有时候有那些不那么重要的信息，你放在右边还是比较有比较好。比如说我会我现在在右边放当前的时间。用户名主机，然后是那个python virtue n environment的的名称。对，然后左边就只放目录和一个大于号的提支付，觉得还蛮蛮方便。",
      "speaker": "发言人1"
    },
    {
      "time": "01:30:04",
      "text": "所以这里其实要说一点，就是说刚才讲的那个ZHL的大部分这种高级特性，其实在后来的这个新版本的bash里面，也通过各种各各各种各样的方式能够逐渐实现了。对，所以在feature就是什么呢？就是在特性的完成度上，现代版本的Z一和现代版本的bh相差不大的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:30:26",
      "text": "但是在90年代，ZGL的很多特性是现代的，是那个时候的办事用户不可想象。这就是为什么从90年代开始有了一大堆Z一拥趸。然后一直到今天，在大概在2010年前后，出现了一个叫做oh my ZH的项目。",
      "speaker": "发言人1"
    },
    {
      "time": "01:30:50",
      "text": "是一群这是一个由社区维护的ZH的配置和插件的一个集合。",
      "speaker": "发言人2"
    },
    {
      "time": "01:30:56",
      "text": "对，就是如果你去装一个oh my ZH的话，给你很多很多东西。这就只需要改一个小小的配置文件里面的一行就可以用到。",
      "speaker": "发言人1"
    },
    {
      "time": "01:31:05",
      "text": "你就可以有一个很很帅很酷的这么一个命令行的提示法。",
      "speaker": "发言人2"
    },
    {
      "time": "01:31:10",
      "text": "对，比如说它里面提供了几百种主题，你随便改一改，你会觉得你会就会让这个不明就里的人看到，我靠你在搞什么？这是什么东西看起来好贵。",
      "speaker": "发言人1"
    },
    {
      "time": "01:31:23",
      "text": "当然所以我有一个问题问你，就是为什么你要从bash切换到z sh？",
      "speaker": "发言人2"
    },
    {
      "time": "01:31:30",
      "text": "其实我犹豫过很久，就是我在两者之间反复跳跃了很多次，OK。",
      "speaker": "发言人1"
    },
    {
      "time": "01:31:38",
      "text": "但是你的你最终要去做这个选择的原因是什么？",
      "speaker": "发言人2"
    },
    {
      "time": "01:31:43",
      "text": "最终选择的原因还是因为他的心疼心太多了，或者说对于我来说，他的killer feature就是右边的这个promote。",
      "speaker": "发言人1"
    },
    {
      "time": "01:31:55",
      "text": "对，这个好像在batch里面，还现在为止都还比较难实现。",
      "speaker": "发言人2"
    },
    {
      "time": "01:31:58",
      "text": "在大事面前不可能做到这样。其他的其实也没什么，因为我现在的特状况其实是我在办公室会用bash，在公司是会用bash，然后回到家用自己在对。",
      "speaker": "发言人1"
    },
    {
      "time": "01:32:14",
      "text": "其实这两个的语法在大部分情况下是兼容。",
      "speaker": "发言人2"
    },
    {
      "time": "01:32:17",
      "text": "在99%的情况下，你是感觉不到差别的。只是有时候你在这下面会觉得非常方便。比如说我刚才提到这个命令的问，在bh下面你可能要tab很多次，然后才能找到自己需要找的那个。但是在zh下面你可能就tape一次，然后看一看你就知道你想要什但是除此之外，其实这次的带来的改进并没有太多。应该这么说，在公司里面我基本不会觉得这里如果我是在用Z10就好了。",
      "speaker": "发言人1"
    },
    {
      "time": "01:32:47",
      "text": "这就是为什么后来我曾经很多次切换回bh就在自己的电脑上面。因为总觉得这只是一个no就no standard的东西，就要加引号，这是当然也非常常见，但是没有没有像bash就是到处都有，对吧？我为什么要依赖于这种其实没有那么多便利的东西呢？但后来还是觉得可能方便一点，何必？",
      "speaker": "发言人1"
    },
    {
      "time": "01:33:18",
      "text": "就是我我我切从bash切换到zeh的原因比较简单。就是我当时做了一个大H的一个promote一个小代码小脚本，就是定自定义这个就是自己定制化这个bash的那个提示服。然后我发现这个bash的就是那个bash power line在github上应该是最被新标的最多的一个report是吧？就可以实现。比如说以一种看起来还挺帅的方式显示。比如说你如果你这个目录是有git的话，它会显示那个gate的这个branch的名字。它会显示说你有多少个commit就是ahead或者是behind远端。然后它可以显示根据你上一条命令的执行的结果是正常还是异常，它会显示是绿色或者是红色这样一些比较花俏的功能。",
      "speaker": "发言人2"
    },
    {
      "time": "01:34:14",
      "text": "OK然后在做的过程中就发现其实那个bush的那些语法是比较坑爹的，就很就就比较首先不是太一致，然后也不太好记，每次都要去折腾半天到底怎么去写，去查半天到底怎么去写。就是他语法比较inconsistent，说然后zeh的那个就会好很多，所以我最后就切到zeh上面。当然还有一个很重要的原因，就是刚才讲的那个OSN自带的这个版本比较新。然后我又是我现在遵循的一个哲学，就是能不折腾就折腾。我不想再home，不如再装一遍bash的，然后再剔掉这样。",
      "speaker": "发言人2"
    },
    {
      "time": "01:34:50",
      "text": "对，没错，对，其实我刚才想说，这也是ZHL有很多他设立之初想要达成的目的之一，就是用ZHL写的sale script，或者说用使用了ZHL的扩展，哼而不是纯粹的shell SH compatible的shell script应该要为bash写的更易读更一些，而且更优雅一点。应该可以，应该使用优雅的这个词在这儿。但是很遗憾这一点并没有铺开来。就是这世界上大部分的share script还是要么是shell，要么是bash，还是很少有人在用写z shell ZSH的shell script可能要比CC0。",
      "speaker": "发言人1"
    },
    {
      "time": "01:35:41",
      "text": "如果写script的话，其实还是用最基精简的那个shell的语法会通用性会强一点。",
      "speaker": "发言人2"
    },
    {
      "time": "01:35:48",
      "text": "但是很多人会觉得说，比如说bash的一些扩展，比如说双双的双方括号，方括号比那个单括号要能够表达语义，实现功能多一些，对吧？所以很多人会选择用shell，用bash来显示e scoot，但是这个数目还是要远远多于用ZZL来写，这一点还是很挺遗憾的。我觉得。",
      "speaker": "发言人1"
    },
    {
      "time": "01:36:15",
      "text": "那倒是。",
      "speaker": "发言人2"
    },
    {
      "time": "01:36:16",
      "text": "其实除了这些。",
      "speaker": "发言人1"
    },
    {
      "time": "01:36:18",
      "text": "比较正统的需要之外，也有一些比较新的尝试，最近几年出现的就是说为什么要有那么多的历史包袱？假设我们不考虑向后兼容性。",
      "speaker": "发言人2"
    },
    {
      "time": "01:36:29",
      "text": "如果抛开这个SH compatibility这个历史包袱的话，那现今天的时候真是可以各种各样。",
      "speaker": "发言人1"
    },
    {
      "time": "01:36:37",
      "text": "对，其实其中比较著名的就是这个叫做fish的，这个鱼可算是。",
      "speaker": "发言人2"
    },
    {
      "time": "01:36:41",
      "text": "用的最多的一个。",
      "speaker": "发言人1"
    },
    {
      "time": "01:36:44",
      "text": "最重shell.",
      "speaker": "发言人2"
    },
    {
      "time": "01:36:46",
      "text": "不兼SH不兼容我们shell了。",
      "speaker": "发言人1"
    },
    {
      "time": "01:36:48",
      "text": "对对对。",
      "speaker": "发言人2"
    },
    {
      "time": "01:36:50",
      "text": "所以你有日常在用吗？",
      "speaker": "发言人1"
    },
    {
      "time": "01:36:53",
      "text": "我有一段时间才把它用当做主力设备来用，它确实挺方便的。它很多特很多叫做modern feature，很多现代的特性。比如说有就是有这个语法高亮的命令，对你会输入的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:37:07",
      "text": "有时候你会产生一种我在用一个ID的这种错觉。就是比如说你打一个你打个ISLS，然后它会把IOS所能显示的所有参数，所能使用的所有的参数显示在你当前航母下。对。",
      "speaker": "发言人1"
    },
    {
      "time": "01:37:22",
      "text": "然后他就是还有一些像那个自动补齐的下拉列表，还有各种各样的这种一些很很好的特性。甚至还有一个它好像这是一个网页版本的什么东西来的问题。",
      "speaker": "发言人2"
    },
    {
      "time": "01:37:32",
      "text": "它的那个主题是可以通过CSS还是什么的一个东西来来来。",
      "speaker": "发言人1"
    },
    {
      "time": "01:37:39",
      "text": "对，它的配色也是很很好。要说到配色要讲256色那些。其实在校里面打出有颜色的字这件事来说还是挺麻烦的对。",
      "speaker": "发言人2"
    },
    {
      "time": "01:37:49",
      "text": "有时候你可能会觉得说，我靠，现在已经60年过去了，我居然还是不能在终端之下。",
      "speaker": "发言人1"
    },
    {
      "time": "01:37:57",
      "text": "要方便的搞出颜色，让用户看到。",
      "speaker": "发言人2"
    },
    {
      "time": "01:38:00",
      "text": "我希望能看到的颜色就这么难。",
      "speaker": "发言人1"
    },
    {
      "time": "01:38:04",
      "text": "对，就像也要吐槽的一件事儿。",
      "speaker": "发言人2"
    },
    {
      "time": "01:38:07",
      "text": "对，就是如果你使用item，然后你要把让想让item看起来漂亮一点的话，一定会折腾你一定折腾过这个配色方案这个东。但是如果你折腾的话，你会觉得我靠这真是一个巨大的坑。用的这。",
      "speaker": "发言人1"
    },
    {
      "time": "01:38:20",
      "text": "这个话题我们估计这里不能展开。",
      "speaker": "发言人2"
    },
    {
      "time": "01:38:24",
      "text": "不然就觉得我靠为什么历史的这个枷锁一直到60年代好像还套在我的头上，我为什么要去去去在意什么十六色、256色之类的东西。那没错，而在fish这边就没有这个问题了，你想用什么颜色就用什么颜色，因为它不需要去做兼容性。",
      "speaker": "发言人1"
    },
    {
      "time": "01:38:45",
      "text": "对，当然了除开我们刚就刚才讲的以上所有shell都是一个叫做类unix系统的上面使用的shell。但其实还有一些大家比较常见的笑，但更没有提到。",
      "speaker": "发言人2"
    },
    {
      "time": "01:39:00",
      "text": "其实我们刚才说过了，但是这个东西首先dos promote从来不会把自己叫做一个把自己称为一个shell.",
      "speaker": "发言人1"
    },
    {
      "time": "01:39:08",
      "text": "叫做shell，它叫promotion。然后在这个东西怎么进在现在的windows里面，你打开这个开始菜单，搜索CMD，他也会出来一个命令行。他他中文叫什么来着？就是告诉这叫命令行窗口，就中文版的他那个那个那叫是吗？OK然后你打开就会出现一个黑黑不拉几的窗口。然后就可能里面最多人跑的两条命令，一个是叫做IP conflict，看自己的这个IP地址。然后第二就是ping然后第三个可能还就是那个了，就是NS look up查那个DNS运作这些比较大于DIR的列表的一些作用，这个可能现在用的越来越少。",
      "speaker": "发言人2"
    },
    {
      "time": "01:39:54",
      "text": "想想还挺讽刺的。你在这样一个时代连看检测自己能不能连接到另外一台计算机的最常见的方法，居然还是就是不能使用一个源自于电传打字机时代的那一个特征，一个命令行窗口来输入一台输入一个70年代的工具的名字。",
      "speaker": "发言人1"
    },
    {
      "time": "01:40:19",
      "text": "历史的包袱还是很沉重。",
      "speaker": "发言人2"
    },
    {
      "time": "01:40:21",
      "text": "就是在过去的四五十年里面，居然没有一个方法能够替代它。",
      "speaker": "发言人1"
    },
    {
      "time": "01:40:28",
      "text": "当然也有一些像windows上也有一些比较晚进的新鲜的东西了，这个叫做power shell。Power shell应该是在windows 7还是vista的时候。",
      "speaker": "发言人2"
    },
    {
      "time": "01:40:39",
      "text": "才觉得NT时代就已经开始研发了。",
      "speaker": "发言人1"
    },
    {
      "time": "01:40:43",
      "text": "我没有用问题，我印象中只有在vista或者windows 7里面见过它。",
      "speaker": "发言人2"
    },
    {
      "time": "01:40:47",
      "text": "然后power shell是个什么东西呢？就是一个windows在早期会觉得说，我靠这个故意难道不是一统天下的东西吗？我为什么要去搞命令行里头？但是后来他们一到命令行，其实生命命命令行就像野草一样，或者就像像像底层的命令行。",
      "speaker": "发言人1"
    },
    {
      "time": "01:41:06",
      "text": "还是非常有用的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:41:08",
      "text": "自己为什么有细菌一样，然后永远活着对吧？那他们发现没办法，我们也得搞一个程序员，能用也好。",
      "speaker": "发言人1"
    },
    {
      "time": "01:41:15",
      "text": "但是他们就，对我想起这个是windows NT的那个服务器的那些延伸过来。因为当时好像他们提了一个口号，是说所有能够在就所有通过图形界面能做的对这个windows NT的操作，都可以通过命令行的方式来执行。然后这个命令行就是power show.",
      "speaker": "发言人2"
    },
    {
      "time": "01:41:33",
      "text": "然后他们就搞出power share了。这个东西当然跟SH是不兼容的这是。",
      "speaker": "发言人1"
    },
    {
      "time": "01:41:38",
      "text": "毫无得了吧，怎么可能呢？",
      "speaker": "发言人2"
    },
    {
      "time": "01:41:41",
      "text": "但是这个东西的语法是非常学习习惯学习曲线是比较陡峭。他首先区分大小姐，你把它做成v visual basic多好，对不对？不区分大小写，首先区分大小要写。其次它的很多参数和做许多事情的方法都非常的啰嗦。他可能他他希望把很多事情做的很正统，或者说很很有条理。但其结果就是如果你有有unix shell的背景的话，你会觉得或者说这套东西是啰嗦到一个境界。但是我不知道纯粹的微软程序员会怎么想，可能会感会不一样的。",
      "speaker": "发言人1"
    },
    {
      "time": "01:42:27",
      "text": "不过他知道有一个好处，就刚刚我说了，因为它的设计原则是说所有没图形界面能做的事情他都能做。所以它的这个就是feature complaints，就是这个功能的完整性是所有目前所有这里面最强大的。你可以完全抛弃这个图形界面，然后通过这个part这个shell的方式去改变一个windows NT的服务器的任何部任何一个部分。",
      "speaker": "发言人2"
    },
    {
      "time": "01:42:53",
      "text": "对吧？因为在linus里面它有一个哲学，就是纯文本，纯文本至上，对吧？在US里面，在不同命令之间流淌的纯文本流可能是你唯一能够依赖的东西。但是在windows的power shell里面，很多东西它已经不再是纯文本的东西了。它是就基于对象的，它是一个structured，你可以在两个object，你可以在两个命令之间传递一个object。这在linux里面是不可想象的，因为就。",
      "speaker": "发言人1"
    },
    {
      "time": "01:43:22",
      "text": "结构化的数据传输，而不是我基于文本的这个数据传输。",
      "speaker": "发言人2"
    },
    {
      "time": "01:43:27",
      "text": "对，这在link里面你即便能做到，也是要通过一大堆什么TR，什么什么奥克之类的来来实现。",
      "speaker": "发言人1"
    },
    {
      "time": "01:43:37",
      "text": "就可靠性很差，简单来讲就是灵活性很强，可靠性很差。判断各种h case比较麻烦，power shell就完全没有这个问题。因为它可以传达以传输一个结构化的对象，保证不需要经过这个序列化反序列化造成的种种问题。",
      "speaker": "发言人2"
    },
    {
      "time": "01:43:53",
      "text": "可以直接去access某一个对property。",
      "speaker": "发言人1"
    },
    {
      "time": "01:43:58",
      "text": "而且他的因为它是被自上而下设计出来的这么一个笑。它的语法虽然说你可能觉得啰嗦，但这还一个好像是比较规整，就是reg举一反三，不像不像linux像德语。",
      "speaker": "发言人2"
    },
    {
      "time": "01:44:12",
      "text": "一样好吧？不像英语，你必须不停的去RTFM，你必须不停的去看音标，对吧？",
      "speaker": "发言人1"
    },
    {
      "time": "01:44:18",
      "text": "对你就给他个记住各种特例到底怎么回事，会比较痛苦一些。刚才讲了那么多share的来龙去脉的种种好处，就是我们有一个核心的要探讨的问题，就是为什么要用shell？为什么要用命令行？",
      "speaker": "发言人2"
    },
    {
      "time": "01:44:34",
      "text": "其实这才是本期的重点，如果你对是要。",
      "speaker": "发言人1"
    },
    {
      "time": "01:44:37",
      "text": "看重点，估计只有。",
      "speaker": "发言人2"
    },
    {
      "time": "01:44:39",
      "text": "五分钟来龙去脉。如果你已经了如指掌的话，前面的部分真的是可以自己去看书，可能会比较快一点。但是我们做了这么多历史的铺垫，介绍了这么多杂七杂八的东西，只是想要强调说命令行的生命力在今天还是非常旺盛。",
      "speaker": "发言人1"
    },
    {
      "time": "01:44:59",
      "text": "因为所以为什么要命令？",
      "speaker": "发言人2"
    },
    {
      "time": "01:45:02",
      "text": "因为他在。",
      "speaker": "发言人1"
    },
    {
      "time": "01:45:05",
      "text": "不他在那不一定你要用。他的魅力在哪里？为什么？",
      "speaker": "发言人2"
    },
    {
      "time": "01:45:09",
      "text": "首先我觉得魅力好像是非常简单的一件事情，就是你在写define简单。",
      "speaker": "发言人1"
    },
    {
      "time": "01:45:17",
      "text": "你在你在使用。",
      "speaker": "发言人2"
    },
    {
      "time": "01:45:19",
      "text": "一个60年代开始就已经在被使用的技术，它是非常的易于理解的，很简单的一个特征。比如说你自然在单一时间只能在屏幕的单一地方输入一个字符，对吧？不像单。",
      "speaker": "发言人1"
    },
    {
      "time": "01:45:36",
      "text": "天生单任务系统。",
      "speaker": "发言人2"
    },
    {
      "time": "01:45:38",
      "text": "没错，不像你在使用一个图形界面的时候，你用鼠标你会想要说你要找一个按钮。你但是你的目光，你在搜索这个按钮的时候，你可能会看到很多其他的东西。命令行不是命令行，就是空荡荡的一个东西在那摆着。然后你要是想不起来的话，你就想不起来。然后你要去找的话，你很有可能你就你要么找你可以直接找到你要找的东西，要么你就完全找不到，对吧？",
      "speaker": "发言人1"
    },
    {
      "time": "01:46:05",
      "text": "所以这个是缺点，它的可发泄性比较差。",
      "speaker": "发言人2"
    },
    {
      "time": "01:46:11",
      "text": "任何事情都是双刃剑，我们就是使用这个图形界面的时候，你我经常会觉得destruct。就是嗯因为屏幕。",
      "speaker": "发言人1"
    },
    {
      "time": "01:46:20",
      "text": "上太多那种布灵的小广告。",
      "speaker": "发言人2"
    },
    {
      "time": "01:46:23",
      "text": "屏幕上会显示着很多你此时用不到，但是你很有可能在下一秒就要用到的东西。哼但你又不可能，或者说目前还没有一个软件会把所有的菜单和工具条全都做成隐藏式的或者是浮动式。因为这个是如果那样的话，你又需要去动一下鼠标，它他们才会弹出来，或者是你需要去按一个什么东西。反正总所有这些你都会让你觉得命令行就这个图形界面固然方便，但是有时候也特别的啰嗦。",
      "speaker": "发言人1"
    },
    {
      "time": "01:47:00",
      "text": "命令行都不一样。你可能你所要做的两件事情就是敲命令，按回车，或者说你主要做两件事情就是输入输出。然后所有这些东西都是在一个特定的地方输完成的，然后你需要关注的点也就只有那么一点而已。",
      "speaker": "发言人1"
    },
    {
      "time": "01:47:18",
      "text": "哼对，再有就是我觉得其实命令行下面的工具要更切中要害一点。比如说gate，要看gate的这个revision history，我基本上只会用take，就我不是没有用过其他的什么source tree或者是。艾特拉斯出的那个网页版的工具叫什么来着？我说不记得了，但是所有这些看git revision的工具感觉都没有take方便，而打开这个的步骤，也就是输入这个按回车而已，没有什么就一步之遥，然后你离开也只有一步之遥。你不需要去点一个工具，点一个图标，然看它运行，然后选入选那个repository之类的对吧？我觉得运行下面很多工具都比较短小，然后切入钥匙，这是个所以。",
      "speaker": "发言人1"
    },
    {
      "time": "01:48:11",
      "text": "其实这句话你刚才讲的是中文，翻译成英文，其实在unix的这个unix大部分是一个命令行驱动的工具。就生态系统对吧？他们追求的这么一个设计哲学叫做do one thing and doing well。对，就是这样有一个工具只做一件事儿，并且把这件事儿做到极致。而在然后比如说刚才讲的这个他可以去浏览这个gate的repository的情况，还有其他各种各样的小工具。它可以去比如说可以去列表一个目录的内容，或者是查在我一个文件里面查找东西，它都是一些很小的一个步骤。",
      "speaker": "发言人2"
    },
    {
      "time": "01:48:52",
      "text": "因为由于命令行的这个管道的功能，它可以使得两个程序之间配合。比如说上一个程序的输入输出变成下一个程序的输入，然后这个链条是可以扩展无限长的。没错，他们之间存在一个叫做可组合性。就是说如果你的是一个工具箱，里面有锤子、有钉子，不是有锤子有扳手这些东西之外，它还能组合成一些一套完整的工具链儿，使得你可以完成各种各样比较复杂或者更加灵活的去应对这个工作场景。所以就是工具的完善性，每一个工具的小巧可靠以及它们之间的相互组合性。我觉得这个是命令行这个生态最大的魅力所在，没错。",
      "speaker": "发言人2"
    },
    {
      "time": "01:49:40",
      "text": "而反过来在这个图形界面之下，你就没有这样的概念存在。就是你你你怎么样才能把一个图形界面的工具的输出转入到另外一个图形界面的工具的输入里面。你看你copy paste吗？",
      "speaker": "发言人1"
    },
    {
      "time": "01:49:54",
      "text": "也有对，copy paste或者叫做drag and drop，或者是拖拉。",
      "speaker": "发言人2"
    },
    {
      "time": "01:49:58",
      "text": "对，但这一切是但自动化的就没有办法同时说我我永远要把自动化。",
      "speaker": "发言人1"
    },
    {
      "time": "01:50:05",
      "text": "这些倒不是一个问题。我觉得最主要的问题就是说他们因为图形化的这个内容的传递之间，不存在一个叫做universal interface。Universal face就统一的接口，就是这个文本test，它不就图形化的界面，它不存在这么一个一个通用的一个接口。使得并不是说任意两个程序之间的这个输出都是可以直接drag on drop来来来组合的。所以必须说你开发了假设你在photoshop里面编辑了一个图片，然后你要导入到另外一个工具里面去做一个进一步的处理。你得把它变成一个文件。然后再再hopefully你的下一个环节的工具能够打开上一个环节这个工具生成的图片，然后导入到自己的这个里面，然后再做进一步的操作。",
      "speaker": "发言人2"
    },
    {
      "time": "01:50:55",
      "text": "对吧？对所以这里。",
      "speaker": "发言人1"
    },
    {
      "time": "01:50:58",
      "text": "就有一个compose base，这个合成性的问题会比稍微差一些。但这只是一个我们理解通常状态，但也有很好的合成性相对还不错的这么一个环境。比如说在起码现在的IOS上面就有，就因为它没有文件系统暴露出来，也没有命令行暴露出来给你用。所以这个上下游的配合是你必须要考作为这个系统的设计者，你必须要考虑的一个问题。那现在就是说你可以分享到某一个应用里面去，对吧？然后你如果那个应用它大刚好能够接受这么一个图片格式或者文件格式也好，它是其实能够把这个链条传下去的。只是说由于还是那个问题，就不存在这个text as universal interface。",
      "speaker": "发言人2"
    },
    {
      "time": "01:51:46",
      "text": "同时也不形象一个强有力的机构来要求所有的程序都必须实现一条跟其他程序交互的接口。",
      "speaker": "发言人1"
    },
    {
      "time": "01:51:54",
      "text": "所以对所以这个整个还是也相对来说比较难一点。然后我觉得可能命令行对我来说另外一个好处就是它可以表述一些比较复杂的一个概念。比如说因为有这个笑语法的存在，它其实是一个它是一个叫做turing complete language，它是一个完整的编程语言，对吧？所以其实你们可以做一些相对来说很复杂的或者更加抽象的一些操作。而这些操作通过点点鼠标这种图形化的方式是比较难办到的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:52:25",
      "text": "比如说很多人都遇到过这个难题，你一个目录里面，就假设我考虑文件的情况下，你要批量改一堆文件的文件名。比如前面加一个前缀或者去掉一个后缀这种事情你不借助一些特殊的工具，在这个图形界面里面是很难实现这一点的。不可能一个一个点鼠标去改，对吧？但是在命令行下面，你其实你因为有这个语法的一个编程语言的存在，你其实可以对这些文本做一些很高级的操作。然后把这个操作变成一个实际可以执行的代码。代码可能就调用一个比如说move修改文件名的这么一个命令去执行它。所以这里面也是一个很重要的问题。但可能现在图形界面里面最接近这个的应该是就是像OSN自带的那个是automated就自动机自动化的一个工具。那个那个图标是一个机器人儿，白色机器人拿着一个黑色的枪，还是什么乱七八糟的这个管子，不是枪，管子对，黑色的管子对pad，他做可以你可以做一些组合，但是1万个.",
      "speaker": "发言人2"
    },
    {
      "time": "01:53:30",
      "text": "卖家有一个人会用这个消息盒子。",
      "speaker": "发言人1"
    },
    {
      "time": "01:53:34",
      "text": "高阶OS ten的用法的用户才会去理解或者使用到的这么一个场景，我偶尔也会用到，然后它里面做的一些功能其实也蛮强大的。比如说它可以批量的从一个假设一个PDF文件里面抽取出多少页，然后再把这些一些批量的转化成一个图片文件，然后再单独出现在某个地方对吧？或者是批量的去修改一些文件图片文件，比如说转换格式，改变文件大小，再压缩这种，或者他也可以有，但是他学学习曲线还是比较陡峭的。",
      "speaker": "发言人2"
    },
    {
      "time": "01:54:08",
      "text": "没错。",
      "speaker": "发言人1"
    },
    {
      "time": "01:54:10",
      "text": "当然了命令行也有它自己的缺点了。比如刚才讲的这个就发现性比较差。就是如果你不知道有一个功能可以用什么方式来实现。",
      "speaker": "发言人2"
    },
    {
      "time": "01:54:18",
      "text": "你就是不知道怎么没有人会告诉你。不像在图形中，你必须你可以去点到时候试对吧？",
      "speaker": "发言人1"
    },
    {
      "time": "01:54:24",
      "text": "对，你可以可以大概找得到他在哪里。如果命令行里面你找不你不知道他在哪儿，你你是真的是你不知道他是什么，你真的就不知道去哪里找。但一个笨办法就是一个一个去读这个menu，读手册。",
      "speaker": "发言人2"
    },
    {
      "time": "01:54:37",
      "text": "但是有些cash是那有些点子是如果你没有人告诉你的话，你就是不知道的对吧？",
      "speaker": "发言人1"
    },
    {
      "time": "01:54:44",
      "text": "比如说对需要实践。",
      "speaker": "发言人2"
    },
    {
      "time": "01:54:46",
      "text": "需要去累积。对，就你会需要真的有一个传承，有一个师傅去告诉你这个东西就是这样，你得这么用，不然就是不行。比如说从dos的命令行到温到links转换的过程中，你可能会遇到一个问题，就是怎么样改名一个文件对吧？你会发现links没有rename这个功能，你就会说我说我靠怎么会改文件，这种东西是做不到的这不可能。但是直到有个人告诉你说你要move.",
      "speaker": "发言人1"
    },
    {
      "time": "01:55:15",
      "text": "就是你要移你要移动一个文件。",
      "speaker": "发言人2"
    },
    {
      "time": "01:55:17",
      "text": "一个东移把一A一个东西从A移动到B的工具也可以完成，把一个东西从A命名为B这是这是是需要有人告诉你的这件事情，对吧？哼类似的例子还有什么？比如说你在到下面，你我觉得什么copy sing点copy。星点TXT空格星点TXT你可以批量的把所有的纯文本文件转换为EXE文件。但在linux下面这是做不到的对吧？你会说我靠，为什么就得有一个人跟你解释这个linux下面的这个所谓share extension这个东西叫什么来着？Interpretation扩展对命令行扩展跟dos项目的机制是不一样的，对吧？这很多东西都需要自己去弄弄明白。",
      "speaker": "发言人1"
    },
    {
      "time": "01:56:13",
      "text": "这是所以现在其实网有网络也好。因为如果之前我们当时用命令行的时候，只能看杂志上面有一个小tips的区域，对吧？就非常有限的，或这个也没办法搜索的。现在就是有很多这种网站，它会有那种叫做那种这种小摘要的形式去告诉你说有这么一个功能，你可以用什么方，哪几个命令组合可以实现这么一个功能。比如像什么这种叫做bony food的这么一个网站可以做类似的事儿。",
      "speaker": "发言人2"
    },
    {
      "time": "01:56:41",
      "text": "我觉得那个时候学linux真的是用生命在学。我靠你要是把自己的那个心爱的游戏分区搞丢了，危险装一个linux然后要买要要从书店里面买unix的教程，然后要看着杂志上面的文章点点学。不像现在我靠开个虚拟机，然后另外开个浏览器，简直是飞一样的一日千里。可以学会我们那个时候需要一个月才能学会的东西。",
      "speaker": "发言人1"
    },
    {
      "time": "01:57:11",
      "text": "对，这个节目最后我们介绍一些我就我们觉得还挺有用的这种谜题堂小工具。可能很多人有些可能知道，但不一定每个你都知道，对吧？所以讲一下大家有什么好玩的。行，先说那个，其实这个我们之前提到过讲在讲包管理器的时候提到过，在OSN上有一个叫home blue的东西，可以帮你解决怎么去新增这种命令行工具的一个困惑是。对，但这个不属于命令行工具本身了，那我们就先略过。下面开始我们一个人介绍一个。",
      "speaker": "发言人2"
    },
    {
      "time": "01:57:48",
      "text": "我先来个LOL cat.",
      "speaker": "发言人1"
    },
    {
      "time": "01:57:52",
      "text": "就是这是干嘛的？",
      "speaker": "发言人2"
    },
    {
      "time": "01:57:54",
      "text": "下面0 unit下面有cat对吧？就是有没有dog，但是有cat。Cats是猫是干嘛用的？猫是输出用的这其实挺有。",
      "speaker": "发言人1"
    },
    {
      "time": "01:58:03",
      "text": "猫的作用，是说它从他的把他的输入打到输出里面。",
      "speaker": "发言人2"
    },
    {
      "time": "01:58:10",
      "text": "你可以把一个文件的内容输出到standard out上。对LOL cat是什么呢？是一个可以把你的输出用彩虹的颜色输出到这个不把你输入用彩虹的颜色输出到stand out上面，就是在一个支持多彩的这个shell里面，shell emulate里面，它可以把字符按照这个固定的色谱，用这个红橙黄绿青蓝紫的这是所有颜色输出出来。也就是说你你的你可能你不用你用普通的cat的话，你只会输入一个单字的东西。但你用IOL要开的那种花，你的整个说不出都会显得多彩。",
      "speaker": "发言人1"
    },
    {
      "time": "01:58:59",
      "text": "所以这是一个有趣而无用的趣迷你号工具对吧？",
      "speaker": "发言人2"
    },
    {
      "time": "01:59:03",
      "text": "类似我还有很多，比如说那个SL如果你把LS打成SL的话，他会出一个出一辆火车还是什么东西，就是说你又打错了这种感觉。对。",
      "speaker": "发言人1"
    },
    {
      "time": "01:59:18",
      "text": "刚才也提到过这个叫做tick的工具。就get大家都知道是一个用于做源代码管理的一个命令行工具。然后tig就是把git反过来写的话，它是一个基于n curse的一个显示revisions .",
      "speaker": "发言人2"
    },
    {
      "time": "01:59:33",
      "text": "history的图形界面。对。",
      "speaker": "发言人1"
    },
    {
      "time": "01:59:35",
      "text": "非常有，就不止revision history，它可以显示很多东西。",
      "speaker": "发言人2"
    },
    {
      "time": "01:59:38",
      "text": "其实在里面还可以比较常用的操作。比如说的大部分。",
      "speaker": "发言人1"
    },
    {
      "time": "01:59:43",
      "text": "功能都可以在这个里面实现了。对，所以这是一个挺好用的工具。因为很多人说可能从那个SVN迁过来，特别是windows下面程序员，他可能觉得，这个git的没有图，没有很好的这个图形化工具，对怎么办？其实是有的，像咱们SOSTRA刚才也提到过了。但是像我们这种死忠的粉，还是习惯于说用这种基于命令行的一个基于这就是文本窗口的一个工具。然后这个是一个很好的选择。",
      "speaker": "发言人2"
    },
    {
      "time": "02:00:10",
      "text": "我觉得git也是一个奇葩的，我没有办法做出一个好用的命令的图形界面的工具。",
      "speaker": "发言人1"
    },
    {
      "time": "02:00:18",
      "text": "有很多人还是用的挺好的，只是说很多高级功能，就好像说我就就刚刚就好像我说的一样。刚才那个为什么选择命令行的原因是一样的。Git就有很多高级功能，只可能在通过文本，就是命令行的方式表述出来。因为用图形方式表述实在是太烦了。",
      "speaker": "发言人2"
    },
    {
      "time": "02:00:34",
      "text": "我觉得用图形界面表示出来就是操作git数的话，我其实能够想到最符合直觉的一种方法就是你可以直接去拖拽那个branch里面的节点，然后让它在你想要去的那个地方停留下来，然后松手。然后这个图形界限面的工具就自动帮你完成对应的get操作，这个才是最符合直觉化的一个实现。现有的只不过现有的大部分的通讯工具，只不过是把那些命令行的命令封装成一个按钮而已。你还是没有办法直接看到执行这些命令之后，那个south tree会变成什么样子，对吧？",
      "speaker": "发言人1"
    },
    {
      "time": "02:01:12",
      "text": "还有可组合性和表达的抽象层级的问题。你始终这种可视化的抽象层级是要相比语言描述的还是要低一些，低很多的。所以你这第一个order OK.",
      "speaker": "发言人2"
    },
    {
      "time": "02:01:30",
      "text": "下一个你有什么介绍的，我可以介绍cos。",
      "speaker": "发言人1"
    },
    {
      "time": "02:01:36",
      "text": "又是一个有趣。",
      "speaker": "发言人2"
    },
    {
      "time": "02:01:38",
      "text": "没有什么有这个cos有一个变种叫做costing。就是你你brew install costing之后，你会得到两个命令，一个叫cos就cos然后结果就是他会把你的输出包裹到一个漫画的那种输入，不对，他会把你的输入包裹到一个漫画的那种想或者是气泡框里面。对，然后旁边下面画一头牛，这就是这个用途，就是牛说对，然后另外有一个工具叫做fortune，就是跟你说一句，其实就有那种中餐馆里面的那个小cookie里面fortune cookie？一个小纸条大概是那个意思。然后他会跟你说很多名人名言，然后你把fortune重定向到cos他就会把名人名言包括到一个包裹里面，然后让牛说出来就是。",
      "speaker": "发言人1"
    },
    {
      "time": "02:02:28",
      "text": "那个那个中餐馆的小cookie这个事情应该是只有在国外的人才会知道这个梗。",
      "speaker": "发言人2"
    },
    {
      "time": "02:02:34",
      "text": "没错，就是中在国外的中餐馆，some house会提供一种非常特别的，在你结账的时候会给你一个小cookie然后这cookie其实是非常难吃的一种饼干。直播这个cook.",
      "speaker": "发言人1"
    },
    {
      "time": "02:02:47",
      "text": "我觉得还挺好吃的。",
      "speaker": "发言人2"
    },
    {
      "time": "02:02:48",
      "text": "What我头一次遇到喜欢吃方程cookie的人。",
      "speaker": "发言人1"
    },
    {
      "time": "02:02:53",
      "text": "脆脆的挺好吃的。",
      "speaker": "发言人2"
    },
    {
      "time": "02:02:55",
      "text": "然后这个面皮它是空心的对吧？它是空心的。然后你把它打开，里面有一个小纸条，小纸条画里面会对，有时候是中英文的这是在德国绝大部分。",
      "speaker": "发言人1"
    },
    {
      "time": "02:03:06",
      "text": "都是中英文的。",
      "speaker": "发言人2"
    },
    {
      "time": "02:03:07",
      "text": "英英德文的，就是一边是英文一边是德文。",
      "speaker": "发言人1"
    },
    {
      "time": "02:03:10",
      "text": "对对对，在北美就是中英文的对。",
      "speaker": "发言人2"
    },
    {
      "time": "02:03:13",
      "text": "会给你一句小格言，比如什么你举个例子，一时想不起来是吗？",
      "speaker": "发言人1"
    },
    {
      "time": "02:03:19",
      "text": "对我一时也想不起来，反正有一种那种箴言是不是不是名言，是真言。那个叫什么？就是他会讲一个看似很有道理的一句话，但实在是没有什么卵用。",
      "speaker": "发言人2"
    },
    {
      "time": "02:03:32",
      "text": "会讲一句有趣而无用的话。",
      "speaker": "发言人1"
    },
    {
      "time": "02:03:35",
      "text": "对，差不多这个意思。对，fortune这个软件差不多就干类似的事情。",
      "speaker": "发言人2"
    },
    {
      "time": "02:03:40",
      "text": "没事。",
      "speaker": "发言人1"
    },
    {
      "time": "02:03:43",
      "text": "下面一个挺有用的一个命令，航空就叫MTR，这个是干嘛？这可能做网络或者是你对网络状况比这个要有有研究，就是互联计算机网络有研究的人会经常用到。有有两个工具，一个叫trace root一个就叫ping。Ping是测这个延迟，然后trace就是测这个你跳转的。你从你从你的电脑到另外一个服务器之间要经过哪些这种中转中间的路由或者是这个网关对吧？对，然后MTR是把这两个工具的功能合二为一，并且一种更加友善和有用的方式汇报出来的一个这种网络诊断工具集合。",
      "speaker": "发言人2"
    },
    {
      "time": "02:04:29",
      "text": "对他这个math traceback t对match的trace route.",
      "speaker": "发言人1"
    },
    {
      "time": "02:04:34",
      "text": "对，那个叫match作者。对，那你现在下一个叫做pre，你介绍一下是什么？",
      "speaker": "发言人2"
    },
    {
      "time": "02:04:43",
      "text": "Pray和i python我想放在一起介绍的OK。Python的用户一定要使用i python这个东西，而不是使用python默认给你装那个老掉牙的idol。Ipad是一个既可以在命令行下面跑，也可以有一个专属的网页版本，或者乃至于一个基于QT的图形界面的一个全功能python笔记本。你可以在里面运行python的程序，你可以在里面尝试python各种新功能。而且你的每一次输入和每一次输出都会被记在in和out两个area里面，你可以随时去查询，然后还内置了很多其他的功能，比如说什么语法高亮，那个trace room codec，the backtrack back tress，back tress, 然后pri就是ruby的ipad on是什么的OK两个是非常有用。",
      "speaker": "发言人1"
    },
    {
      "time": "02:05:45",
      "text": "刚才讲的那个i python，我还推荐一个叫做b python，就是AB的BB python OK，I python它是也是一个python的一个叫做rapper，read evaluate，print, look这么一个工具。B python是一个替代的一个rapper，然后它的好处是什么呢？它首先它有语法高亮，就对python语法，它是你敲的每一行它是语法高亮的那它的多行模式也比较支持，比ipad要好。然后它觉得最有用的功能，它会对你打的这个标准库里面的函数，它是有这个就是那个叫什么，类似于一个ID，它是有提示那个函数的一个签名，以及每个参数是干什么用的。OK就非常好用，而且它的没有ipad tho那么功能丰富，它是一个更加轻量级的这么一个rap。对ipad.",
      "speaker": "发言人2"
    },
    {
      "time": "02:06:33",
      "text": "我相信如果你要是要做一些什么科学计算，或者是啊生物信息学之类的做科研，基本上是对人手臂装一个东西。",
      "speaker": "发言人1"
    },
    {
      "time": "02:06:46",
      "text": "我再介绍一个叫做i perf 3，这也是一个做网络性能的测试的一个工具。就是说假设你想测，就你们家刚装修房子，你想测这个装修师傅给你装的网线是否达到千兆的一个一个一个速度，对吧？你怎么办？你找两台电脑都插上网线对吧？然后再一头运行一个ipad 33的1个server，然后在另外一头运行的python 3的1个客户端，一个client。然后把这个client指向那个server，它就会在这两端发起一个一个连接。然后他就测试这个连接能最能最大以多快的速度传输，对吧？OK就它是一个测试这个网络联通速度的这么一个小工具。这三是一个最新的版本，然后有一个ipad I perf没有数字，就是默认是二。这个版本相对老一点，就看你的发行版的区别。",
      "speaker": "发言人2"
    },
    {
      "time": "02:07:37",
      "text": "OK, 接下来我再介绍一个t mox，就是刚才已经提到了是一个终端复用器。就是你可能连接到一个远程计算机上，或者说你在本地，然后你开了一个产品的窗口，你会觉得说我靠我还想做另外一件事情，怎么办？一个选择是再开一个窗口或者再建立一个链接。而比较好的一个方法就是复用你当前已经建立的链接。",
      "speaker": "发言人1"
    },
    {
      "time": "02:08:03",
      "text": "可以装t max这个东西。它可以通过一些组合键，让你在一个terminal的窗口里面开很多个其他terminal窗口。可能描述比较抽象，但如果你去这个d max的网站上看一下，你会很很明白这是什么意思。",
      "speaker": "发言人1"
    },
    {
      "time": "02:08:20",
      "text": "其实这个有个最大的好处，你知道是什么吗？就是它可以保持你的一个登录状态。",
      "speaker": "发言人2"
    },
    {
      "time": "02:08:25",
      "text": "不是就可以保持程序的一些状态。对你可以在一台机器上用team mos来执行一个命令，然后detach from the team Marks.",
      "speaker": "发言人1"
    },
    {
      "time": "02:08:34",
      "text": "然后就直接关掉那个和那个机器的连接。对，但是这个时候在你刚才启动那个进程，它是不会退出的。因为正常情况下你断掉一个连接之后，那个那个进程就退出了。",
      "speaker": "发言人2"
    },
    {
      "time": "02:08:47",
      "text": "但是除非你之前什么有因为一个很复杂的操作，this old this先background，然后this old然后你才不会在你退出的时候终止这个程序。",
      "speaker": "发言人1"
    },
    {
      "time": "02:08:59",
      "text": "但一般人不会这么干嘛。",
      "speaker": "发言人2"
    },
    {
      "time": "02:09:01",
      "text": "对，除非你事后想到了。",
      "speaker": "发言人1"
    },
    {
      "time": "02:09:04",
      "text": "对，所以你用这个T如果你用t max的话，它是你退出的时候，它是直接断掉和t max这个master进程的连接。那他会还会继续接管你在里面lunch的那些紫禁城，然后等你回家再连上。这个时候你可以用那个t max空格A也就attach这个参数重新连回之前的那个t max的这个master进程。这个时候你会看到和你断开之前一模一样的这个远端登录的键盘。而你之前在执行的那个可能那个程序可能执行时间比较长的话，它是不会受任何影响的对。",
      "speaker": "发言人2"
    },
    {
      "time": "02:09:39",
      "text": "然后另外一个用例就是比如说你是一个实验室的学生，然后你实验室里面有台电脑，然后你的工作办公室里面有一台电脑。你需要在实验室里面观测一些数据，然后输入到电脑上，然后你你你要么用远程桌面对吧？要么就是t max，然后在实验室的电脑上看到的东西会实时显示在你办公室电脑上也挺好。",
      "speaker": "发言人1"
    },
    {
      "time": "02:10:03",
      "text": "当然t max还有一个兄弟叫做screen，就是屏幕那个。",
      "speaker": "发言人2"
    },
    {
      "time": "02:10:08",
      "text": "词的早期的一个终端复用。",
      "speaker": "发言人1"
    },
    {
      "time": "02:10:12",
      "text": "那screen的特性没有t max的那么强大好用，现在基本上都推荐大家用t max会好一些了。",
      "speaker": "发言人2"
    },
    {
      "time": "02:10:19",
      "text": "Screen太古老了，主要是而且好像screen好像不能分就是分tab。",
      "speaker": "发言人1"
    },
    {
      "time": "02:10:24",
      "text": "我记得可以分tab，它最早的版本是不能分那个分左右分屏对。",
      "speaker": "发言人2"
    },
    {
      "time": "02:10:29",
      "text": "我就是这个意思，就是不能split view。",
      "speaker": "发言人1"
    },
    {
      "time": "02:10:33",
      "text": "但现在新版本是可以的了OK但只是因为大家展示一般都是比较老旧的版本，所以这个就很难保证t max的特性大概会好一些。没错，行，我在这个t max还有个很高级的功能，就一直没有说它screen有这个功能，就是可以做那个pair programing。对，没错，就是可以两个人连到同一个人在输入。对，你可以连两个人从分别从自己的机器人连到同一台服务器，然后调用一个t max的一个终端，大家互相可以看见对方在那个里面打什么也可以对进行一对一的这么一种辅导式的教学，只不过容易打架。这个就是你要自己约定好到底是谁教谁学，对吧？对，最好协同一下。",
      "speaker": "发言人2"
    },
    {
      "time": "02:11:19",
      "text": "对，就是两个做成pair pro结结对编程对吧？Pair programmer的时候比较有用的一个工具。没错，我再介绍一个叫做tree，就是树那个那个工具。这个是干嘛用的呢？就是说你在命令行里面你要去叫做navigate。就是你要在文件系统里面去看东西到底哪个文件在哪，在哪个结构里面，对吧？",
      "speaker": "发言人2"
    },
    {
      "time": "02:11:43",
      "text": "经常采用的是list，或者这个就是list就是列表一个目录里面的文件。但list一般只能列一层，就是你只能看当前或者某个指定目录下面的这个文件列表。但是你是看不到整个文件。因为文件系统是一个整个是一个树状结构。你是不能用list看到整一个树状结构怎么样子的，然后tree这个小工具就可以做，那就做做这个事儿。他会把这个文件系统从你指定的层开始，以一个数的形式把它打印到这个终端窗口上面去。你可以比较直观的看到你的这个，就比如整个这个代码的工程目录里面的文件结构是怎么样子的，还是要有用。",
      "speaker": "发言人2"
    },
    {
      "time": "02:12:28",
      "text": "我也来顺便推荐一个midnight commander，就是ok因为这也是从处理想到的，就是通用commander是dos时代乃至windows时代非常受欢迎的一个文件管理工具。后来有有好事者把它移植成了一个command line interface的这么一个东西。就是你输入MC就会出现一个类似于那个total commander的一个全屏的工具，也是n curse。然后里面也有什么，比如说列出当前命令数，批量拷贝，批量重命名之类的功能。然后如果你是一个熟练的total command用户的话，你会发现里面很多很多的操作是一模一样。对，因为而且这个东西最大的一个特征它是跨平台的，就是它在linux和dos上面都有OK，还蛮特别的。",
      "speaker": "发言人1"
    },
    {
      "time": "02:13:23",
      "text": "这太帅了，那我推荐另外一个系统管理用的工具叫做h top。就是很多系统，很多unix里面都有一个内建的命令叫做top。然后它会列它会以一个n curse的方式列出当前系统里面正在活跃的进程，以及一些系统的状态。比如说这个CPU的占用，这个就是各个用户态内核态各占多少比例，内存的使用状况，活跃的一些进程的使用资源的情况这些。但是top的一个主要问题就是它展示的是一个单色，而且就不不方操作不方便的一个键，不好看也不好用。",
      "speaker": "发言人2"
    },
    {
      "time": "02:14:02",
      "text": "对，h top就是一个top的就是一个改良版。它可以一种更加直观易懂的方式展现出top展现的所有内容。并且它比如说它会展示在默认情况下，它会展示这个CPU。它会有一种进度条的方式去表示这个CPU的实际占用比例以及这个内存的占用情况。而且它下面的那个那个是进程列表，它会也有各种各样的高级功能。比如说它可以以一个树状的结构展示这个进程列表，而不而不是一个单纯的对，就是非常建议大家都，这是我每次装新系统的时候都必装的一个软件。大致的作用跟大家看到那个叫做activity monitor，在weston这个功能是差不多的。",
      "speaker": "发言人2"
    },
    {
      "time": "02:14:48",
      "text": "只不过是在命令行下面杯子。然后很多人做他们的那个呃当前命令行的截图，都会专门找一个窗口开。这个也算是一个现象级的软件。",
      "speaker": "发言人1"
    },
    {
      "time": "02:15:03",
      "text": "对O.",
      "speaker": "发言人2"
    },
    {
      "time": "02:15:05",
      "text": "K那我来推荐一个命令，叫做open或者是或者说我来推荐一组在OS ten上面。在命令行下面工作的时候，你可能会出现一些比如说你要把命令某一个文件内容或者是某一些输出弄到系统剪贴板上的场景，或者你需要把系统里的剪贴板的内容输入到某一个命令的输入里面。或者你需要利用系统级的一个工具。比如说你要打开一个PDF，怎么办呢？你可以用首先剪贴板的话，你可以用PB copy和PV pace两个功能，两个命令，分别可以把这个剪贴板里面的东西拷贝或者是粘贴出来。",
      "speaker": "发言人1"
    },
    {
      "time": "02:16:02",
      "text": "如果你想打开某一个文件的话，你可以用open这个命令。比如说你想要在finder里面观察当前的目录，你可以open空格，点打开就可以在finder里面打开当前目录。如果你想要打开当前目录下面所有的PDF文件，你可以打open星点PDF。系统会自动调用preview或者是AOB reader，取决于你选择的默认程序是什么。来打开所有的PDF算是一个小team。",
      "speaker": "发言人1"
    },
    {
      "time": "02:16:36",
      "text": "那个PP copy PP pace用法可能还要再解释一下，就是PBPB copy这个命令。",
      "speaker": "发言人2"
    },
    {
      "time": "02:16:47",
      "text": "的输入，你需要把你的程序的输出重定向给PB copy。",
      "speaker": "发言人1"
    },
    {
      "time": "02:16:52",
      "text": "对，就他是指只从从他的书把他的输入复制到系统简介版里面。然后BB pace就刚好反过来，它是把它的系统剪辑版的内容导到它的输出里面去。所以用法肯定就是说是从PB导入，就是内容导到PP copy里面去，然后从PP pace里面导出这么一个管道的。",
      "speaker": "发言人2"
    },
    {
      "time": "02:17:13",
      "text": "就说你在网页上选中了一段话，然后你要把这段话排序，可以在你可以先选中这个话，按com and c然后在命令行下面打PV paste pipe salt pipe PB copy，然后你就把这个剪贴板里的内容排序。对，大概是这么一对。",
      "speaker": "发言人1"
    },
    {
      "time": "02:17:35",
      "text": "行，那这个命令就介绍到这里。因为要以上介绍的所有命令都除了刚才讲的那个O就是OSN原生的PP copy，PP pace open之外。",
      "speaker": "发言人2"
    },
    {
      "time": "02:17:45",
      "text": "都都需要你额外装。",
      "speaker": "发言人1"
    },
    {
      "time": "02:17:47",
      "text": "都是不是系统自带的，你就要需要通过这个比如说home put的方式去自己装。如果你是其他类U系统的话，用你可以用你自己的包管理器去装这个工具。对，那我们今天的这个节目就到此为止了。",
      "speaker": "发言人2"
    },
    {
      "time": "02:18:03",
      "text": "好，真的说了好多，因为这真是可以拆成两期的节目。好吧，反正关于这个命令行的这个所谓common line food，common line空腹的这么一个东西，这是说之不尽。不妨推荐大家去这个come online food点com，就是这个名是怎么来的呢？就是因为外国人不明白空腹这个词是什么意思，他们会把某些东西的技巧叫做什么什么付。比如说搜搜google的技巧叫做google付，然后common line的技巧叫做common line，然后come online FU dot com，然后你可以在这里面找到很多很多实用的命令行的tips，好吧，感谢收听IPPA网络旗下的IT技术主题娱乐节目。",
      "speaker": "发言人1"
    },
    {
      "time": "02:18:51",
      "text": "我们把号称我们叫内核恐吓，我们号称helper，但是也没有干货，想听人听，不想听别听。你可以为本节目捐款，捐款地址是current panic dota FM slash donate，捐款金额随意，这样是八个正式入背就可以了。捐款不会为你带来什么，不捐也不会让失去什么。我们的口号是no hot feelings，如果你有任何反馈，欢迎发邮件到kernel panic at IP note LI。同时也欢迎收听IPN旗下几档节目，ID公论为指导。太一来了，流行通讯high story阴影下五次元博物志选美，我们下期节目再会。",
      "speaker": "发言人1"
    }
  ],
  "lab_info": {
    "summary": "本期播客“内核恐慌”聚焦于个人网站与开源项目维护的实践与思考。讨论首先强调了开源社区的重要性及其未来趋势，指出维护开源项目不仅是技术活，还需要沟通与团队协作能力，鼓励参与以促进行业进步。随后，分享了维护开源项目的实际经验，包括项目规划、团队管理、技术难题解决及个人品牌建设，同时触及开源项目面临的挑战，如资金短缺、贡献者流失等，并探讨了解决方案。最后，深入讨论了平衡个人与开源项目的时间分配、吸引新人参与及开源项目的机遇与挑战，展现了开源生态的复杂性与发展潜力。",
    "qa_pairs": [
      {
        "question": "在上一期节目中，我们提到QQ发代码的问题，能否请你分享一下这在国内院校中是一个怎样的场景？",
        "answer": "国内院校中，由于部分同学可能不熟悉或没有使用版本控制系统如git，因此在做group assignment时，会出现将代码通过QQ等门槛较低的方式共享给组员的情况。尽管国外也有类似问题，但效果并不理想。此外，计算机课程覆盖面广，与其他学科相比缺乏系统性也是一个因素。",
        "time": "00:01:28"
      },
      {
        "question": "对于计算机科学系和计算机工程系或者软件工程等专业的学生，学校是否应该教授代码管理工具、编辑器等实践性内容？",
        "answer": "如果一个专业的目标是培养软件工程师，并期望毕业生能在就业市场上具备相关技能，那么学校有责任教授这些代码管理工具、编辑器以及最佳实践操作。如果不进行这样的系统化培训，就不能合理地称其为工程类专业的学生。",
        "time": "00:05:02"
      },
      {
        "question": "是否有必要将所有计算机专业的学生都打造成能用各种工具的实际操作人员？",
        "answer": "纯理论研究的计算机科学家并不一定需要掌握所有具体的工具，但如果一个本科教学目标是培养码农，那么忽视这些工具的培训是存在问题的。学校应当根据学生的就业需求和目标来平衡理论学习与实践技能的培养。",
        "time": "00:05:57"
      },
      {
        "question": "为什么说“码农”这个词不能被用来称呼软件工程师？",
        "answer": "“Programmer, stop calling yourself engineers.”这篇文章指出，许多从事编程的人并不具备与“engineer”这一职业title相匹配的严谨性和可靠性。因为很多软件服务虽然已经成为基础设施的一部分，但其实远不如传统基础设施可靠。工程师通常代表的是高度可靠和值得信赖的专业技术人员，而当前部分软件的稳定性并不能满足这一标准。",
        "time": "00:12:26"
      },
      {
        "question": "这个Flutter框架是什么时候正式发布的？",
        "answer": "这个Flutter框架大概两周之前正式有了自己的网站，并且是源自Google的一个移动编程框架，名字叫做Flutter。",
        "time": "00:16:54"
      },
      {
        "question": "Google对于Flutter及其语言Dart的推广力度如何？",
        "answer": "Google在推广方面似乎力度不足，之前计划将Dart整合进Chrome中，但后来似乎取消了该计划，这让外界对Dart和Flutter的信心不是很足。",
        "time": "00:19:09"
      },
      {
        "question": "Flutter的最大特点是什么？除了Dart之外，还有哪些语言可以在Android应用开发中使用？",
        "answer": "Flutter的最大特点是使用 Dart 语言编写，它本质上是一个跨平台框架，可以将编写好的程序编译成适用于iOS和Android等不同操作系统的程序。理论上用Scala也可以用于开发Android应用，但不一定是主流或广泛使用的解决方案。",
        "time": "00:17:44"
      },
      {
        "question": "Flutter是否采用了类似于React的设计模式？",
        "answer": "是的，Flutter采用了类似于Facebook的React框架所采用的设计模式，支持开发者使用类似于functional reactive的方式来编写界面。",
        "time": "00:18:41"
      },
      {
        "question": "对于Flutter的未来发展，您怎么看？",
        "answer": "我不确定，我自己已经不再从事移动端开发，不过从swift的角度看，Flutter算得上是Google的亲儿子，但Dart背后的推动力似乎不够，Google在这个项目上的表现并不稳定。",
        "time": "00:19:09"
      },
      {
        "question": "您对Flutter的成功前景持何种态度？",
        "answer": "我对其没有特别的看法，因为我现在不再专注于移动端开发，不过建议大家了解这个东西的存在。",
        "time": "00:20:49"
      },
      {
        "question": "数字零点网站主要讨论什么话题？",
        "answer": "数字零点是一个专门讲解浮点运算的网站，深入探讨了在某些编程语言中，由于二进制表示的限制，无法精确表示十进制数如0.1和0.2，从而导致计算结果出现偏差的问题。",
        "time": "00:21:45"
      },
      {
        "question": "浮点数精度问题如何在编程语言中处理？",
        "answer": "不同的编程语言有不同的处理方式，如使用不同精度的浮点数类型（如float和double）、采用任意精度的十进制库，或者通过分数形式存储数据以避免精度丢失。",
        "time": "00:25:07"
      },
      {
        "question": "在实践中，命令行与理论之间是否存在差异？现在的新人们是否直接跳到命令行，很少使用图形界面了？",
        "answer": "理论和实践在某些方面没有明显差异，但在实际应用中，命令行的重要性对于初学者乃至深入研究的人来说是绕不开的话题。是的，现在许多新学习电脑的人可能直接开始使用命令行，而较少依赖图形界面。但未来他们仍会需要补上这方面的知识。",
        "time": "00:32:50"
      },
      {
        "question": "早期计算机开机默认是图形界面吗？",
        "answer": "在90年代的中国，计算机开机通常不会自动进入图形界面，而是类似IBM PC兼容机那样，开机后会出现BIOS自检、C盘符等字符界面，需要通过输入特定命令（如win）才能进入图形界面。",
        "time": "00:33:11"
      },
      {
        "question": "是否有命令行文件管理软件的例子？",
        "answer": "早期有一款名为Total Commander的命令行文件管理软件，它虽然不是图形界面，但提供了类似图形界面的操作方式，用户可以通过命令行进行各种文件操作。",
        "time": "00:37:24"
      },
      {
        "question": "命令行的历史起源是什么时候？",
        "answer": "命令行的历史可以追溯到50年代和60年代，当时计算机通过电传打字机（teletype）作为显示终端，用户在纸上编写程序，然后通过打孔机将程序输入远端计算机，最终由电传打字机接收并执行程序。",
        "time": "00:43:40"
      },
      {
        "question": "当时人们如何解决电话线路仅限于打电话的问题，从而实现计算机间的通信？",
        "answer": "人们利用Acoustic coupler（声音耦合器）将电话线路转化为能够传输二进制信息的模拟声音信号，从而实现远程通信。直到70年代初，贝尔公司取消了相关限制，人们才逐渐不再使用这种原始的方法。",
        "time": "00:45:52"
      },
      {
        "question": "acoustic couple和现代技术的本质区别是什么？",
        "answer": "acoustic couple与现代技术本质上都是为了实现信息传输，但它们接入方式不同。acoustic couple利用声音波进行信息传输，而现代技术如通过无线电波传输WiFi信号。",
        "time": "00:49:22"
      },
      {
        "question": "RJ32是什么类型的接头？",
        "answer": "RJ32应该是指RJ11或RJ14等小型电话接头，而非RJ45网线接头。RJ45通常用于网线连接，而RJ11或RJ14则常用于电话线连接。",
        "time": "00:50:04"
      },
      {
        "question": "为什么现在很多人选择用网线代替电话线？",
        "answer": "因为网线不仅可以用于上网，还能支持更高带宽，如百兆甚至千兆。但同时提醒，如果要装修房子，不建议仅依赖网线而不单独布设电话线，因为有时仍需电话服务。",
        "time": "00:50:46"
      },
      {
        "question": "电传打字机的工作原理是怎样的？",
        "answer": "电传打字机通常会在一行上工作，输入和输出都受限于一行长度，若需输入多行内容需通过特定符号告知机器。这一特性影响了后续计算机历史中命令行的概念发展。",
        "time": "00:52:12"
      },
      {
        "question": "TTTY在操作系统中的作用是什么？",
        "answer": "TTTY是一个模拟电传打字机终端的伪终端，在操作系统中，用户通过键盘输入的信息和从主机获取的输出信息都是通过TTTY进行交互，它就像是一个可以支配的虚拟电传打字机，允许用户在屏幕上进行操作，就如同早期电传打字机与主机交互的方式一样。",
        "time": "00:56:03"
      },
      {
        "question": "早期电传打字机如何处理输入错误？",
        "answer": "早期电传打字机打错字符无法修改，可能需要整行重写。而有一些电传打字机可能通过backspace键来删除错误字符，但具体操作方式取决于不同的机型。",
        "time": "00:59:41"
      },
      {
        "question": "shell这个名字在早期使用时是否具有迷惑性？",
        "answer": "是的，shell这个名字在最初接触时确实有些迷惑性，因为它实际上是指用来接收和执行用户输入命令的一个小工具，通过命令行与内核交互。但需要注意的是，并非所有运行在内层的程序都被称为shell，例如还有其他一些程序不会直接与用户打交道。",
        "time": "01:04:58"
      },
      {
        "question": "在图形层中，shell应该对应于哪一层？",
        "answer": "如果将图形层进行类比，shell应该对应于用户界面层或组件层，但其复杂度和层级要远高于此。",
        "time": "01:05:52"
      },
      {
        "question": "早期shell有哪些主要功能？",
        "answer": "早期的shell主要面向行操作，用户在终端上与远程机交互时，所有的交互都限制为一行输入命令。其中，Unix早期作者之一Ken Thompson在其编写的Unix shell中实现了输入输出重定向功能，这是通过大于号(>)和小于号(<)实现的，这一特性在1971年的Unix系统中就已经存在。",
        "time": "01:06:17"
      },
      {
        "question": "V7版本对shell发展有何影响？",
        "answer": "1979年发布的Unix V7版本中，出现了一个叫做Bourne Shell（sh）的版本，由Stephen Born编写，它延续了Ken Thompson版本的特性，并且因其向后兼容性而被广泛使用。后来，符合POSIX标准的shell也会被称为“SH”。",
        "time": "01:08:11"
      },
      {
        "question": "C Shell（csh）有何创新之处？",
        "answer": "C Shell诞生于1978年，其设计初衷是让shell语法尽量接近C语言语法，尤其在当时Unix系统大多用C编写的情况下。C Shell引入了诸多创新，如history命令显示之前输入过的命令，以及支持job control功能，允许用户暂停、后台执行或重新启动任务。",
        "time": "01:10:59"
      },
      {
        "question": "Korn Shell（ksh）与C Shell相比有何不同？",
        "answer": "Korn Shell（ksh）是在1980年左右由David Korn为贝尔实验室编写的，虽然也包含一些创新功能，但没有C Shell那么多。Ksh并未像Csh那样流行起来，特别是在Unix分裂和Linux兴起的过程中，Bash逐渐取代了SH成为主流外壳。",
        "time": "01:15:33"
      },
      {
        "question": "Bash shell是如何发展的？",
        "answer": "Bash shell是在1980年代初作为GNU项目的一部分独立开发的，它的设计目标是吸收原有SH、Csh的优点，并提供更强大的功能。当Linux兴起时，Bash成为默认的外壳，并且自由软件基金会重新开发了版本，命名为 Bourne-again shell（bash），以适应新的环境。",
        "time": "01:16:29"
      },
      {
        "question": "目前主流的shell有哪些？",
        "answer": "现在主要剩下的shell有：绝大多数Linux发行版和Mac OS X默认使用的bash，一小部分用户坚持使用zsh，以及在精简系统或嵌入式系统上常见的busy box自带的ash。",
        "time": "01:23:15"
      },
      {
        "question": "在不同系统中，BNSH指向的具体是什么？",
        "answer": "在30里面，bin SH可能是默认的original born shell；在Linux中可能是GU bash；而在open BSD中可能会使用KSH93。With positive extensions。",
        "time": "01:22:02"
      },
      {
        "question": "现状如何？",
        "answer": "时光机快进到2010年或21世纪第一个十年，我们仍然在使用CL，但我个人使用的shell是z shell。",
        "time": "01:22:55"
      },
      {
        "question": "是否有推荐学习或使用的shell？",
        "answer": "对于初学者，由于大部分Linux教程使用bash作为主要教学工具，建议先从bash入手；但如果追求复杂度低、适合资源有限系统的，则可以考虑使用ash。",
        "time": "01:24:07"
      },
      {
        "question": "为什么不能直接使用最新的bash版本？",
        "answer": "因为从bash 4.0开始，其自带的版本特别老，由于GPLV3授权协议与商业不开源产品存在冲突，所以基于OSN的产品中的bash可能只能停留在某个老版本系列，无法升级到更新的版本。",
        "time": "01:24:07"
      },
      {
        "question": "ZSH的来历是怎样的？",
        "answer": "ZSH是在1990年由一个叫Foster的学生在读普林斯顿时创建的，受其导师邵中中（ZSH中少）启发，因其导师名中的\"ZSH\"而得名。ZSH最初是为了给古老的系统带来更多的优化和强大功能。",
        "time": "01:26:34"
      },
      {
        "question": "ZSH相比bash有哪些优点？ZSH是否有一些只有它才有的特性？",
        "answer": "ZSH提供了如 extensive 的输入提示、自动补全路径、命令纠错等功能，并且可以显示远程服务器路径，还支持在屏幕右侧显示promote（提示符），这对于一些需要额外信息的操作非常方便。是的，ZSH的一些高级特性，在当时是shell用户无法比拟的，比如其强大的自动补全和提示功能，以及屏幕右侧的promote显示等。",
        "time": "01:28:48"
      },
      {
        "question": "ZSH在特性完成度上与现代版本的bash相比如何？",
        "answer": "虽然现代版本的bash通过各种方式逐渐实现了ZSH的很多高级特性，但在90年代，ZSH的很多特性对于当时的shell用户来说是不可想象的。",
        "time": "01:30:04"
      },
      {
        "question": "为什么从bash切换到zsh？",
        "answer": "最终切换的原因在于zsh的killer feature（杀手级特性）——右侧的promote功能，在大部分情况下，两个shell的语法兼容，但在某些特定功能上，zsh更为强大和实用。",
        "time": "01:31:43"
      },
      {
        "question": "在使用item时，为了使其看起来更漂亮，你会遇到配色方案的问题吗？",
        "answer": "是的，如果想让item看起来更好，确实会涉及到配色方案的问题，这可能会让人觉得是个大坑。",
        "time": "01:38:07"
      },
      {
        "question": "为什么在60年代后，历史包袱仍然限制着我们对颜色的选择？",
        "answer": "在过去的四五十年里，历史包袱一直套在头上，导致我们无法完全摆脱对十六色、256色等限制的关注。而在fish shell中就没有这个问题了，可以自由选择颜色，因为它无需考虑兼容性问题。",
        "time": "01:38:24"
      },
      {
        "question": "DOS是否被称为shell？",
        "answer": "DOS并不把自己称为shell，而是称为promotion，并且在现代Windows系统中，通过开始菜单搜索CMD可以打开命令行窗口。",
        "time": "01:39:08"
      },
      {
        "question": "PowerShell是什么时候开始出现的？PowerShell与Unix shell相比有何不同？",
        "answer": "PowerShell是在Windows Vista或7的时候开始出现的，最初是为了整合各种图形界面操作以命令行方式执行。PowerShell语法较为陡峭，区分大小写，参数和操作方法较为繁琐。虽然设计原则是所有图形界面能做的事情都可以通过命令行完成，但其功能完整性和灵活性不如Unix shell，不过在功能传递方面，PowerShell利用结构化数据传输，避免了文本序列化反序列化带来的问题。",
        "time": "01:40:28"
      },
      {
        "question": "命令行窗口中常用的命令有哪些？",
        "answer": "在命令行窗口中，人们最常用的命令之一是ping，用于检测IP地址连通性；另一个常用命令是NS lookup，用于查询DNS记录。",
        "time": "01:40:47"
      },
      {
        "question": "为什么命令行至今仍具有旺盛的生命力？",
        "answer": "命令行的魅力在于其简单易用、可预见性和一致性，用户只需关注一个输入源，执行效率高。同时，命令行下的工具往往更加精炼、直接，且由于命令行生态系统的do one thing and doing well的设计哲学，使得每个工具都专注于某一特定功能并做得极致，而这些工具之间的组合性和可扩展性是图形界面环境下较难实现的。",
        "time": "01:48:11"
      },
      {
        "question": "在图形界面中，有没有类似于在命令行下批量修改文件名的功能？",
        "answer": "在图形界面中，最接近实现批量改文件名功能的是像OSN自带的自动化工具，比如Automator，它可以进行一些高级操作，如批量从PDF文件抽取页面并转换成图片文件，或者批量修改文件图片格式、大小和压缩等。但它的学习曲线较陡峭。",
        "time": "01:53:34"
      },
      {
        "question": "命令行的优点是什么？命令行有什么缺点吗？",
        "answer": "命令行的优点在于通过编程语言编写的代码能够对文本进行高级操作，并能通过调用系统命令（如move命令）执行实际任务，提高了效率。命令行的一个主要缺点是发现性较差，用户若不知道如何通过命令行实现某个功能，则难以查找。需要用户自己去阅读手册或累积实践经验，甚至可能需要有人指导才能掌握某些操作，例如在早期Linux环境下不知道如何用move命令来改名文件。",
        "time": "01:54:10"
      },
      {
        "question": "现在有哪些资源可以帮助我们更好地学习和使用命令行工具？",
        "answer": "现在有许多网络资源可以提供命令行工具的使用提示和教程，比如bony food等网站会发布一些小摘要内容，告诉用户如何使用特定命令组合实现所需功能。",
        "time": "01:56:13"
      },
      {
        "question": "是否有推荐的一些有趣或实用的命令行工具？",
        "answer": "推荐LOL cat工具，它可以将文本内容以彩虹颜色输出到屏幕上；另外还有tig工具，它是基于 ncurses 的图形界面工具，用于显示Git源代码管理的历史和常用操作。",
        "time": "01:59:18"
      },
      {
        "question": "iPython和bPython分别是什么？",
        "answer": "iPython是一个交互式Python环境，可以在命令行或网页版本运行Python程序，具有语法高亮、traceback追踪等功能，并支持Python新特性。而bPython则是Python的一个轻量级rap（read-evaluate-print-look）工具，同样具备语法高亮和多行模式支持，特别之处在于它可以提示用户使用的标准库函数的签名和参数说明，是一个功能较为精简且实用的交互工具。",
        "time": "02:05:45"
      },
      {
        "question": "i perf 3是什么，它主要用于什么场景？",
        "answer": "i perf 3是一个用于网络性能测试的工具，可以帮助用户测试家里的装修师傅安装的网线是否达到千兆速度。通过在两台电脑上分别运行server和client端，可以测量网络连接的最大传输速度。",
        "time": "02:06:46"
      },
      {
        "question": "接下来介绍的t mox是什么？它有什么功能？",
        "answer": "t mox是一个终端复用器，它允许在已建立的远程连接或本地终端窗口中新开多个子窗口，保持登录状态，并且即使关闭主窗口，子进程仍能继续运行。它支持通过组合键创建并切换多个终端实例，且能保留程序状态。",
        "time": "02:07:37"
      },
      {
        "question": "t max相较于screen有何优势？",
        "answer": "t max相比screen具有更强大的功能和更好的用户体验，尤其是支持pair programming，即两人可以同时通过各自的终端连接到同一台服务器上的同一个终端，互相看到对方的操作并进行实时互动，而screen在这方面较为古老，功能没有t max那么强大。",
        "time": "02:10:33"
      },
      {
        "question": "tree工具的作用是什么？",
        "answer": "tree工具用于在命令行界面中直观地显示文件系统的树状结构，不同于ls命令只能列出当前或指定目录下的文件，tree可以展示整个文件系统的层级结构，有助于用户更好地理解和导航文件系统。",
        "time": "02:11:43"
      },
      {
        "question": "midnight commander（MC）是一款什么样的工具？h top工具是做什么用的？",
        "answer": "midnight commander（MC）是一款跨平台的命令行文件管理工具，类似于total commander，具备列出当前目录、批量拷贝、批量重命名等功能，对于熟悉total commander的用户来说，MC提供了相似的操作体验，且同样具有良好的跨平台兼容性。h top是一款改良版的top命令，它以更直观易懂的方式展示系统当前活跃进程及系统状态，如CPU和内存占用情况，并以进度条形式展现，还支持以树状结构展示进程列表，提供了许多高级功能，是系统管理必备的工具之一。",
        "time": "02:12:28"
      },
      {
        "question": "如何使用open命令在OS X系统中打开文件或剪贴板内容？",
        "answer": "在OS X系统中，open命令可以用来打开文件或系统剪贴板内容。例如，open .会在 finder 中打开当前目录，而 open *PDF 则会自动调用预设默认程序（如 preview 或 AOOB reader）打开当前目录下的所有 PDF 文件。此外，还可以利用 pbcopy 和 pbpaste 命令将剪贴板内容复制到系统或从系统粘贴出来。",
        "time": "02:16:02"
      }
    ],
    "chapters": [
      {
        "time": "00:00:00",
        "title": "内核恐慌：IT技术主题娱乐节目",
        "summary": "本期节目来自IPM podcast网络旗下的IT技术主题娱乐节目《内核恐慌》，节目以轻松幽默的方式探讨IT相关话题。节目中提到，听众可以通过podcast客户端订阅节目，访问特定网站获取更多详情。此外，还介绍了捐款支持节目的方式，强调捐款金额需为八的正整数倍，但同时说明捐款不会为捐款者带来任何实质性的回报。节目以独特的口号结束，表达了对IT工作热情的态度。"
      },
      {
        "time": "00:00:45",
        "title": "听众反馈：QQ发代码与计算机课程讨论",
        "summary": "切普罗先生从澳大利亚反馈关于使用QQ发送代码的问题，提到了组合作业时由于不使用Git等版本控制工具而导致的效率问题。讨论了国内外在计算机课程教学上的差异，以及计算机学科的覆盖面广泛问题，强调了个人修行的重要性。此外，还提及了一个小插曲，讨论了“码农”和“软件工程师”的区别。"
      },
      {
        "time": "00:02:48",
        "title": "软件工程师应具备工具和实践知识",
        "summary": "对话指出，许多人认为计算机科学与工程实践脱节，强调理论而轻视实践技能，如使用开发工具和遵循最佳实践。批评指出，如果软件工程专业不教授这些基础技能，那么就不应自称教授工程。同时，讨论了纯理论研究与实践之间的差异，认为计算机科学与工程系应平衡理论教育和实践技能培养，以满足就业市场需求。还提到了对密歇根大学的误称，并纠正了上期节目中的错误。"
      },
      {
        "time": "00:07:20",
        "title": "听众对播客节目的反馈与期待",
        "summary": "一位从事交互设计行业的听众分享了对‘内核恐慌’播客节目的热爱，表示从第一期开始追逐，评价极高。尽管转行，但仍积极关注技术领域，特别喜欢节目中涉及设计、产品、MVP等话题。听众还表达了与播客嘉宾进行合作的意愿，但因担心被误解而放弃。最后，听众对播客的未来表达了乐观态度，期望节目能继续带来启发和快乐。"
      },
      {
        "time": "00:12:26",
        "title": "软件工程师称号是否恰当",
        "summary": "讨论源自一篇文章，指出软件工程师使用'工程师'这一称号可能不合适，因为软件的不可靠性与传统工程基础设施的可靠性存在差异。文章强调了工程师称号的庄严性和高门槛，而科技行业中，许多人倾向于自称软件工程师，这可能对工程师的形象造成负面影响。讨论也涉及了如Facebook和Twitter等服务的频繁故障，尽管这些服务已成为人们日常生活的一部分，但其可靠性仍不及传统基础设施。同时，也提到了考虑软件使用频次和问题量级的重要性。"
      },
      {
        "time": "00:15:23",
        "title": "探讨Flutter框架及对移动开发的影响",
        "summary": "对话中提及了两个主题：首先介绍了Google推出的移动编程框架Flutter，强调其主要特点为使用Dart语言编写，能够跨平台支持Android和iOS应用开发，可能减少对Java的依赖。其次，讨论了个人对于Google以往项目推广情况的看法，指出了Google在推广新技术方面存在的问题，并以Flutter为例，对其未来发展表示谨慎乐观。"
      },
      {
        "time": "00:21:31",
        "title": "浮点数运算中的精度问题及解决方案",
        "summary": "讨论了浮点数运算中的精度问题，特别是当使用0.1加0.2时得到的结果不理想，由于二进制无法精确表示十进制下的某些分数，导致出现误差。IEE754标准规定了如何用二进制表示浮点数，但仍然存在精度损失。文中提及，不同编程语言和库提供了多种解决方法，如使用任意精度的十进制数库或以分数形式表示数字来避免精度问题。此外，还讨论了float和double类型在计算机中的精度和表示范围，强调了在编程时对于浮点数运算要格外小心。"
      },
      {
        "time": "00:28:13",
        "title": "探讨编程语言中浮点数的处理及命令行使用",
        "summary": "讨论集中在编程语言如何处理浮点数的加法运算，特别是PHP将0.1加0.2的结果显示为0.3的处理方式，以及Python对于浮点数的近似值打印。此外，还提到了在工业测量中判断浮点数大小和相等性的正确方法，强调了理论与实践之间的差异。最后，简要提及了命令行的主题，暗示了后续的讨论方向。"
      },
      {
        "time": "00:32:30",
        "title": "计算机发展史：从命令行到图形界面",
        "summary": "对话围绕计算机技术的发展，特别是从早期的命令行界面到后来的图形用户界面的转变。讨论了初学者在学习计算机时可能会遇到的不同操作系统和界面，回忆了90年代中国计算机用户的童年记忆，那时候计算机开机不会自动进入图形界面。此外，还提及了一些历史上的操作系统和软件，如Windows 3.1、Total Commander等，以及一些经典游戏。最后，讨论了从命令行到图形界面的转变对计算机使用体验的影响。"
      },
      {
        "time": "00:41:18",
        "title": "从电传打字机到声学耦合器：早期计算机通信技术的演变",
        "summary": "在20世纪50至60年代，计算机技术尚未发展到能够在屏幕上实时显示和操作图形。当时，电视已经普及，但计算机并未采用电视作为显示终端，而是使用电传打字机。电传打字机，由Teletype公司制造，在当时几乎是西方世界各大学和机构的标准设备。文本描述了人们如何通过这种设备进行编程，以及贝尔公司对电话线路的限制如何影响了早期计算机通信技术的发展。随着技术的进步，声学耦合器（Acoustic coupler）的使用使得通过电话线传输计算机数据成为可能，直至贝尔公司最终解除电话线路的限制。此外，文中还提到了现代技术中利用高频声波进行数据传输的应用，反映了声学通信原理的持续影响。"
      },
      {
        "time": "00:49:03",
        "title": "从无线到有线：调制解调器和网络接口的演变",
        "summary": "对话内容主要围绕调制解调器的功能演变，从最初的通过电话线进行拨号的有线连接，到后来的无线连接技术，以及现代装修中网线的布设方式。提及了RJ11、RJ45等不同类型的接口标准及其用途，同时指出了现在大部分家庭已经不再需要传统电话线，转而采用更加灵活的无线网络解决方案。"
      },
      {
        "time": "00:52:12",
        "title": "电传打字机及其对计算机历史的影响",
        "summary": "电传打字机，以其典型的50年代外观和仅允许在一行上工作的特性，对后续60年的计算机历史产生了深远的影响。这种设备限制了输入输出的行数，促使了命令行界面的产生，其中的每行输入都成了与计算机交互的基本单位。此外，电传打字机的术语和概念，如TTY（teletype的缩写），至今仍在现代操作系统中使用，暗示着早期硬件对现代技术的持续影响。通过软件模拟的伪终端（PTTY）延续了电传打字机的功能，使得标准输入输出得以实现，展示了早期技术如何塑造了当前的计算机互动模式。"
      },
      {
        "time": "00:57:39",
        "title": "从电传打字机到数字设备公司的单色显示器",
        "summary": "讨论了终端模拟器的使用与游戏的不同，提到了DEC（Digital Equipment Corporation）公司研发的单色显示器代替了传统的TTY（电传打字机）设备，实现了从纸质打印到电子显示的转变。讨论还涉及了早期电传打字机的局限性，如无法修改输入错误，以及后来玻璃终端如何解决了这一问题，使得用户可以编辑输入，尽管本质上仍在模拟电传打字机与主机的交互方式。"
      },
      {
        "time": "01:00:32",
        "title": "从电传打字机到Unix时代的技术演变",
        "summary": "对话从经典的电传打字机Model 33ASR及其速率讲起，描述了账单大门先生的编程起点，体现了早期技术的限制与魅力。随后，讨论转向了早期的BBS系统，突出了离线通信的方式，以及随着时间推移，技术进步带来的变化。最终，进入Unix时代，提到了Multics操作系统和Unix的兴起，以及终端和Shell概念的引入，展示了操作系统和用户界面的历史演进。"
      },
      {
        "time": "01:04:22",
        "title": "Unix Shell的历史和发展",
        "summary": "对话内容主要围绕Unix Shell的发展历程、重要特性及其在计算机系统中的作用进行讨论。最初，Shell作为一个用户与内核交互的工具，允许用户通过命令行输入命令并展示执行结果。随着Unix的发展，Shell的功能逐渐丰富，如输入输出重定向和管道服务等功能的引入，极大地增强了其功能性和实用性。讨论还提到了一些关键人物和Shell版本，如早期的Unix开发者对Shell的发展贡献，以及Bourne Shell的广泛使用和POSIX标准的定义。整体上，这段对话深入探讨了Shell在Unix系统中的核心地位和其技术演进的历史背景。"
      },
      {
        "time": "01:10:13",
        "title": "Unix发展史及Shell的演进",
        "summary": "对话详细回顾了Unix系统及其Shell的发展历程，重点介绍了1978年Billy Joy研发的C Shell（csh）的背景、设计理念及其对后续Unix发展的影响。C Shell旨在使Shell语法接近C语言，引入了如命令历史、作业控制等创新特性，极大地丰富了Unix系统的功能性和用户交互体验。此外，还提到了Korn Shell（ksh）的发布以及Unix历史上因版权和商业化引发的争议，这为其他操作系统的发展提供了机遇。"
      },
      {
        "time": "01:16:17",
        "title": "Bash及其他Shell的发展历史与特点",
        "summary": "对话中提及了多种Shell的历史及其在Linux和Unix系统中的应用。KHL（由David开发）并未流行，而是在Unix的官方版本中仍有使用。BSDE因为KHL源码未公开而避免使用它。随着Linux的兴起，Geno Bash变得流行，自由软件基金会也对SH进行重新开发，命名为Bash，意为“凶狠的击打”，成为最常用的Shell之一。Debian将默认Shell改为Dash，一种轻量级的Shell，旨在提高脚本运行效率。此外还提到了一些不常见的Shell，如PSH和Another shell，它们分别用于使用Perl语言和教学目的。讨论强调了兼容性（SH兼容）的重要性，并通过不同系统中BNSH指向的Shell版本（如original born shell、GU bash、KSH93等）来说明。"
      },
      {
        "time": "01:22:53",
        "title": "从2010年视角看Shell的发展",
        "summary": "2010年，随着21世纪第一个十年的结束，shell领域经历了显著的变化。大部分Linux发行版和OS默认使用bash，而一小部分用户坚持使用Z shell（ZSH），特别是在嵌入式系统中，如BusyBox自带的ash。由于授权协议的问题，某些商业系统如AOSN可能无法升级到bash 4.0以上版本，而Z shell因为采用了更灵活的MIT协议，得以在各种系统上持续更新至较新版本。Z shell自1990年由Foster开发以来，以其复杂而强大的功能，如输入提示、自动补全远程服务器路径等，赢得了用户的青睐。此外，Z shell的一些高级特性逐渐也被新版本的bash所吸收，显示了这两个shell在功能上的趋同。至2010年前后，oh-my-zsh项目成为Z shell用户社区的一个亮点。"
      },
      {
        "time": "01:30:49",
        "title": "从Bash到Zsh的切换原因及体验分享",
        "summary": "在讨论中，参与者分享了从Bash切换到Zsh的原因和体验。Zsh因为其丰富的配置选项、主题和插件集合而受到青睐，特别是其命令行提示和自动补全功能的优越性。尽管在办公室和公司环境中仍使用Bash，但个人使用中Zsh提供了更多的便利和个性化选项，比如自定义提示符和易于使用的语法，使得切换到Zsh成为一种更优选择。尽管存在兼容性和通用性方面的考量，Zsh的新功能和用户友好性最终促成了这次切换。"
      },
      {
        "time": "01:36:18",
        "title": "现代Shell的创新与挑战",
        "summary": "近年来，一些新的Shell尝试打破传统的历史包袱，追求更现代化的功能和用户体验。其中，fish Shell因其不追求与历史Shell（SH）的兼容性而受到关注，它引入了许多现代特性，如语法高亮、自动补齐的下拉列表和自定义主题配色等，极大地提升了用户交互体验。这些创新使得用户在使用时感觉像是在使用集成开发环境（IDE），而非传统的命令行界面。尽管如此，这些现代Shell的普及仍然面临着兼容性、用户习惯等挑战。"
      },
      {
        "time": "01:38:59",
        "title": "探讨命令行界面的历史和PowerShell的优势",
        "summary": "对话深入讨论了命令行界面（CLI）在Windows系统中的演进，特别是从传统的CMD到较新的PowerShell的转变。指出了尽管图形用户界面（GUI）普及，CLI仍因其强大功能而不可或缺。PowerShell的引入被视作Windows系统对于命令行操作的革新，它提供了比以往更强大的功能和灵活性，包括大小写敏感、结构化数据处理等，以及能够通过命令行完成所有图形界面操作的能力。此外，讨论还触及了PowerShell与Unix/Linux shell的显著差异，特别是在数据传输方式和语法上。总体上，这次对话强调了即使在现代操作系统中，CLI仍然是一种不可或缺的工具，PowerShell代表着向更高效、功能更全面的命令行工具的迈进。"
      },
      {
        "time": "01:44:34",
        "title": "命令行的魅力及在现代应用中的生命力",
        "summary": "命令行自60年代起便因其简单易懂的特点而被广泛使用，虽然在图形界面普及的今天，其在单一时间内的专注性以及直接性仍然展示了其无可比拟的效率和魅力。尽管图形界面提供了直观的操作方式，但过多的视觉元素往往导致分心，与之相比，命令行的简洁使其成为高效执行特定任务的首选。特别是在Unix系统中，命令行工具遵循'做一件事并做好'的设计哲学，工具间的可组合性使得复杂的操作变得简单，这正是命令行生态系统最大的魅力所在。"
      },
      {
        "time": "01:49:40",
        "title": "图形界面与命令行的优劣比较及文件处理挑战",
        "summary": "讨论集中在图形界面和命令行界面之间的操作差异，特别是文件和数据处理的效率与灵活性。图形界面虽然直观易用，但在文件处理、数据传递方面存在局限性，如缺乏通用接口导致不同工具之间难以直接交互。相比之下，命令行界面通过编程语言的支持，能够执行更复杂和抽象的操作，如批量修改文件名等任务，展现了其在处理特定任务上的优势。此外，也提到了一些图形界面下的自动化工具，虽然功能强大，但学习成本较高。"
      },
      {
        "time": "01:54:09",
        "title": "探讨命令行的优缺点及实用工具",
        "summary": "命令行具有发现性差的缺点，用户不易于找到所需功能，与图形界面相比，用户需自行探索或通过学习积累。讨论了在使用Linux和Windows系统时，用户可能遇到的问题，例如文件重命名和批量处理文件格式转换。同时介绍了几个实用的命令行工具，如LOL cat和tig，以及通过网络资源学习命令行的便利性。"
      },
      {
        "time": "02:01:30",
        "title": "介绍有趣的命令行工具：cos、fortune 和 MTR",
        "summary": "对话中提到了几个有趣的命令行工具，首先是cos，它可以将输入包裹成漫画气泡框样式，并在旁边画上一头牛。接着是fortune工具，用于生成名人名言，类似中餐馆里的fortune cookie。最后介绍了MTR工具，这是一个结合了ping和trace route功能的网络诊断工具，提供更友好和有用的网络状态报告。"
      },
      {
        "time": "02:04:41",
        "title": "Python开发工具及网络性能测试工具介绍",
        "summary": "介绍了Python开发中常用的工具，包括iPython、BPython以及它们的特点和优势。iPython是一个功能强大的Python笔记本，支持命令行、网页版本和基于QT的图形界面，能够运行Python程序并尝试新功能，具有语法高亮、traceback等功能。BPython作为另一个Python解释器，提供了语法高亮和函数签名提示等功能，相比iPython更为轻量级。此外，还介绍了用于网络性能测试的工具iPerf3，可用于测试网络连接的传输速度。最后，提到了tmux，一个终端复用器，可以复用当前的链接在终端窗口内开启多个其他终端窗口，保持登录和程序状态，非常适合远程工作或需要长时间运行程序的场景。"
      },
      {
        "time": "02:10:01",
        "title": "探讨高级命令行工具和技巧",
        "summary": "对话中讨论了多种高级命令行工具和技巧，包括tmux和screen的比较，强调tmux的优越性；介绍了tree命令用于导航文件系统，以及midnight commander作为跨平台的文件管理工具。此外，还提到了htop作为top命令的增强版，以及在OS X中使用open、pbcopy和pbpaste命令进行文件管理和剪贴板操作。最后，推荐了一个网站come online FU dot com，供听众学习更多命令行技巧。"
      }
    ],
    "mindmap": {
      "children": [
        {
          "children": [
            {
              "children": [
                {
                  "children": [],
                  "content": "电传打字机：早期的计算机输入输出设备，促进了命令行的发展。"
                },
                {
                  "children": [],
                  "content": "UNIX的诞生：引入了shell的概念，将用户与操作系统连接。"
                },
                {
                  "children": [],
                  "content": "不同Shell的演变：从早期的Bourne Shell (sh) 到后来的C Shell (csh)，Bash，Z Shell (zsh) 等。"
                },
                {
                  "children": [],
                  "content": "命令行的发展：从电传打字机到图形界面，再到现代命令行工具的多样性。"
                }
              ],
              "content": "历史回顾"
            },
            {
              "children": [
                {
                  "children": [],
                  "content": "系统管理：利用命令行进行高效的系统配置和维护。"
                },
                {
                  "children": [],
                  "content": "开发工具：用于编程、测试和调试的高效工具。"
                },
                {
                  "children": [],
                  "content": "数据处理：批处理脚本和数据处理任务的执行。"
                },
                {
                  "children": [],
                  "content": "自动化任务：通过脚本执行重复性任务，提高效率。"
                }
              ],
              "content": "命令行的现代应用场景"
            },
            {
              "children": [
                {
                  "children": [],
                  "content": "iTerm2：提供高级功能的终端模拟器。"
                },
                {
                  "children": [],
                  "content": "Midnight Commander (mc)：命令行下的文件管理器。"
                },
                {
                  "children": [],
                  "content": "Git：版本控制系统，通过命令行操作。"
                },
                {
                  "children": [],
                  "content": "rsync：高效的数据同步工具。"
                },
                {
                  "children": [],
                  "content": "tmux：终端复用器，用于管理多个会话。"
                },
                {
                  "children": [],
                  "content": "htop：系统监控工具，提供更直观的界面。"
                }
              ],
              "content": "命令行工具推荐"
            },
            {
              "children": [
                {
                  "children": [],
                  "content": "优点：快速执行任务，高度可定制，适合自动化操作。"
                },
                {
                  "children": [],
                  "content": "缺点：学习曲线陡峭，新手友好度低，错误容易造成系统问题。"
                }
              ],
              "content": "命令行的便捷与复杂性"
            },
            {
              "children": [
                {
                  "children": [],
                  "content": "技术发展：命令行工具继续演化，向更高效、更用户友好的方向发展。"
                },
                {
                  "children": [],
                  "content": "教育普及：提升用户对命令行工具的认识和使用技巧。"
                },
                {
                  "children": [],
                  "content": "社区支持：通过共享技巧和经验，形成强大的用户社区。"
                }
              ],
              "content": "面向未来的命令行"
            }
          ],
          "content": "主题：命令行与Shell的探索"
        },
        {
          "children": [
            {
              "children": [],
              "content": "PB copy/PB paste：在macOS中用于复制和粘贴文本到剪贴板。"
            },
            {
              "children": [],
              "content": "open命令：用于在macOS中打开文件或目录。"
            },
            {
              "children": [],
              "content": "tree命令：显示目录结构，帮助用户导航文件系统。"
            },
            {
              "children": [],
              "content": "iTerm2的双击查找：在终端中双击文字以快速搜索相关信息。"
            }
          ],
          "content": "附录：实用命令行技巧"
        }
      ],
      "content": "播客节目内容脑图摘要"
    }
  }
}